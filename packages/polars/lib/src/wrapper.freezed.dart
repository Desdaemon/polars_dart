// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'wrapper.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AggExpr {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AggExprCopyWith<$Res> {
  factory $AggExprCopyWith(AggExpr value, $Res Function(AggExpr) then) =
      _$AggExprCopyWithImpl<$Res, AggExpr>;
}

/// @nodoc
class _$AggExprCopyWithImpl<$Res, $Val extends AggExpr>
    implements $AggExprCopyWith<$Res> {
  _$AggExprCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AggExpr_MinCopyWith<$Res> {
  factory _$$AggExpr_MinCopyWith(
          _$AggExpr_Min value, $Res Function(_$AggExpr_Min) then) =
      __$$AggExpr_MinCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr input, bool propagateNans});

  $ExprCopyWith<$Res> get input;
}

/// @nodoc
class __$$AggExpr_MinCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_Min>
    implements _$$AggExpr_MinCopyWith<$Res> {
  __$$AggExpr_MinCopyWithImpl(
      _$AggExpr_Min _value, $Res Function(_$AggExpr_Min) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? propagateNans = null,
  }) {
    return _then(_$AggExpr_Min(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as Expr,
      propagateNans: null == propagateNans
          ? _value.propagateNans
          : propagateNans // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get input {
    return $ExprCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value));
    });
  }
}

/// @nodoc

class _$AggExpr_Min implements AggExpr_Min {
  const _$AggExpr_Min({required this.input, required this.propagateNans});

  @override
  final Expr input;
  @override
  final bool propagateNans;

  @override
  String toString() {
    return 'AggExpr.min(input: $input, propagateNans: $propagateNans)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_Min &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.propagateNans, propagateNans) ||
                other.propagateNans == propagateNans));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input, propagateNans);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_MinCopyWith<_$AggExpr_Min> get copyWith =>
      __$$AggExpr_MinCopyWithImpl<_$AggExpr_Min>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return min(input, propagateNans);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return min?.call(input, propagateNans);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (min != null) {
      return min(input, propagateNans);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return min(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return min?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (min != null) {
      return min(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Min implements AggExpr {
  const factory AggExpr_Min(
      {required final Expr input,
      required final bool propagateNans}) = _$AggExpr_Min;

  Expr get input;
  bool get propagateNans;
  @JsonKey(ignore: true)
  _$$AggExpr_MinCopyWith<_$AggExpr_Min> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_MaxCopyWith<$Res> {
  factory _$$AggExpr_MaxCopyWith(
          _$AggExpr_Max value, $Res Function(_$AggExpr_Max) then) =
      __$$AggExpr_MaxCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr input, bool propagateNans});

  $ExprCopyWith<$Res> get input;
}

/// @nodoc
class __$$AggExpr_MaxCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_Max>
    implements _$$AggExpr_MaxCopyWith<$Res> {
  __$$AggExpr_MaxCopyWithImpl(
      _$AggExpr_Max _value, $Res Function(_$AggExpr_Max) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? propagateNans = null,
  }) {
    return _then(_$AggExpr_Max(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as Expr,
      propagateNans: null == propagateNans
          ? _value.propagateNans
          : propagateNans // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get input {
    return $ExprCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value));
    });
  }
}

/// @nodoc

class _$AggExpr_Max implements AggExpr_Max {
  const _$AggExpr_Max({required this.input, required this.propagateNans});

  @override
  final Expr input;
  @override
  final bool propagateNans;

  @override
  String toString() {
    return 'AggExpr.max(input: $input, propagateNans: $propagateNans)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_Max &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.propagateNans, propagateNans) ||
                other.propagateNans == propagateNans));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input, propagateNans);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_MaxCopyWith<_$AggExpr_Max> get copyWith =>
      __$$AggExpr_MaxCopyWithImpl<_$AggExpr_Max>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return max(input, propagateNans);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return max?.call(input, propagateNans);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (max != null) {
      return max(input, propagateNans);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return max(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return max?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (max != null) {
      return max(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Max implements AggExpr {
  const factory AggExpr_Max(
      {required final Expr input,
      required final bool propagateNans}) = _$AggExpr_Max;

  Expr get input;
  bool get propagateNans;
  @JsonKey(ignore: true)
  _$$AggExpr_MaxCopyWith<_$AggExpr_Max> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_MedianCopyWith<$Res> {
  factory _$$AggExpr_MedianCopyWith(
          _$AggExpr_Median value, $Res Function(_$AggExpr_Median) then) =
      __$$AggExpr_MedianCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_MedianCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_Median>
    implements _$$AggExpr_MedianCopyWith<$Res> {
  __$$AggExpr_MedianCopyWithImpl(
      _$AggExpr_Median _value, $Res Function(_$AggExpr_Median) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_Median(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_Median implements AggExpr_Median {
  const _$AggExpr_Median(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.median(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_Median &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_MedianCopyWith<_$AggExpr_Median> get copyWith =>
      __$$AggExpr_MedianCopyWithImpl<_$AggExpr_Median>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return median(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return median?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (median != null) {
      return median(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return median(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return median?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (median != null) {
      return median(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Median implements AggExpr {
  const factory AggExpr_Median(final Expr field0) = _$AggExpr_Median;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_MedianCopyWith<_$AggExpr_Median> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_NUniqueCopyWith<$Res> {
  factory _$$AggExpr_NUniqueCopyWith(
          _$AggExpr_NUnique value, $Res Function(_$AggExpr_NUnique) then) =
      __$$AggExpr_NUniqueCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_NUniqueCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_NUnique>
    implements _$$AggExpr_NUniqueCopyWith<$Res> {
  __$$AggExpr_NUniqueCopyWithImpl(
      _$AggExpr_NUnique _value, $Res Function(_$AggExpr_NUnique) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_NUnique(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_NUnique implements AggExpr_NUnique {
  const _$AggExpr_NUnique(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.nUnique(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_NUnique &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_NUniqueCopyWith<_$AggExpr_NUnique> get copyWith =>
      __$$AggExpr_NUniqueCopyWithImpl<_$AggExpr_NUnique>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return nUnique(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return nUnique?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (nUnique != null) {
      return nUnique(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return nUnique(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return nUnique?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (nUnique != null) {
      return nUnique(this);
    }
    return orElse();
  }
}

abstract class AggExpr_NUnique implements AggExpr {
  const factory AggExpr_NUnique(final Expr field0) = _$AggExpr_NUnique;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_NUniqueCopyWith<_$AggExpr_NUnique> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_FirstCopyWith<$Res> {
  factory _$$AggExpr_FirstCopyWith(
          _$AggExpr_First value, $Res Function(_$AggExpr_First) then) =
      __$$AggExpr_FirstCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_FirstCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_First>
    implements _$$AggExpr_FirstCopyWith<$Res> {
  __$$AggExpr_FirstCopyWithImpl(
      _$AggExpr_First _value, $Res Function(_$AggExpr_First) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_First(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_First implements AggExpr_First {
  const _$AggExpr_First(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.first(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_First &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_FirstCopyWith<_$AggExpr_First> get copyWith =>
      __$$AggExpr_FirstCopyWithImpl<_$AggExpr_First>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return first(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return first?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return first(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return first?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first(this);
    }
    return orElse();
  }
}

abstract class AggExpr_First implements AggExpr {
  const factory AggExpr_First(final Expr field0) = _$AggExpr_First;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_FirstCopyWith<_$AggExpr_First> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_LastCopyWith<$Res> {
  factory _$$AggExpr_LastCopyWith(
          _$AggExpr_Last value, $Res Function(_$AggExpr_Last) then) =
      __$$AggExpr_LastCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_LastCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_Last>
    implements _$$AggExpr_LastCopyWith<$Res> {
  __$$AggExpr_LastCopyWithImpl(
      _$AggExpr_Last _value, $Res Function(_$AggExpr_Last) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_Last(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_Last implements AggExpr_Last {
  const _$AggExpr_Last(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.last(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_Last &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_LastCopyWith<_$AggExpr_Last> get copyWith =>
      __$$AggExpr_LastCopyWithImpl<_$AggExpr_Last>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return last(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return last?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (last != null) {
      return last(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return last(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return last?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (last != null) {
      return last(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Last implements AggExpr {
  const factory AggExpr_Last(final Expr field0) = _$AggExpr_Last;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_LastCopyWith<_$AggExpr_Last> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_MeanCopyWith<$Res> {
  factory _$$AggExpr_MeanCopyWith(
          _$AggExpr_Mean value, $Res Function(_$AggExpr_Mean) then) =
      __$$AggExpr_MeanCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_MeanCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_Mean>
    implements _$$AggExpr_MeanCopyWith<$Res> {
  __$$AggExpr_MeanCopyWithImpl(
      _$AggExpr_Mean _value, $Res Function(_$AggExpr_Mean) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_Mean(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_Mean implements AggExpr_Mean {
  const _$AggExpr_Mean(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.mean(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_Mean &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_MeanCopyWith<_$AggExpr_Mean> get copyWith =>
      __$$AggExpr_MeanCopyWithImpl<_$AggExpr_Mean>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return mean(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return mean?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (mean != null) {
      return mean(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return mean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return mean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (mean != null) {
      return mean(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Mean implements AggExpr {
  const factory AggExpr_Mean(final Expr field0) = _$AggExpr_Mean;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_MeanCopyWith<_$AggExpr_Mean> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_ListCopyWith<$Res> {
  factory _$$AggExpr_ListCopyWith(
          _$AggExpr_List value, $Res Function(_$AggExpr_List) then) =
      __$$AggExpr_ListCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_ListCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_List>
    implements _$$AggExpr_ListCopyWith<$Res> {
  __$$AggExpr_ListCopyWithImpl(
      _$AggExpr_List _value, $Res Function(_$AggExpr_List) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_List(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_List implements AggExpr_List {
  const _$AggExpr_List(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.list(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_List &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_ListCopyWith<_$AggExpr_List> get copyWith =>
      __$$AggExpr_ListCopyWithImpl<_$AggExpr_List>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return list(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return list?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return list(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return list?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(this);
    }
    return orElse();
  }
}

abstract class AggExpr_List implements AggExpr {
  const factory AggExpr_List(final Expr field0) = _$AggExpr_List;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_ListCopyWith<_$AggExpr_List> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_CountCopyWith<$Res> {
  factory _$$AggExpr_CountCopyWith(
          _$AggExpr_Count value, $Res Function(_$AggExpr_Count) then) =
      __$$AggExpr_CountCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_CountCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_Count>
    implements _$$AggExpr_CountCopyWith<$Res> {
  __$$AggExpr_CountCopyWithImpl(
      _$AggExpr_Count _value, $Res Function(_$AggExpr_Count) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_Count(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_Count implements AggExpr_Count {
  const _$AggExpr_Count(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.count(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_Count &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_CountCopyWith<_$AggExpr_Count> get copyWith =>
      __$$AggExpr_CountCopyWithImpl<_$AggExpr_Count>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return count(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return count?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (count != null) {
      return count(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return count(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return count?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (count != null) {
      return count(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Count implements AggExpr {
  const factory AggExpr_Count(final Expr field0) = _$AggExpr_Count;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_CountCopyWith<_$AggExpr_Count> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_QuantileCopyWith<$Res> {
  factory _$$AggExpr_QuantileCopyWith(
          _$AggExpr_Quantile value, $Res Function(_$AggExpr_Quantile) then) =
      __$$AggExpr_QuantileCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr expr, Expr quantile, QuantileInterpolOptions interpol});

  $ExprCopyWith<$Res> get expr;
  $ExprCopyWith<$Res> get quantile;
}

/// @nodoc
class __$$AggExpr_QuantileCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_Quantile>
    implements _$$AggExpr_QuantileCopyWith<$Res> {
  __$$AggExpr_QuantileCopyWithImpl(
      _$AggExpr_Quantile _value, $Res Function(_$AggExpr_Quantile) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expr = null,
    Object? quantile = null,
    Object? interpol = null,
  }) {
    return _then(_$AggExpr_Quantile(
      expr: null == expr
          ? _value.expr
          : expr // ignore: cast_nullable_to_non_nullable
              as Expr,
      quantile: null == quantile
          ? _value.quantile
          : quantile // ignore: cast_nullable_to_non_nullable
              as Expr,
      interpol: null == interpol
          ? _value.interpol
          : interpol // ignore: cast_nullable_to_non_nullable
              as QuantileInterpolOptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get expr {
    return $ExprCopyWith<$Res>(_value.expr, (value) {
      return _then(_value.copyWith(expr: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get quantile {
    return $ExprCopyWith<$Res>(_value.quantile, (value) {
      return _then(_value.copyWith(quantile: value));
    });
  }
}

/// @nodoc

class _$AggExpr_Quantile implements AggExpr_Quantile {
  const _$AggExpr_Quantile(
      {required this.expr, required this.quantile, required this.interpol});

  @override
  final Expr expr;
  @override
  final Expr quantile;
  @override
  final QuantileInterpolOptions interpol;

  @override
  String toString() {
    return 'AggExpr.quantile(expr: $expr, quantile: $quantile, interpol: $interpol)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_Quantile &&
            (identical(other.expr, expr) || other.expr == expr) &&
            (identical(other.quantile, quantile) ||
                other.quantile == quantile) &&
            (identical(other.interpol, interpol) ||
                other.interpol == interpol));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expr, quantile, interpol);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_QuantileCopyWith<_$AggExpr_Quantile> get copyWith =>
      __$$AggExpr_QuantileCopyWithImpl<_$AggExpr_Quantile>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return quantile(expr, this.quantile, interpol);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return quantile?.call(expr, this.quantile, interpol);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (quantile != null) {
      return quantile(expr, this.quantile, interpol);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return quantile(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return quantile?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (quantile != null) {
      return quantile(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Quantile implements AggExpr {
  const factory AggExpr_Quantile(
      {required final Expr expr,
      required final Expr quantile,
      required final QuantileInterpolOptions interpol}) = _$AggExpr_Quantile;

  Expr get expr;
  Expr get quantile;
  QuantileInterpolOptions get interpol;
  @JsonKey(ignore: true)
  _$$AggExpr_QuantileCopyWith<_$AggExpr_Quantile> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_SumCopyWith<$Res> {
  factory _$$AggExpr_SumCopyWith(
          _$AggExpr_Sum value, $Res Function(_$AggExpr_Sum) then) =
      __$$AggExpr_SumCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_SumCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_Sum>
    implements _$$AggExpr_SumCopyWith<$Res> {
  __$$AggExpr_SumCopyWithImpl(
      _$AggExpr_Sum _value, $Res Function(_$AggExpr_Sum) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_Sum(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_Sum implements AggExpr_Sum {
  const _$AggExpr_Sum(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.sum(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_Sum &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_SumCopyWith<_$AggExpr_Sum> get copyWith =>
      __$$AggExpr_SumCopyWithImpl<_$AggExpr_Sum>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return sum(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return sum?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (sum != null) {
      return sum(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return sum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return sum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (sum != null) {
      return sum(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Sum implements AggExpr {
  const factory AggExpr_Sum(final Expr field0) = _$AggExpr_Sum;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_SumCopyWith<_$AggExpr_Sum> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_AggGroupsCopyWith<$Res> {
  factory _$$AggExpr_AggGroupsCopyWith(
          _$AggExpr_AggGroups value, $Res Function(_$AggExpr_AggGroups) then) =
      __$$AggExpr_AggGroupsCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_AggGroupsCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_AggGroups>
    implements _$$AggExpr_AggGroupsCopyWith<$Res> {
  __$$AggExpr_AggGroupsCopyWithImpl(
      _$AggExpr_AggGroups _value, $Res Function(_$AggExpr_AggGroups) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_AggGroups(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_AggGroups implements AggExpr_AggGroups {
  const _$AggExpr_AggGroups(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.aggGroups(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_AggGroups &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_AggGroupsCopyWith<_$AggExpr_AggGroups> get copyWith =>
      __$$AggExpr_AggGroupsCopyWithImpl<_$AggExpr_AggGroups>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return aggGroups(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return aggGroups?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (aggGroups != null) {
      return aggGroups(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return aggGroups(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return aggGroups?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (aggGroups != null) {
      return aggGroups(this);
    }
    return orElse();
  }
}

abstract class AggExpr_AggGroups implements AggExpr {
  const factory AggExpr_AggGroups(final Expr field0) = _$AggExpr_AggGroups;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_AggGroupsCopyWith<_$AggExpr_AggGroups> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_StdCopyWith<$Res> {
  factory _$$AggExpr_StdCopyWith(
          _$AggExpr_Std value, $Res Function(_$AggExpr_Std) then) =
      __$$AggExpr_StdCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0, int field1});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_StdCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_Std>
    implements _$$AggExpr_StdCopyWith<$Res> {
  __$$AggExpr_StdCopyWithImpl(
      _$AggExpr_Std _value, $Res Function(_$AggExpr_Std) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$AggExpr_Std(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_Std implements AggExpr_Std {
  const _$AggExpr_Std(this.field0, this.field1);

  @override
  final Expr field0;
  @override
  final int field1;

  @override
  String toString() {
    return 'AggExpr.std(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_Std &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_StdCopyWith<_$AggExpr_Std> get copyWith =>
      __$$AggExpr_StdCopyWithImpl<_$AggExpr_Std>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) list,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
  }) {
    return std(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? list,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
  }) {
    return std?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? list,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    required TResult orElse(),
  }) {
    if (std != null) {
      return std(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_List value) list,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
  }) {
    return std(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_List value)? list,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
  }) {
    return std?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_List value)? list,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    required TResult orElse(),
  }) {
    if (std != null) {
      return std(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Std implements AggExpr {
  const factory AggExpr_Std(final Expr field0, final int field1) =
      _$AggExpr_Std;

  Expr get field0;
  int get field1;
  @JsonKey(ignore: true)
  _$$AggExpr_StdCopyWith<_$AggExpr_Std> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DataType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataTypeCopyWith<$Res> {
  factory $DataTypeCopyWith(DataType value, $Res Function(DataType) then) =
      _$DataTypeCopyWithImpl<$Res, DataType>;
}

/// @nodoc
class _$DataTypeCopyWithImpl<$Res, $Val extends DataType>
    implements $DataTypeCopyWith<$Res> {
  _$DataTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DataType_BooleanCopyWith<$Res> {
  factory _$$DataType_BooleanCopyWith(
          _$DataType_Boolean value, $Res Function(_$DataType_Boolean) then) =
      __$$DataType_BooleanCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_BooleanCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Boolean>
    implements _$$DataType_BooleanCopyWith<$Res> {
  __$$DataType_BooleanCopyWithImpl(
      _$DataType_Boolean _value, $Res Function(_$DataType_Boolean) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Boolean implements DataType_Boolean {
  const _$DataType_Boolean();

  @override
  String toString() {
    return 'DataType.boolean()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Boolean);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return boolean();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return boolean?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class DataType_Boolean implements DataType {
  const factory DataType_Boolean() = _$DataType_Boolean;
}

/// @nodoc
abstract class _$$DataType_UInt8CopyWith<$Res> {
  factory _$$DataType_UInt8CopyWith(
          _$DataType_UInt8 value, $Res Function(_$DataType_UInt8) then) =
      __$$DataType_UInt8CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt8CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt8>
    implements _$$DataType_UInt8CopyWith<$Res> {
  __$$DataType_UInt8CopyWithImpl(
      _$DataType_UInt8 _value, $Res Function(_$DataType_UInt8) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt8 implements DataType_UInt8 {
  const _$DataType_UInt8();

  @override
  String toString() {
    return 'DataType.uInt8()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt8);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return uInt8();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return uInt8?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt8 implements DataType {
  const factory DataType_UInt8() = _$DataType_UInt8;
}

/// @nodoc
abstract class _$$DataType_UInt16CopyWith<$Res> {
  factory _$$DataType_UInt16CopyWith(
          _$DataType_UInt16 value, $Res Function(_$DataType_UInt16) then) =
      __$$DataType_UInt16CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt16CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt16>
    implements _$$DataType_UInt16CopyWith<$Res> {
  __$$DataType_UInt16CopyWithImpl(
      _$DataType_UInt16 _value, $Res Function(_$DataType_UInt16) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt16 implements DataType_UInt16 {
  const _$DataType_UInt16();

  @override
  String toString() {
    return 'DataType.uInt16()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt16);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return uInt16();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return uInt16?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt16 implements DataType {
  const factory DataType_UInt16() = _$DataType_UInt16;
}

/// @nodoc
abstract class _$$DataType_UInt32CopyWith<$Res> {
  factory _$$DataType_UInt32CopyWith(
          _$DataType_UInt32 value, $Res Function(_$DataType_UInt32) then) =
      __$$DataType_UInt32CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt32CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt32>
    implements _$$DataType_UInt32CopyWith<$Res> {
  __$$DataType_UInt32CopyWithImpl(
      _$DataType_UInt32 _value, $Res Function(_$DataType_UInt32) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt32 implements DataType_UInt32 {
  const _$DataType_UInt32();

  @override
  String toString() {
    return 'DataType.uInt32()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt32);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return uInt32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return uInt32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt32 implements DataType {
  const factory DataType_UInt32() = _$DataType_UInt32;
}

/// @nodoc
abstract class _$$DataType_UInt64CopyWith<$Res> {
  factory _$$DataType_UInt64CopyWith(
          _$DataType_UInt64 value, $Res Function(_$DataType_UInt64) then) =
      __$$DataType_UInt64CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt64CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt64>
    implements _$$DataType_UInt64CopyWith<$Res> {
  __$$DataType_UInt64CopyWithImpl(
      _$DataType_UInt64 _value, $Res Function(_$DataType_UInt64) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt64 implements DataType_UInt64 {
  const _$DataType_UInt64();

  @override
  String toString() {
    return 'DataType.uInt64()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt64);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return uInt64();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return uInt64?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt64 implements DataType {
  const factory DataType_UInt64() = _$DataType_UInt64;
}

/// @nodoc
abstract class _$$DataType_Int8CopyWith<$Res> {
  factory _$$DataType_Int8CopyWith(
          _$DataType_Int8 value, $Res Function(_$DataType_Int8) then) =
      __$$DataType_Int8CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int8CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int8>
    implements _$$DataType_Int8CopyWith<$Res> {
  __$$DataType_Int8CopyWithImpl(
      _$DataType_Int8 _value, $Res Function(_$DataType_Int8) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int8 implements DataType_Int8 {
  const _$DataType_Int8();

  @override
  String toString() {
    return 'DataType.int8()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int8);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return int8();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return int8?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8(this);
    }
    return orElse();
  }
}

abstract class DataType_Int8 implements DataType {
  const factory DataType_Int8() = _$DataType_Int8;
}

/// @nodoc
abstract class _$$DataType_Int16CopyWith<$Res> {
  factory _$$DataType_Int16CopyWith(
          _$DataType_Int16 value, $Res Function(_$DataType_Int16) then) =
      __$$DataType_Int16CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int16CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int16>
    implements _$$DataType_Int16CopyWith<$Res> {
  __$$DataType_Int16CopyWithImpl(
      _$DataType_Int16 _value, $Res Function(_$DataType_Int16) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int16 implements DataType_Int16 {
  const _$DataType_Int16();

  @override
  String toString() {
    return 'DataType.int16()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int16);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return int16();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return int16?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16(this);
    }
    return orElse();
  }
}

abstract class DataType_Int16 implements DataType {
  const factory DataType_Int16() = _$DataType_Int16;
}

/// @nodoc
abstract class _$$DataType_Int32CopyWith<$Res> {
  factory _$$DataType_Int32CopyWith(
          _$DataType_Int32 value, $Res Function(_$DataType_Int32) then) =
      __$$DataType_Int32CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int32CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int32>
    implements _$$DataType_Int32CopyWith<$Res> {
  __$$DataType_Int32CopyWithImpl(
      _$DataType_Int32 _value, $Res Function(_$DataType_Int32) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int32 implements DataType_Int32 {
  const _$DataType_Int32();

  @override
  String toString() {
    return 'DataType.int32()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int32);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return int32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return int32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(this);
    }
    return orElse();
  }
}

abstract class DataType_Int32 implements DataType {
  const factory DataType_Int32() = _$DataType_Int32;
}

/// @nodoc
abstract class _$$DataType_Int64CopyWith<$Res> {
  factory _$$DataType_Int64CopyWith(
          _$DataType_Int64 value, $Res Function(_$DataType_Int64) then) =
      __$$DataType_Int64CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int64CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int64>
    implements _$$DataType_Int64CopyWith<$Res> {
  __$$DataType_Int64CopyWithImpl(
      _$DataType_Int64 _value, $Res Function(_$DataType_Int64) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int64 implements DataType_Int64 {
  const _$DataType_Int64();

  @override
  String toString() {
    return 'DataType.int64()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int64);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return int64();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return int64?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(this);
    }
    return orElse();
  }
}

abstract class DataType_Int64 implements DataType {
  const factory DataType_Int64() = _$DataType_Int64;
}

/// @nodoc
abstract class _$$DataType_Float32CopyWith<$Res> {
  factory _$$DataType_Float32CopyWith(
          _$DataType_Float32 value, $Res Function(_$DataType_Float32) then) =
      __$$DataType_Float32CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Float32CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Float32>
    implements _$$DataType_Float32CopyWith<$Res> {
  __$$DataType_Float32CopyWithImpl(
      _$DataType_Float32 _value, $Res Function(_$DataType_Float32) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Float32 implements DataType_Float32 {
  const _$DataType_Float32();

  @override
  String toString() {
    return 'DataType.float32()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Float32);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return float32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return float32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return float32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return float32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32(this);
    }
    return orElse();
  }
}

abstract class DataType_Float32 implements DataType {
  const factory DataType_Float32() = _$DataType_Float32;
}

/// @nodoc
abstract class _$$DataType_Float64CopyWith<$Res> {
  factory _$$DataType_Float64CopyWith(
          _$DataType_Float64 value, $Res Function(_$DataType_Float64) then) =
      __$$DataType_Float64CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Float64CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Float64>
    implements _$$DataType_Float64CopyWith<$Res> {
  __$$DataType_Float64CopyWithImpl(
      _$DataType_Float64 _value, $Res Function(_$DataType_Float64) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Float64 implements DataType_Float64 {
  const _$DataType_Float64();

  @override
  String toString() {
    return 'DataType.float64()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Float64);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return float64();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return float64?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return float64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return float64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(this);
    }
    return orElse();
  }
}

abstract class DataType_Float64 implements DataType {
  const factory DataType_Float64() = _$DataType_Float64;
}

/// @nodoc
abstract class _$$DataType_Utf8CopyWith<$Res> {
  factory _$$DataType_Utf8CopyWith(
          _$DataType_Utf8 value, $Res Function(_$DataType_Utf8) then) =
      __$$DataType_Utf8CopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Utf8CopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Utf8>
    implements _$$DataType_Utf8CopyWith<$Res> {
  __$$DataType_Utf8CopyWithImpl(
      _$DataType_Utf8 _value, $Res Function(_$DataType_Utf8) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Utf8 implements DataType_Utf8 {
  const _$DataType_Utf8();

  @override
  String toString() {
    return 'DataType.utf8()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Utf8);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return utf8();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return utf8?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return utf8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return utf8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8(this);
    }
    return orElse();
  }
}

abstract class DataType_Utf8 implements DataType {
  const factory DataType_Utf8() = _$DataType_Utf8;
}

/// @nodoc
abstract class _$$DataType_BinaryCopyWith<$Res> {
  factory _$$DataType_BinaryCopyWith(
          _$DataType_Binary value, $Res Function(_$DataType_Binary) then) =
      __$$DataType_BinaryCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_BinaryCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Binary>
    implements _$$DataType_BinaryCopyWith<$Res> {
  __$$DataType_BinaryCopyWithImpl(
      _$DataType_Binary _value, $Res Function(_$DataType_Binary) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Binary implements DataType_Binary {
  const _$DataType_Binary();

  @override
  String toString() {
    return 'DataType.binary()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Binary);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return binary();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return binary?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return binary(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return binary?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(this);
    }
    return orElse();
  }
}

abstract class DataType_Binary implements DataType {
  const factory DataType_Binary() = _$DataType_Binary;
}

/// @nodoc
abstract class _$$DataType_DateCopyWith<$Res> {
  factory _$$DataType_DateCopyWith(
          _$DataType_Date value, $Res Function(_$DataType_Date) then) =
      __$$DataType_DateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_DateCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Date>
    implements _$$DataType_DateCopyWith<$Res> {
  __$$DataType_DateCopyWithImpl(
      _$DataType_Date _value, $Res Function(_$DataType_Date) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Date implements DataType_Date {
  const _$DataType_Date();

  @override
  String toString() {
    return 'DataType.date()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Date);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return date();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return date?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return date(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return date?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date(this);
    }
    return orElse();
  }
}

abstract class DataType_Date implements DataType {
  const factory DataType_Date() = _$DataType_Date;
}

/// @nodoc
abstract class _$$DataType_DatetimeCopyWith<$Res> {
  factory _$$DataType_DatetimeCopyWith(
          _$DataType_Datetime value, $Res Function(_$DataType_Datetime) then) =
      __$$DataType_DatetimeCopyWithImpl<$Res>;
  @useResult
  $Res call({TimeUnit field0, String? field1});
}

/// @nodoc
class __$$DataType_DatetimeCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Datetime>
    implements _$$DataType_DatetimeCopyWith<$Res> {
  __$$DataType_DatetimeCopyWithImpl(
      _$DataType_Datetime _value, $Res Function(_$DataType_Datetime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = freezed,
  }) {
    return _then(_$DataType_Datetime(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
      freezed == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$DataType_Datetime implements DataType_Datetime {
  const _$DataType_Datetime(this.field0, [this.field1]);

  @override
  final TimeUnit field0;
  @override
  final String? field1;

  @override
  String toString() {
    return 'DataType.datetime(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_Datetime &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_DatetimeCopyWith<_$DataType_Datetime> get copyWith =>
      __$$DataType_DatetimeCopyWithImpl<_$DataType_Datetime>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return datetime(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return datetime?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (datetime != null) {
      return datetime(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return datetime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return datetime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (datetime != null) {
      return datetime(this);
    }
    return orElse();
  }
}

abstract class DataType_Datetime implements DataType {
  const factory DataType_Datetime(final TimeUnit field0,
      [final String? field1]) = _$DataType_Datetime;

  TimeUnit get field0;
  String? get field1;
  @JsonKey(ignore: true)
  _$$DataType_DatetimeCopyWith<_$DataType_Datetime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_DurationCopyWith<$Res> {
  factory _$$DataType_DurationCopyWith(
          _$DataType_Duration value, $Res Function(_$DataType_Duration) then) =
      __$$DataType_DurationCopyWithImpl<$Res>;
  @useResult
  $Res call({TimeUnit field0});
}

/// @nodoc
class __$$DataType_DurationCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Duration>
    implements _$$DataType_DurationCopyWith<$Res> {
  __$$DataType_DurationCopyWithImpl(
      _$DataType_Duration _value, $Res Function(_$DataType_Duration) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DataType_Duration(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
    ));
  }
}

/// @nodoc

class _$DataType_Duration implements DataType_Duration {
  const _$DataType_Duration(this.field0);

  @override
  final TimeUnit field0;

  @override
  String toString() {
    return 'DataType.duration(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_Duration &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_DurationCopyWith<_$DataType_Duration> get copyWith =>
      __$$DataType_DurationCopyWithImpl<_$DataType_Duration>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return duration(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return duration?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return duration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return duration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(this);
    }
    return orElse();
  }
}

abstract class DataType_Duration implements DataType {
  const factory DataType_Duration(final TimeUnit field0) = _$DataType_Duration;

  TimeUnit get field0;
  @JsonKey(ignore: true)
  _$$DataType_DurationCopyWith<_$DataType_Duration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_TimeCopyWith<$Res> {
  factory _$$DataType_TimeCopyWith(
          _$DataType_Time value, $Res Function(_$DataType_Time) then) =
      __$$DataType_TimeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_TimeCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Time>
    implements _$$DataType_TimeCopyWith<$Res> {
  __$$DataType_TimeCopyWithImpl(
      _$DataType_Time _value, $Res Function(_$DataType_Time) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Time implements DataType_Time {
  const _$DataType_Time();

  @override
  String toString() {
    return 'DataType.time()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Time);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return time();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return time?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return time(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return time?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time(this);
    }
    return orElse();
  }
}

abstract class DataType_Time implements DataType {
  const factory DataType_Time() = _$DataType_Time;
}

/// @nodoc
abstract class _$$DataType_ListCopyWith<$Res> {
  factory _$$DataType_ListCopyWith(
          _$DataType_List value, $Res Function(_$DataType_List) then) =
      __$$DataType_ListCopyWithImpl<$Res>;
  @useResult
  $Res call({DataType field0});

  $DataTypeCopyWith<$Res> get field0;
}

/// @nodoc
class __$$DataType_ListCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_List>
    implements _$$DataType_ListCopyWith<$Res> {
  __$$DataType_ListCopyWithImpl(
      _$DataType_List _value, $Res Function(_$DataType_List) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DataType_List(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get field0 {
    return $DataTypeCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$DataType_List implements DataType_List {
  const _$DataType_List(this.field0);

  @override
  final DataType field0;

  @override
  String toString() {
    return 'DataType.list(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_List &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_ListCopyWith<_$DataType_List> get copyWith =>
      __$$DataType_ListCopyWithImpl<_$DataType_List>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return list(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return list?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return list(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return list?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(this);
    }
    return orElse();
  }
}

abstract class DataType_List implements DataType {
  const factory DataType_List(final DataType field0) = _$DataType_List;

  DataType get field0;
  @JsonKey(ignore: true)
  _$$DataType_ListCopyWith<_$DataType_List> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_StructCopyWith<$Res> {
  factory _$$DataType_StructCopyWith(
          _$DataType_Struct value, $Res Function(_$DataType_Struct) then) =
      __$$DataType_StructCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Field> field0});
}

/// @nodoc
class __$$DataType_StructCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Struct>
    implements _$$DataType_StructCopyWith<$Res> {
  __$$DataType_StructCopyWithImpl(
      _$DataType_Struct _value, $Res Function(_$DataType_Struct) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DataType_Struct(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<Field>,
    ));
  }
}

/// @nodoc

class _$DataType_Struct implements DataType_Struct {
  const _$DataType_Struct(final List<Field> field0) : _field0 = field0;

  final List<Field> _field0;
  @override
  List<Field> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'DataType.struct(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_Struct &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_StructCopyWith<_$DataType_Struct> get copyWith =>
      __$$DataType_StructCopyWithImpl<_$DataType_Struct>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return struct(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return struct?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (struct != null) {
      return struct(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return struct(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return struct?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (struct != null) {
      return struct(this);
    }
    return orElse();
  }
}

abstract class DataType_Struct implements DataType {
  const factory DataType_Struct(final List<Field> field0) = _$DataType_Struct;

  List<Field> get field0;
  @JsonKey(ignore: true)
  _$$DataType_StructCopyWith<_$DataType_Struct> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_UnknownCopyWith<$Res> {
  factory _$$DataType_UnknownCopyWith(
          _$DataType_Unknown value, $Res Function(_$DataType_Unknown) then) =
      __$$DataType_UnknownCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UnknownCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Unknown>
    implements _$$DataType_UnknownCopyWith<$Res> {
  __$$DataType_UnknownCopyWithImpl(
      _$DataType_Unknown _value, $Res Function(_$DataType_Unknown) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Unknown implements DataType_Unknown {
  const _$DataType_Unknown();

  @override
  String toString() {
    return 'DataType.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Unknown);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class DataType_Unknown implements DataType {
  const factory DataType_Unknown() = _$DataType_Unknown;
}

/// @nodoc
mixin _$Excluded {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) name,
    required TResult Function(DataType field0) dtype,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? name,
    TResult? Function(DataType field0)? dtype,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? name,
    TResult Function(DataType field0)? dtype,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Excluded_Name value) name,
    required TResult Function(Excluded_Dtype value) dtype,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Excluded_Name value)? name,
    TResult? Function(Excluded_Dtype value)? dtype,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Excluded_Name value)? name,
    TResult Function(Excluded_Dtype value)? dtype,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExcludedCopyWith<$Res> {
  factory $ExcludedCopyWith(Excluded value, $Res Function(Excluded) then) =
      _$ExcludedCopyWithImpl<$Res, Excluded>;
}

/// @nodoc
class _$ExcludedCopyWithImpl<$Res, $Val extends Excluded>
    implements $ExcludedCopyWith<$Res> {
  _$ExcludedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Excluded_NameCopyWith<$Res> {
  factory _$$Excluded_NameCopyWith(
          _$Excluded_Name value, $Res Function(_$Excluded_Name) then) =
      __$$Excluded_NameCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$Excluded_NameCopyWithImpl<$Res>
    extends _$ExcludedCopyWithImpl<$Res, _$Excluded_Name>
    implements _$$Excluded_NameCopyWith<$Res> {
  __$$Excluded_NameCopyWithImpl(
      _$Excluded_Name _value, $Res Function(_$Excluded_Name) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Excluded_Name(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Excluded_Name implements Excluded_Name {
  const _$Excluded_Name(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'Excluded.name(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Excluded_Name &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Excluded_NameCopyWith<_$Excluded_Name> get copyWith =>
      __$$Excluded_NameCopyWithImpl<_$Excluded_Name>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) name,
    required TResult Function(DataType field0) dtype,
  }) {
    return name(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? name,
    TResult? Function(DataType field0)? dtype,
  }) {
    return name?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? name,
    TResult Function(DataType field0)? dtype,
    required TResult orElse(),
  }) {
    if (name != null) {
      return name(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Excluded_Name value) name,
    required TResult Function(Excluded_Dtype value) dtype,
  }) {
    return name(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Excluded_Name value)? name,
    TResult? Function(Excluded_Dtype value)? dtype,
  }) {
    return name?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Excluded_Name value)? name,
    TResult Function(Excluded_Dtype value)? dtype,
    required TResult orElse(),
  }) {
    if (name != null) {
      return name(this);
    }
    return orElse();
  }
}

abstract class Excluded_Name implements Excluded {
  const factory Excluded_Name(final String field0) = _$Excluded_Name;

  @override
  String get field0;
  @JsonKey(ignore: true)
  _$$Excluded_NameCopyWith<_$Excluded_Name> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Excluded_DtypeCopyWith<$Res> {
  factory _$$Excluded_DtypeCopyWith(
          _$Excluded_Dtype value, $Res Function(_$Excluded_Dtype) then) =
      __$$Excluded_DtypeCopyWithImpl<$Res>;
  @useResult
  $Res call({DataType field0});

  $DataTypeCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Excluded_DtypeCopyWithImpl<$Res>
    extends _$ExcludedCopyWithImpl<$Res, _$Excluded_Dtype>
    implements _$$Excluded_DtypeCopyWith<$Res> {
  __$$Excluded_DtypeCopyWithImpl(
      _$Excluded_Dtype _value, $Res Function(_$Excluded_Dtype) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Excluded_Dtype(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get field0 {
    return $DataTypeCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Excluded_Dtype implements Excluded_Dtype {
  const _$Excluded_Dtype(this.field0);

  @override
  final DataType field0;

  @override
  String toString() {
    return 'Excluded.dtype(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Excluded_Dtype &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Excluded_DtypeCopyWith<_$Excluded_Dtype> get copyWith =>
      __$$Excluded_DtypeCopyWithImpl<_$Excluded_Dtype>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) name,
    required TResult Function(DataType field0) dtype,
  }) {
    return dtype(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? name,
    TResult? Function(DataType field0)? dtype,
  }) {
    return dtype?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? name,
    TResult Function(DataType field0)? dtype,
    required TResult orElse(),
  }) {
    if (dtype != null) {
      return dtype(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Excluded_Name value) name,
    required TResult Function(Excluded_Dtype value) dtype,
  }) {
    return dtype(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Excluded_Name value)? name,
    TResult? Function(Excluded_Dtype value)? dtype,
  }) {
    return dtype?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Excluded_Name value)? name,
    TResult Function(Excluded_Dtype value)? dtype,
    required TResult orElse(),
  }) {
    if (dtype != null) {
      return dtype(this);
    }
    return orElse();
  }
}

abstract class Excluded_Dtype implements Excluded {
  const factory Excluded_Dtype(final DataType field0) = _$Excluded_Dtype;

  @override
  DataType get field0;
  @JsonKey(ignore: true)
  _$$Excluded_DtypeCopyWith<_$Excluded_Dtype> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Expr {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExprCopyWith<$Res> {
  factory $ExprCopyWith(Expr value, $Res Function(Expr) then) =
      _$ExprCopyWithImpl<$Res, Expr>;
}

/// @nodoc
class _$ExprCopyWithImpl<$Res, $Val extends Expr>
    implements $ExprCopyWith<$Res> {
  _$ExprCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Expr_AliasCopyWith<$Res> {
  factory _$$Expr_AliasCopyWith(
          _$Expr_Alias value, $Res Function(_$Expr_Alias) then) =
      __$$Expr_AliasCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0, String field1});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_AliasCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Alias>
    implements _$$Expr_AliasCopyWith<$Res> {
  __$$Expr_AliasCopyWithImpl(
      _$Expr_Alias _value, $Res Function(_$Expr_Alias) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$Expr_Alias(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_Alias implements Expr_Alias {
  const _$Expr_Alias(this.field0, this.field1);

  @override
  final Expr field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'Expr.alias(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Alias &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_AliasCopyWith<_$Expr_Alias> get copyWith =>
      __$$Expr_AliasCopyWithImpl<_$Expr_Alias>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return alias(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return alias?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (alias != null) {
      return alias(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return alias(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return alias?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (alias != null) {
      return alias(this);
    }
    return orElse();
  }
}

abstract class Expr_Alias implements Expr {
  const factory Expr_Alias(final Expr field0, final String field1) =
      _$Expr_Alias;

  Expr get field0;
  String get field1;
  @JsonKey(ignore: true)
  _$$Expr_AliasCopyWith<_$Expr_Alias> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_ColumnCopyWith<$Res> {
  factory _$$Expr_ColumnCopyWith(
          _$Expr_Column value, $Res Function(_$Expr_Column) then) =
      __$$Expr_ColumnCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$Expr_ColumnCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Column>
    implements _$$Expr_ColumnCopyWith<$Res> {
  __$$Expr_ColumnCopyWithImpl(
      _$Expr_Column _value, $Res Function(_$Expr_Column) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_Column(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Expr_Column implements Expr_Column {
  const _$Expr_Column(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'Expr.column(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Column &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_ColumnCopyWith<_$Expr_Column> get copyWith =>
      __$$Expr_ColumnCopyWithImpl<_$Expr_Column>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return column(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return column?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (column != null) {
      return column(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return column(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return column?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (column != null) {
      return column(this);
    }
    return orElse();
  }
}

abstract class Expr_Column implements Expr {
  const factory Expr_Column(final String field0) = _$Expr_Column;

  String get field0;
  @JsonKey(ignore: true)
  _$$Expr_ColumnCopyWith<_$Expr_Column> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_ColumnsCopyWith<$Res> {
  factory _$$Expr_ColumnsCopyWith(
          _$Expr_Columns value, $Res Function(_$Expr_Columns) then) =
      __$$Expr_ColumnsCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> field0});
}

/// @nodoc
class __$$Expr_ColumnsCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Columns>
    implements _$$Expr_ColumnsCopyWith<$Res> {
  __$$Expr_ColumnsCopyWithImpl(
      _$Expr_Columns _value, $Res Function(_$Expr_Columns) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_Columns(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$Expr_Columns implements Expr_Columns {
  const _$Expr_Columns(final List<String> field0) : _field0 = field0;

  final List<String> _field0;
  @override
  List<String> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Expr.columns(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Columns &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_ColumnsCopyWith<_$Expr_Columns> get copyWith =>
      __$$Expr_ColumnsCopyWithImpl<_$Expr_Columns>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return columns(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return columns?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (columns != null) {
      return columns(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return columns(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return columns?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (columns != null) {
      return columns(this);
    }
    return orElse();
  }
}

abstract class Expr_Columns implements Expr {
  const factory Expr_Columns(final List<String> field0) = _$Expr_Columns;

  List<String> get field0;
  @JsonKey(ignore: true)
  _$$Expr_ColumnsCopyWith<_$Expr_Columns> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_DtypeColumnCopyWith<$Res> {
  factory _$$Expr_DtypeColumnCopyWith(
          _$Expr_DtypeColumn value, $Res Function(_$Expr_DtypeColumn) then) =
      __$$Expr_DtypeColumnCopyWithImpl<$Res>;
  @useResult
  $Res call({List<DataType> field0});
}

/// @nodoc
class __$$Expr_DtypeColumnCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_DtypeColumn>
    implements _$$Expr_DtypeColumnCopyWith<$Res> {
  __$$Expr_DtypeColumnCopyWithImpl(
      _$Expr_DtypeColumn _value, $Res Function(_$Expr_DtypeColumn) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_DtypeColumn(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<DataType>,
    ));
  }
}

/// @nodoc

class _$Expr_DtypeColumn implements Expr_DtypeColumn {
  const _$Expr_DtypeColumn(final List<DataType> field0) : _field0 = field0;

  final List<DataType> _field0;
  @override
  List<DataType> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Expr.dtypeColumn(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_DtypeColumn &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_DtypeColumnCopyWith<_$Expr_DtypeColumn> get copyWith =>
      __$$Expr_DtypeColumnCopyWithImpl<_$Expr_DtypeColumn>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return dtypeColumn(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return dtypeColumn?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (dtypeColumn != null) {
      return dtypeColumn(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return dtypeColumn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return dtypeColumn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (dtypeColumn != null) {
      return dtypeColumn(this);
    }
    return orElse();
  }
}

abstract class Expr_DtypeColumn implements Expr {
  const factory Expr_DtypeColumn(final List<DataType> field0) =
      _$Expr_DtypeColumn;

  List<DataType> get field0;
  @JsonKey(ignore: true)
  _$$Expr_DtypeColumnCopyWith<_$Expr_DtypeColumn> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_LiteralCopyWith<$Res> {
  factory _$$Expr_LiteralCopyWith(
          _$Expr_Literal value, $Res Function(_$Expr_Literal) then) =
      __$$Expr_LiteralCopyWithImpl<$Res>;
  @useResult
  $Res call({LiteralValue field0});

  $LiteralValueCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_LiteralCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Literal>
    implements _$$Expr_LiteralCopyWith<$Res> {
  __$$Expr_LiteralCopyWithImpl(
      _$Expr_Literal _value, $Res Function(_$Expr_Literal) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_Literal(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as LiteralValue,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LiteralValueCopyWith<$Res> get field0 {
    return $LiteralValueCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_Literal implements Expr_Literal {
  const _$Expr_Literal(this.field0);

  @override
  final LiteralValue field0;

  @override
  String toString() {
    return 'Expr.literal(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Literal &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_LiteralCopyWith<_$Expr_Literal> get copyWith =>
      __$$Expr_LiteralCopyWithImpl<_$Expr_Literal>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return literal(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return literal?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (literal != null) {
      return literal(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return literal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return literal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (literal != null) {
      return literal(this);
    }
    return orElse();
  }
}

abstract class Expr_Literal implements Expr {
  const factory Expr_Literal(final LiteralValue field0) = _$Expr_Literal;

  LiteralValue get field0;
  @JsonKey(ignore: true)
  _$$Expr_LiteralCopyWith<_$Expr_Literal> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_BinaryExprCopyWith<$Res> {
  factory _$$Expr_BinaryExprCopyWith(
          _$Expr_BinaryExpr value, $Res Function(_$Expr_BinaryExpr) then) =
      __$$Expr_BinaryExprCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr left, Operator op, Expr right});

  $ExprCopyWith<$Res> get left;
  $ExprCopyWith<$Res> get right;
}

/// @nodoc
class __$$Expr_BinaryExprCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_BinaryExpr>
    implements _$$Expr_BinaryExprCopyWith<$Res> {
  __$$Expr_BinaryExprCopyWithImpl(
      _$Expr_BinaryExpr _value, $Res Function(_$Expr_BinaryExpr) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? left = null,
    Object? op = null,
    Object? right = null,
  }) {
    return _then(_$Expr_BinaryExpr(
      left: null == left
          ? _value.left
          : left // ignore: cast_nullable_to_non_nullable
              as Expr,
      op: null == op
          ? _value.op
          : op // ignore: cast_nullable_to_non_nullable
              as Operator,
      right: null == right
          ? _value.right
          : right // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get left {
    return $ExprCopyWith<$Res>(_value.left, (value) {
      return _then(_value.copyWith(left: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get right {
    return $ExprCopyWith<$Res>(_value.right, (value) {
      return _then(_value.copyWith(right: value));
    });
  }
}

/// @nodoc

class _$Expr_BinaryExpr implements Expr_BinaryExpr {
  const _$Expr_BinaryExpr(
      {required this.left, required this.op, required this.right});

  /// The left-hand side column.
  @override
  final Expr left;

  /// The operator, e.g. ==, >, <.
  @override
  final Operator op;

  /// The right-hand side column.
  @override
  final Expr right;

  @override
  String toString() {
    return 'Expr.binaryExpr(left: $left, op: $op, right: $right)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_BinaryExpr &&
            (identical(other.left, left) || other.left == left) &&
            (identical(other.op, op) || other.op == op) &&
            (identical(other.right, right) || other.right == right));
  }

  @override
  int get hashCode => Object.hash(runtimeType, left, op, right);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_BinaryExprCopyWith<_$Expr_BinaryExpr> get copyWith =>
      __$$Expr_BinaryExprCopyWithImpl<_$Expr_BinaryExpr>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return binaryExpr(left, op, right);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return binaryExpr?.call(left, op, right);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (binaryExpr != null) {
      return binaryExpr(left, op, right);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return binaryExpr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return binaryExpr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (binaryExpr != null) {
      return binaryExpr(this);
    }
    return orElse();
  }
}

abstract class Expr_BinaryExpr implements Expr {
  const factory Expr_BinaryExpr(
      {required final Expr left,
      required final Operator op,
      required final Expr right}) = _$Expr_BinaryExpr;

  /// The left-hand side column.
  Expr get left;

  /// The operator, e.g. ==, >, <.
  Operator get op;

  /// The right-hand side column.
  Expr get right;
  @JsonKey(ignore: true)
  _$$Expr_BinaryExprCopyWith<_$Expr_BinaryExpr> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_CastCopyWith<$Res> {
  factory _$$Expr_CastCopyWith(
          _$Expr_Cast value, $Res Function(_$Expr_Cast) then) =
      __$$Expr_CastCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr expr, DataType dataType, bool strict});

  $ExprCopyWith<$Res> get expr;
  $DataTypeCopyWith<$Res> get dataType;
}

/// @nodoc
class __$$Expr_CastCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Cast>
    implements _$$Expr_CastCopyWith<$Res> {
  __$$Expr_CastCopyWithImpl(
      _$Expr_Cast _value, $Res Function(_$Expr_Cast) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expr = null,
    Object? dataType = null,
    Object? strict = null,
  }) {
    return _then(_$Expr_Cast(
      expr: null == expr
          ? _value.expr
          : expr // ignore: cast_nullable_to_non_nullable
              as Expr,
      dataType: null == dataType
          ? _value.dataType
          : dataType // ignore: cast_nullable_to_non_nullable
              as DataType,
      strict: null == strict
          ? _value.strict
          : strict // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get expr {
    return $ExprCopyWith<$Res>(_value.expr, (value) {
      return _then(_value.copyWith(expr: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get dataType {
    return $DataTypeCopyWith<$Res>(_value.dataType, (value) {
      return _then(_value.copyWith(dataType: value));
    });
  }
}

/// @nodoc

class _$Expr_Cast implements Expr_Cast {
  const _$Expr_Cast(
      {required this.expr, required this.dataType, required this.strict});

  /// The column to be cast.
  @override
  final Expr expr;

  /// The new desired datatype.
  @override
  final DataType dataType;

  /// Whether incompatible values should be coerced.
  @override
  final bool strict;

  @override
  String toString() {
    return 'Expr.cast(expr: $expr, dataType: $dataType, strict: $strict)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Cast &&
            (identical(other.expr, expr) || other.expr == expr) &&
            (identical(other.dataType, dataType) ||
                other.dataType == dataType) &&
            (identical(other.strict, strict) || other.strict == strict));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expr, dataType, strict);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_CastCopyWith<_$Expr_Cast> get copyWith =>
      __$$Expr_CastCopyWithImpl<_$Expr_Cast>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return cast(expr, dataType, strict);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return cast?.call(expr, dataType, strict);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (cast != null) {
      return cast(expr, dataType, strict);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return cast(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return cast?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (cast != null) {
      return cast(this);
    }
    return orElse();
  }
}

abstract class Expr_Cast implements Expr {
  const factory Expr_Cast(
      {required final Expr expr,
      required final DataType dataType,
      required final bool strict}) = _$Expr_Cast;

  /// The column to be cast.
  Expr get expr;

  /// The new desired datatype.
  DataType get dataType;

  /// Whether incompatible values should be coerced.
  bool get strict;
  @JsonKey(ignore: true)
  _$$Expr_CastCopyWith<_$Expr_Cast> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_SortCopyWith<$Res> {
  factory _$$Expr_SortCopyWith(
          _$Expr_Sort value, $Res Function(_$Expr_Sort) then) =
      __$$Expr_SortCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr expr, SortOptions options});

  $ExprCopyWith<$Res> get expr;
}

/// @nodoc
class __$$Expr_SortCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Sort>
    implements _$$Expr_SortCopyWith<$Res> {
  __$$Expr_SortCopyWithImpl(
      _$Expr_Sort _value, $Res Function(_$Expr_Sort) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expr = null,
    Object? options = null,
  }) {
    return _then(_$Expr_Sort(
      expr: null == expr
          ? _value.expr
          : expr // ignore: cast_nullable_to_non_nullable
              as Expr,
      options: null == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as SortOptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get expr {
    return $ExprCopyWith<$Res>(_value.expr, (value) {
      return _then(_value.copyWith(expr: value));
    });
  }
}

/// @nodoc

class _$Expr_Sort implements Expr_Sort {
  const _$Expr_Sort({required this.expr, required this.options});

  /// The column to be sorted.
  @override
  final Expr expr;

  /// Options for sorting.
  @override
  final SortOptions options;

  @override
  String toString() {
    return 'Expr.sort(expr: $expr, options: $options)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Sort &&
            (identical(other.expr, expr) || other.expr == expr) &&
            (identical(other.options, options) || other.options == options));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expr, options);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_SortCopyWith<_$Expr_Sort> get copyWith =>
      __$$Expr_SortCopyWithImpl<_$Expr_Sort>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return sort(expr, options);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return sort?.call(expr, options);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (sort != null) {
      return sort(expr, options);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return sort(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return sort?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (sort != null) {
      return sort(this);
    }
    return orElse();
  }
}

abstract class Expr_Sort implements Expr {
  const factory Expr_Sort(
      {required final Expr expr,
      required final SortOptions options}) = _$Expr_Sort;

  /// The column to be sorted.
  Expr get expr;

  /// Options for sorting.
  SortOptions get options;
  @JsonKey(ignore: true)
  _$$Expr_SortCopyWith<_$Expr_Sort> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_TakeCopyWith<$Res> {
  factory _$$Expr_TakeCopyWith(
          _$Expr_Take value, $Res Function(_$Expr_Take) then) =
      __$$Expr_TakeCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr expr, Expr idx});

  $ExprCopyWith<$Res> get expr;
  $ExprCopyWith<$Res> get idx;
}

/// @nodoc
class __$$Expr_TakeCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Take>
    implements _$$Expr_TakeCopyWith<$Res> {
  __$$Expr_TakeCopyWithImpl(
      _$Expr_Take _value, $Res Function(_$Expr_Take) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expr = null,
    Object? idx = null,
  }) {
    return _then(_$Expr_Take(
      expr: null == expr
          ? _value.expr
          : expr // ignore: cast_nullable_to_non_nullable
              as Expr,
      idx: null == idx
          ? _value.idx
          : idx // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get expr {
    return $ExprCopyWith<$Res>(_value.expr, (value) {
      return _then(_value.copyWith(expr: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get idx {
    return $ExprCopyWith<$Res>(_value.idx, (value) {
      return _then(_value.copyWith(idx: value));
    });
  }
}

/// @nodoc

class _$Expr_Take implements Expr_Take {
  const _$Expr_Take({required this.expr, required this.idx});

  /// The column from which to take.
  @override
  final Expr expr;

  /// The index to take at.
  @override
  final Expr idx;

  @override
  String toString() {
    return 'Expr.take(expr: $expr, idx: $idx)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Take &&
            (identical(other.expr, expr) || other.expr == expr) &&
            (identical(other.idx, idx) || other.idx == idx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expr, idx);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_TakeCopyWith<_$Expr_Take> get copyWith =>
      __$$Expr_TakeCopyWithImpl<_$Expr_Take>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return take(expr, idx);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return take?.call(expr, idx);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (take != null) {
      return take(expr, idx);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return take(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return take?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (take != null) {
      return take(this);
    }
    return orElse();
  }
}

abstract class Expr_Take implements Expr {
  const factory Expr_Take({required final Expr expr, required final Expr idx}) =
      _$Expr_Take;

  /// The column from which to take.
  Expr get expr;

  /// The index to take at.
  Expr get idx;
  @JsonKey(ignore: true)
  _$$Expr_TakeCopyWith<_$Expr_Take> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_AggCopyWith<$Res> {
  factory _$$Expr_AggCopyWith(
          _$Expr_Agg value, $Res Function(_$Expr_Agg) then) =
      __$$Expr_AggCopyWithImpl<$Res>;
  @useResult
  $Res call({AggExpr field0});

  $AggExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_AggCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Agg>
    implements _$$Expr_AggCopyWith<$Res> {
  __$$Expr_AggCopyWithImpl(_$Expr_Agg _value, $Res Function(_$Expr_Agg) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_Agg(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as AggExpr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AggExprCopyWith<$Res> get field0 {
    return $AggExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_Agg implements Expr_Agg {
  const _$Expr_Agg(this.field0);

  @override
  final AggExpr field0;

  @override
  String toString() {
    return 'Expr.agg(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Agg &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_AggCopyWith<_$Expr_Agg> get copyWith =>
      __$$Expr_AggCopyWithImpl<_$Expr_Agg>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return agg(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return agg?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (agg != null) {
      return agg(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return agg(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return agg?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (agg != null) {
      return agg(this);
    }
    return orElse();
  }
}

abstract class Expr_Agg implements Expr {
  const factory Expr_Agg(final AggExpr field0) = _$Expr_Agg;

  AggExpr get field0;
  @JsonKey(ignore: true)
  _$$Expr_AggCopyWith<_$Expr_Agg> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_TernaryCopyWith<$Res> {
  factory _$$Expr_TernaryCopyWith(
          _$Expr_Ternary value, $Res Function(_$Expr_Ternary) then) =
      __$$Expr_TernaryCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr predicate, Expr truthy, Expr falsy});

  $ExprCopyWith<$Res> get predicate;
  $ExprCopyWith<$Res> get truthy;
  $ExprCopyWith<$Res> get falsy;
}

/// @nodoc
class __$$Expr_TernaryCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Ternary>
    implements _$$Expr_TernaryCopyWith<$Res> {
  __$$Expr_TernaryCopyWithImpl(
      _$Expr_Ternary _value, $Res Function(_$Expr_Ternary) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? predicate = null,
    Object? truthy = null,
    Object? falsy = null,
  }) {
    return _then(_$Expr_Ternary(
      predicate: null == predicate
          ? _value.predicate
          : predicate // ignore: cast_nullable_to_non_nullable
              as Expr,
      truthy: null == truthy
          ? _value.truthy
          : truthy // ignore: cast_nullable_to_non_nullable
              as Expr,
      falsy: null == falsy
          ? _value.falsy
          : falsy // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get predicate {
    return $ExprCopyWith<$Res>(_value.predicate, (value) {
      return _then(_value.copyWith(predicate: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get truthy {
    return $ExprCopyWith<$Res>(_value.truthy, (value) {
      return _then(_value.copyWith(truthy: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get falsy {
    return $ExprCopyWith<$Res>(_value.falsy, (value) {
      return _then(_value.copyWith(falsy: value));
    });
  }
}

/// @nodoc

class _$Expr_Ternary implements Expr_Ternary {
  const _$Expr_Ternary(
      {required this.predicate, required this.truthy, required this.falsy});

  /// The condition for this ternary.
  @override
  final Expr predicate;

  /// If `predicate` is true, evaluate to this.
  @override
  final Expr truthy;

  /// If `predicate` is false, evaluate to this.
  @override
  final Expr falsy;

  @override
  String toString() {
    return 'Expr.ternary(predicate: $predicate, truthy: $truthy, falsy: $falsy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Ternary &&
            (identical(other.predicate, predicate) ||
                other.predicate == predicate) &&
            (identical(other.truthy, truthy) || other.truthy == truthy) &&
            (identical(other.falsy, falsy) || other.falsy == falsy));
  }

  @override
  int get hashCode => Object.hash(runtimeType, predicate, truthy, falsy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_TernaryCopyWith<_$Expr_Ternary> get copyWith =>
      __$$Expr_TernaryCopyWithImpl<_$Expr_Ternary>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return ternary(predicate, truthy, falsy);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return ternary?.call(predicate, truthy, falsy);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (ternary != null) {
      return ternary(predicate, truthy, falsy);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return ternary(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return ternary?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (ternary != null) {
      return ternary(this);
    }
    return orElse();
  }
}

abstract class Expr_Ternary implements Expr {
  const factory Expr_Ternary(
      {required final Expr predicate,
      required final Expr truthy,
      required final Expr falsy}) = _$Expr_Ternary;

  /// The condition for this ternary.
  Expr get predicate;

  /// If `predicate` is true, evaluate to this.
  Expr get truthy;

  /// If `predicate` is false, evaluate to this.
  Expr get falsy;
  @JsonKey(ignore: true)
  _$$Expr_TernaryCopyWith<_$Expr_Ternary> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_ExplodeCopyWith<$Res> {
  factory _$$Expr_ExplodeCopyWith(
          _$Expr_Explode value, $Res Function(_$Expr_Explode) then) =
      __$$Expr_ExplodeCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_ExplodeCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Explode>
    implements _$$Expr_ExplodeCopyWith<$Res> {
  __$$Expr_ExplodeCopyWithImpl(
      _$Expr_Explode _value, $Res Function(_$Expr_Explode) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_Explode(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_Explode implements Expr_Explode {
  const _$Expr_Explode(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'Expr.explode(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Explode &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_ExplodeCopyWith<_$Expr_Explode> get copyWith =>
      __$$Expr_ExplodeCopyWithImpl<_$Expr_Explode>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return explode(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return explode?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (explode != null) {
      return explode(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return explode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return explode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (explode != null) {
      return explode(this);
    }
    return orElse();
  }
}

abstract class Expr_Explode implements Expr {
  const factory Expr_Explode(final Expr field0) = _$Expr_Explode;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$Expr_ExplodeCopyWith<_$Expr_Explode> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_FilterCopyWith<$Res> {
  factory _$$Expr_FilterCopyWith(
          _$Expr_Filter value, $Res Function(_$Expr_Filter) then) =
      __$$Expr_FilterCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr input, Expr by});

  $ExprCopyWith<$Res> get input;
  $ExprCopyWith<$Res> get by;
}

/// @nodoc
class __$$Expr_FilterCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Filter>
    implements _$$Expr_FilterCopyWith<$Res> {
  __$$Expr_FilterCopyWithImpl(
      _$Expr_Filter _value, $Res Function(_$Expr_Filter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? by = null,
  }) {
    return _then(_$Expr_Filter(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as Expr,
      by: null == by
          ? _value.by
          : by // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get input {
    return $ExprCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get by {
    return $ExprCopyWith<$Res>(_value.by, (value) {
      return _then(_value.copyWith(by: value));
    });
  }
}

/// @nodoc

class _$Expr_Filter implements Expr_Filter {
  const _$Expr_Filter({required this.input, required this.by});

  /// The column to be filtered.
  @override
  final Expr input;

  /// The conditions by which this column should be filtered.
  @override
  final Expr by;

  @override
  String toString() {
    return 'Expr.filter(input: $input, by: $by)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Filter &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.by, by) || other.by == by));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input, by);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_FilterCopyWith<_$Expr_Filter> get copyWith =>
      __$$Expr_FilterCopyWithImpl<_$Expr_Filter>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return filter(input, by);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return filter?.call(input, by);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (filter != null) {
      return filter(input, by);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return filter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return filter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (filter != null) {
      return filter(this);
    }
    return orElse();
  }
}

abstract class Expr_Filter implements Expr {
  const factory Expr_Filter(
      {required final Expr input, required final Expr by}) = _$Expr_Filter;

  /// The column to be filtered.
  Expr get input;

  /// The conditions by which this column should be filtered.
  Expr get by;
  @JsonKey(ignore: true)
  _$$Expr_FilterCopyWith<_$Expr_Filter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_WildcardCopyWith<$Res> {
  factory _$$Expr_WildcardCopyWith(
          _$Expr_Wildcard value, $Res Function(_$Expr_Wildcard) then) =
      __$$Expr_WildcardCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Expr_WildcardCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Wildcard>
    implements _$$Expr_WildcardCopyWith<$Res> {
  __$$Expr_WildcardCopyWithImpl(
      _$Expr_Wildcard _value, $Res Function(_$Expr_Wildcard) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Expr_Wildcard implements Expr_Wildcard {
  const _$Expr_Wildcard();

  @override
  String toString() {
    return 'Expr.wildcard()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Expr_Wildcard);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return wildcard();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return wildcard?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (wildcard != null) {
      return wildcard();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return wildcard(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return wildcard?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (wildcard != null) {
      return wildcard(this);
    }
    return orElse();
  }
}

abstract class Expr_Wildcard implements Expr {
  const factory Expr_Wildcard() = _$Expr_Wildcard;
}

/// @nodoc
abstract class _$$Expr_SliceCopyWith<$Res> {
  factory _$$Expr_SliceCopyWith(
          _$Expr_Slice value, $Res Function(_$Expr_Slice) then) =
      __$$Expr_SliceCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr input, Expr offset, Expr length});

  $ExprCopyWith<$Res> get input;
  $ExprCopyWith<$Res> get offset;
  $ExprCopyWith<$Res> get length;
}

/// @nodoc
class __$$Expr_SliceCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Slice>
    implements _$$Expr_SliceCopyWith<$Res> {
  __$$Expr_SliceCopyWithImpl(
      _$Expr_Slice _value, $Res Function(_$Expr_Slice) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? offset = null,
    Object? length = null,
  }) {
    return _then(_$Expr_Slice(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as Expr,
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as Expr,
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get input {
    return $ExprCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get offset {
    return $ExprCopyWith<$Res>(_value.offset, (value) {
      return _then(_value.copyWith(offset: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get length {
    return $ExprCopyWith<$Res>(_value.length, (value) {
      return _then(_value.copyWith(length: value));
    });
  }
}

/// @nodoc

class _$Expr_Slice implements Expr_Slice {
  const _$Expr_Slice(
      {required this.input, required this.offset, required this.length});

  /// The column to take slices of.
  @override
  final Expr input;

  /// Length is not yet known so we accept negative offsets
  @override
  final Expr offset;

  /// How long the slice should be.
  @override
  final Expr length;

  @override
  String toString() {
    return 'Expr.slice(input: $input, offset: $offset, length: $length)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Slice &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.length, length) || other.length == length));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input, offset, length);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_SliceCopyWith<_$Expr_Slice> get copyWith =>
      __$$Expr_SliceCopyWithImpl<_$Expr_Slice>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return slice(input, offset, length);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return slice?.call(input, offset, length);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (slice != null) {
      return slice(input, offset, length);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return slice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return slice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (slice != null) {
      return slice(this);
    }
    return orElse();
  }
}

abstract class Expr_Slice implements Expr {
  const factory Expr_Slice(
      {required final Expr input,
      required final Expr offset,
      required final Expr length}) = _$Expr_Slice;

  /// The column to take slices of.
  Expr get input;

  /// Length is not yet known so we accept negative offsets
  Expr get offset;

  /// How long the slice should be.
  Expr get length;
  @JsonKey(ignore: true)
  _$$Expr_SliceCopyWith<_$Expr_Slice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_ExcludeCopyWith<$Res> {
  factory _$$Expr_ExcludeCopyWith(
          _$Expr_Exclude value, $Res Function(_$Expr_Exclude) then) =
      __$$Expr_ExcludeCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0, List<Excluded> field1});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_ExcludeCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Exclude>
    implements _$$Expr_ExcludeCopyWith<$Res> {
  __$$Expr_ExcludeCopyWithImpl(
      _$Expr_Exclude _value, $Res Function(_$Expr_Exclude) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$Expr_Exclude(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
      null == field1
          ? _value._field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as List<Excluded>,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_Exclude implements Expr_Exclude {
  const _$Expr_Exclude(this.field0, final List<Excluded> field1)
      : _field1 = field1;

  @override
  final Expr field0;
  final List<Excluded> _field1;
  @override
  List<Excluded> get field1 {
    if (_field1 is EqualUnmodifiableListView) return _field1;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field1);
  }

  @override
  String toString() {
    return 'Expr.exclude(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Exclude &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            const DeepCollectionEquality().equals(other._field1, _field1));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, field0, const DeepCollectionEquality().hash(_field1));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_ExcludeCopyWith<_$Expr_Exclude> get copyWith =>
      __$$Expr_ExcludeCopyWithImpl<_$Expr_Exclude>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return exclude(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return exclude?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (exclude != null) {
      return exclude(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return exclude(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return exclude?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (exclude != null) {
      return exclude(this);
    }
    return orElse();
  }
}

abstract class Expr_Exclude implements Expr {
  const factory Expr_Exclude(final Expr field0, final List<Excluded> field1) =
      _$Expr_Exclude;

  Expr get field0;
  List<Excluded> get field1;
  @JsonKey(ignore: true)
  _$$Expr_ExcludeCopyWith<_$Expr_Exclude> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_KeepNameCopyWith<$Res> {
  factory _$$Expr_KeepNameCopyWith(
          _$Expr_KeepName value, $Res Function(_$Expr_KeepName) then) =
      __$$Expr_KeepNameCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_KeepNameCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_KeepName>
    implements _$$Expr_KeepNameCopyWith<$Res> {
  __$$Expr_KeepNameCopyWithImpl(
      _$Expr_KeepName _value, $Res Function(_$Expr_KeepName) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_KeepName(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_KeepName implements Expr_KeepName {
  const _$Expr_KeepName(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'Expr.keepName(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_KeepName &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_KeepNameCopyWith<_$Expr_KeepName> get copyWith =>
      __$$Expr_KeepNameCopyWithImpl<_$Expr_KeepName>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return keepName(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return keepName?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (keepName != null) {
      return keepName(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return keepName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return keepName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (keepName != null) {
      return keepName(this);
    }
    return orElse();
  }
}

abstract class Expr_KeepName implements Expr {
  const factory Expr_KeepName(final Expr field0) = _$Expr_KeepName;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$Expr_KeepNameCopyWith<_$Expr_KeepName> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_CountCopyWith<$Res> {
  factory _$$Expr_CountCopyWith(
          _$Expr_Count value, $Res Function(_$Expr_Count) then) =
      __$$Expr_CountCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Expr_CountCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Count>
    implements _$$Expr_CountCopyWith<$Res> {
  __$$Expr_CountCopyWithImpl(
      _$Expr_Count _value, $Res Function(_$Expr_Count) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Expr_Count implements Expr_Count {
  const _$Expr_Count();

  @override
  String toString() {
    return 'Expr.count()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Expr_Count);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return count();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return count?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (count != null) {
      return count();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return count(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return count?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (count != null) {
      return count(this);
    }
    return orElse();
  }
}

abstract class Expr_Count implements Expr {
  const factory Expr_Count() = _$Expr_Count;
}

/// @nodoc
abstract class _$$Expr_NthCopyWith<$Res> {
  factory _$$Expr_NthCopyWith(
          _$Expr_Nth value, $Res Function(_$Expr_Nth) then) =
      __$$Expr_NthCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Expr_NthCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_Nth>
    implements _$$Expr_NthCopyWith<$Res> {
  __$$Expr_NthCopyWithImpl(_$Expr_Nth _value, $Res Function(_$Expr_Nth) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_Nth(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Expr_Nth implements Expr_Nth {
  const _$Expr_Nth(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'Expr.nth(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_Nth &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_NthCopyWith<_$Expr_Nth> get copyWith =>
      __$$Expr_NthCopyWithImpl<_$Expr_Nth>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx) take,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return nth(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx)? take,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return nth?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx)? take,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (nth != null) {
      return nth(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Take value) take,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return nth(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Take value)? take,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return nth?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Take value)? take,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (nth != null) {
      return nth(this);
    }
    return orElse();
  }
}

abstract class Expr_Nth implements Expr {
  const factory Expr_Nth(final int field0) = _$Expr_Nth;

  int get field0;
  @JsonKey(ignore: true)
  _$$Expr_NthCopyWith<_$Expr_Nth> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LiteralValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LiteralValueCopyWith<$Res> {
  factory $LiteralValueCopyWith(
          LiteralValue value, $Res Function(LiteralValue) then) =
      _$LiteralValueCopyWithImpl<$Res, LiteralValue>;
}

/// @nodoc
class _$LiteralValueCopyWithImpl<$Res, $Val extends LiteralValue>
    implements $LiteralValueCopyWith<$Res> {
  _$LiteralValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LiteralValue_BooleanCopyWith<$Res> {
  factory _$$LiteralValue_BooleanCopyWith(_$LiteralValue_Boolean value,
          $Res Function(_$LiteralValue_Boolean) then) =
      __$$LiteralValue_BooleanCopyWithImpl<$Res>;
  @useResult
  $Res call({bool field0});
}

/// @nodoc
class __$$LiteralValue_BooleanCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Boolean>
    implements _$$LiteralValue_BooleanCopyWith<$Res> {
  __$$LiteralValue_BooleanCopyWithImpl(_$LiteralValue_Boolean _value,
      $Res Function(_$LiteralValue_Boolean) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Boolean(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Boolean implements LiteralValue_Boolean {
  const _$LiteralValue_Boolean(this.field0);

  @override
  final bool field0;

  @override
  String toString() {
    return 'LiteralValue.boolean(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Boolean &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_BooleanCopyWith<_$LiteralValue_Boolean> get copyWith =>
      __$$LiteralValue_BooleanCopyWithImpl<_$LiteralValue_Boolean>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return boolean(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return boolean?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Boolean implements LiteralValue {
  const factory LiteralValue_Boolean(final bool field0) =
      _$LiteralValue_Boolean;

  bool get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_BooleanCopyWith<_$LiteralValue_Boolean> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Utf8CopyWith<$Res> {
  factory _$$LiteralValue_Utf8CopyWith(
          _$LiteralValue_Utf8 value, $Res Function(_$LiteralValue_Utf8) then) =
      __$$LiteralValue_Utf8CopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$LiteralValue_Utf8CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Utf8>
    implements _$$LiteralValue_Utf8CopyWith<$Res> {
  __$$LiteralValue_Utf8CopyWithImpl(
      _$LiteralValue_Utf8 _value, $Res Function(_$LiteralValue_Utf8) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Utf8(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Utf8 implements LiteralValue_Utf8 {
  const _$LiteralValue_Utf8(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'LiteralValue.utf8(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Utf8 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Utf8CopyWith<_$LiteralValue_Utf8> get copyWith =>
      __$$LiteralValue_Utf8CopyWithImpl<_$LiteralValue_Utf8>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return utf8(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return utf8?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return utf8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return utf8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Utf8 implements LiteralValue {
  const factory LiteralValue_Utf8(final String field0) = _$LiteralValue_Utf8;

  String get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Utf8CopyWith<_$LiteralValue_Utf8> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_BinaryCopyWith<$Res> {
  factory _$$LiteralValue_BinaryCopyWith(_$LiteralValue_Binary value,
          $Res Function(_$LiteralValue_Binary) then) =
      __$$LiteralValue_BinaryCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$LiteralValue_BinaryCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Binary>
    implements _$$LiteralValue_BinaryCopyWith<$Res> {
  __$$LiteralValue_BinaryCopyWithImpl(
      _$LiteralValue_Binary _value, $Res Function(_$LiteralValue_Binary) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Binary(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Binary implements LiteralValue_Binary {
  const _$LiteralValue_Binary(this.field0);

  @override
  final Uint8List field0;

  @override
  String toString() {
    return 'LiteralValue.binary(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Binary &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_BinaryCopyWith<_$LiteralValue_Binary> get copyWith =>
      __$$LiteralValue_BinaryCopyWithImpl<_$LiteralValue_Binary>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return binary(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return binary?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return binary(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return binary?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Binary implements LiteralValue {
  const factory LiteralValue_Binary(final Uint8List field0) =
      _$LiteralValue_Binary;

  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_BinaryCopyWith<_$LiteralValue_Binary> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt8CopyWith<$Res> {
  factory _$$LiteralValue_UInt8CopyWith(_$LiteralValue_UInt8 value,
          $Res Function(_$LiteralValue_UInt8) then) =
      __$$LiteralValue_UInt8CopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt8CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt8>
    implements _$$LiteralValue_UInt8CopyWith<$Res> {
  __$$LiteralValue_UInt8CopyWithImpl(
      _$LiteralValue_UInt8 _value, $Res Function(_$LiteralValue_UInt8) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt8(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt8 implements LiteralValue_UInt8 {
  const _$LiteralValue_UInt8(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt8(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt8 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt8CopyWith<_$LiteralValue_UInt8> get copyWith =>
      __$$LiteralValue_UInt8CopyWithImpl<_$LiteralValue_UInt8>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return uInt8(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return uInt8?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return uInt8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return uInt8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt8 implements LiteralValue {
  const factory LiteralValue_UInt8(final int field0) = _$LiteralValue_UInt8;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt8CopyWith<_$LiteralValue_UInt8> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt16CopyWith<$Res> {
  factory _$$LiteralValue_UInt16CopyWith(_$LiteralValue_UInt16 value,
          $Res Function(_$LiteralValue_UInt16) then) =
      __$$LiteralValue_UInt16CopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt16CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt16>
    implements _$$LiteralValue_UInt16CopyWith<$Res> {
  __$$LiteralValue_UInt16CopyWithImpl(
      _$LiteralValue_UInt16 _value, $Res Function(_$LiteralValue_UInt16) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt16(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt16 implements LiteralValue_UInt16 {
  const _$LiteralValue_UInt16(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt16(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt16 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt16CopyWith<_$LiteralValue_UInt16> get copyWith =>
      __$$LiteralValue_UInt16CopyWithImpl<_$LiteralValue_UInt16>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return uInt16(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return uInt16?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return uInt16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return uInt16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt16 implements LiteralValue {
  const factory LiteralValue_UInt16(final int field0) = _$LiteralValue_UInt16;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt16CopyWith<_$LiteralValue_UInt16> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt32CopyWith<$Res> {
  factory _$$LiteralValue_UInt32CopyWith(_$LiteralValue_UInt32 value,
          $Res Function(_$LiteralValue_UInt32) then) =
      __$$LiteralValue_UInt32CopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt32CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt32>
    implements _$$LiteralValue_UInt32CopyWith<$Res> {
  __$$LiteralValue_UInt32CopyWithImpl(
      _$LiteralValue_UInt32 _value, $Res Function(_$LiteralValue_UInt32) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt32(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt32 implements LiteralValue_UInt32 {
  const _$LiteralValue_UInt32(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt32(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt32 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt32CopyWith<_$LiteralValue_UInt32> get copyWith =>
      __$$LiteralValue_UInt32CopyWithImpl<_$LiteralValue_UInt32>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return uInt32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return uInt32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return uInt32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return uInt32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt32 implements LiteralValue {
  const factory LiteralValue_UInt32(final int field0) = _$LiteralValue_UInt32;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt32CopyWith<_$LiteralValue_UInt32> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt64CopyWith<$Res> {
  factory _$$LiteralValue_UInt64CopyWith(_$LiteralValue_UInt64 value,
          $Res Function(_$LiteralValue_UInt64) then) =
      __$$LiteralValue_UInt64CopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt64CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt64>
    implements _$$LiteralValue_UInt64CopyWith<$Res> {
  __$$LiteralValue_UInt64CopyWithImpl(
      _$LiteralValue_UInt64 _value, $Res Function(_$LiteralValue_UInt64) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt64(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt64 implements LiteralValue_UInt64 {
  const _$LiteralValue_UInt64(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt64(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt64 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt64CopyWith<_$LiteralValue_UInt64> get copyWith =>
      __$$LiteralValue_UInt64CopyWithImpl<_$LiteralValue_UInt64>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return uInt64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return uInt64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return uInt64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return uInt64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt64 implements LiteralValue {
  const factory LiteralValue_UInt64(final int field0) = _$LiteralValue_UInt64;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt64CopyWith<_$LiteralValue_UInt64> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int8CopyWith<$Res> {
  factory _$$LiteralValue_Int8CopyWith(
          _$LiteralValue_Int8 value, $Res Function(_$LiteralValue_Int8) then) =
      __$$LiteralValue_Int8CopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int8CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int8>
    implements _$$LiteralValue_Int8CopyWith<$Res> {
  __$$LiteralValue_Int8CopyWithImpl(
      _$LiteralValue_Int8 _value, $Res Function(_$LiteralValue_Int8) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int8(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int8 implements LiteralValue_Int8 {
  const _$LiteralValue_Int8(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int8(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int8 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int8CopyWith<_$LiteralValue_Int8> get copyWith =>
      __$$LiteralValue_Int8CopyWithImpl<_$LiteralValue_Int8>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return int8(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return int8?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return int8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return int8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int8 implements LiteralValue {
  const factory LiteralValue_Int8(final int field0) = _$LiteralValue_Int8;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int8CopyWith<_$LiteralValue_Int8> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int16CopyWith<$Res> {
  factory _$$LiteralValue_Int16CopyWith(_$LiteralValue_Int16 value,
          $Res Function(_$LiteralValue_Int16) then) =
      __$$LiteralValue_Int16CopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int16CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int16>
    implements _$$LiteralValue_Int16CopyWith<$Res> {
  __$$LiteralValue_Int16CopyWithImpl(
      _$LiteralValue_Int16 _value, $Res Function(_$LiteralValue_Int16) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int16(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int16 implements LiteralValue_Int16 {
  const _$LiteralValue_Int16(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int16(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int16 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int16CopyWith<_$LiteralValue_Int16> get copyWith =>
      __$$LiteralValue_Int16CopyWithImpl<_$LiteralValue_Int16>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return int16(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return int16?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return int16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return int16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int16 implements LiteralValue {
  const factory LiteralValue_Int16(final int field0) = _$LiteralValue_Int16;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int16CopyWith<_$LiteralValue_Int16> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int32CopyWith<$Res> {
  factory _$$LiteralValue_Int32CopyWith(_$LiteralValue_Int32 value,
          $Res Function(_$LiteralValue_Int32) then) =
      __$$LiteralValue_Int32CopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int32CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int32>
    implements _$$LiteralValue_Int32CopyWith<$Res> {
  __$$LiteralValue_Int32CopyWithImpl(
      _$LiteralValue_Int32 _value, $Res Function(_$LiteralValue_Int32) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int32(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int32 implements LiteralValue_Int32 {
  const _$LiteralValue_Int32(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int32(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int32 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int32CopyWith<_$LiteralValue_Int32> get copyWith =>
      __$$LiteralValue_Int32CopyWithImpl<_$LiteralValue_Int32>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return int32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return int32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return int32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return int32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int32 implements LiteralValue {
  const factory LiteralValue_Int32(final int field0) = _$LiteralValue_Int32;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int32CopyWith<_$LiteralValue_Int32> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int64CopyWith<$Res> {
  factory _$$LiteralValue_Int64CopyWith(_$LiteralValue_Int64 value,
          $Res Function(_$LiteralValue_Int64) then) =
      __$$LiteralValue_Int64CopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int64CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int64>
    implements _$$LiteralValue_Int64CopyWith<$Res> {
  __$$LiteralValue_Int64CopyWithImpl(
      _$LiteralValue_Int64 _value, $Res Function(_$LiteralValue_Int64) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int64(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int64 implements LiteralValue_Int64 {
  const _$LiteralValue_Int64(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int64(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int64 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int64CopyWith<_$LiteralValue_Int64> get copyWith =>
      __$$LiteralValue_Int64CopyWithImpl<_$LiteralValue_Int64>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return int64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return int64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return int64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return int64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int64 implements LiteralValue {
  const factory LiteralValue_Int64(final int field0) = _$LiteralValue_Int64;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int64CopyWith<_$LiteralValue_Int64> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Float32CopyWith<$Res> {
  factory _$$LiteralValue_Float32CopyWith(_$LiteralValue_Float32 value,
          $Res Function(_$LiteralValue_Float32) then) =
      __$$LiteralValue_Float32CopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$LiteralValue_Float32CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Float32>
    implements _$$LiteralValue_Float32CopyWith<$Res> {
  __$$LiteralValue_Float32CopyWithImpl(_$LiteralValue_Float32 _value,
      $Res Function(_$LiteralValue_Float32) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Float32(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Float32 implements LiteralValue_Float32 {
  const _$LiteralValue_Float32(this.field0);

  @override
  final double field0;

  @override
  String toString() {
    return 'LiteralValue.float32(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Float32 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Float32CopyWith<_$LiteralValue_Float32> get copyWith =>
      __$$LiteralValue_Float32CopyWithImpl<_$LiteralValue_Float32>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return float32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return float32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return float32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return float32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Float32 implements LiteralValue {
  const factory LiteralValue_Float32(final double field0) =
      _$LiteralValue_Float32;

  double get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Float32CopyWith<_$LiteralValue_Float32> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Float64CopyWith<$Res> {
  factory _$$LiteralValue_Float64CopyWith(_$LiteralValue_Float64 value,
          $Res Function(_$LiteralValue_Float64) then) =
      __$$LiteralValue_Float64CopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$LiteralValue_Float64CopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Float64>
    implements _$$LiteralValue_Float64CopyWith<$Res> {
  __$$LiteralValue_Float64CopyWithImpl(_$LiteralValue_Float64 _value,
      $Res Function(_$LiteralValue_Float64) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Float64(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Float64 implements LiteralValue_Float64 {
  const _$LiteralValue_Float64(this.field0);

  @override
  final double field0;

  @override
  String toString() {
    return 'LiteralValue.float64(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Float64 &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Float64CopyWith<_$LiteralValue_Float64> get copyWith =>
      __$$LiteralValue_Float64CopyWithImpl<_$LiteralValue_Float64>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return float64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return float64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return float64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return float64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Float64 implements LiteralValue {
  const factory LiteralValue_Float64(final double field0) =
      _$LiteralValue_Float64;

  double get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Float64CopyWith<_$LiteralValue_Float64> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_RangeCopyWith<$Res> {
  factory _$$LiteralValue_RangeCopyWith(_$LiteralValue_Range value,
          $Res Function(_$LiteralValue_Range) then) =
      __$$LiteralValue_RangeCopyWithImpl<$Res>;
  @useResult
  $Res call({int low, int high, DataType dataType});

  $DataTypeCopyWith<$Res> get dataType;
}

/// @nodoc
class __$$LiteralValue_RangeCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Range>
    implements _$$LiteralValue_RangeCopyWith<$Res> {
  __$$LiteralValue_RangeCopyWithImpl(
      _$LiteralValue_Range _value, $Res Function(_$LiteralValue_Range) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? low = null,
    Object? high = null,
    Object? dataType = null,
  }) {
    return _then(_$LiteralValue_Range(
      low: null == low
          ? _value.low
          : low // ignore: cast_nullable_to_non_nullable
              as int,
      high: null == high
          ? _value.high
          : high // ignore: cast_nullable_to_non_nullable
              as int,
      dataType: null == dataType
          ? _value.dataType
          : dataType // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get dataType {
    return $DataTypeCopyWith<$Res>(_value.dataType, (value) {
      return _then(_value.copyWith(dataType: value));
    });
  }
}

/// @nodoc

class _$LiteralValue_Range implements LiteralValue_Range {
  const _$LiteralValue_Range(
      {required this.low, required this.high, required this.dataType});

  /// The starting value of the range.
  @override
  final int low;

  /// The ending value of the range.
  @override
  final int high;

  /// The datatype of this range's ends.
  @override
  final DataType dataType;

  @override
  String toString() {
    return 'LiteralValue.range(low: $low, high: $high, dataType: $dataType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Range &&
            (identical(other.low, low) || other.low == low) &&
            (identical(other.high, high) || other.high == high) &&
            (identical(other.dataType, dataType) ||
                other.dataType == dataType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, low, high, dataType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_RangeCopyWith<_$LiteralValue_Range> get copyWith =>
      __$$LiteralValue_RangeCopyWithImpl<_$LiteralValue_Range>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return range(low, high, dataType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return range?.call(low, high, dataType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (range != null) {
      return range(low, high, dataType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return range(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return range?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (range != null) {
      return range(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Range implements LiteralValue {
  const factory LiteralValue_Range(
      {required final int low,
      required final int high,
      required final DataType dataType}) = _$LiteralValue_Range;

  /// The starting value of the range.
  int get low;

  /// The ending value of the range.
  int get high;

  /// The datatype of this range's ends.
  DataType get dataType;
  @JsonKey(ignore: true)
  _$$LiteralValue_RangeCopyWith<_$LiteralValue_Range> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_DateTimeCopyWith<$Res> {
  factory _$$LiteralValue_DateTimeCopyWith(_$LiteralValue_DateTime value,
          $Res Function(_$LiteralValue_DateTime) then) =
      __$$LiteralValue_DateTimeCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime field0, TimeUnit field1});
}

/// @nodoc
class __$$LiteralValue_DateTimeCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_DateTime>
    implements _$$LiteralValue_DateTimeCopyWith<$Res> {
  __$$LiteralValue_DateTimeCopyWithImpl(_$LiteralValue_DateTime _value,
      $Res Function(_$LiteralValue_DateTime) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$LiteralValue_DateTime(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DateTime,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
    ));
  }
}

/// @nodoc

class _$LiteralValue_DateTime implements LiteralValue_DateTime {
  const _$LiteralValue_DateTime(this.field0, this.field1);

  @override
  final DateTime field0;
  @override
  final TimeUnit field1;

  @override
  String toString() {
    return 'LiteralValue.dateTime(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_DateTime &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_DateTimeCopyWith<_$LiteralValue_DateTime> get copyWith =>
      __$$LiteralValue_DateTimeCopyWithImpl<_$LiteralValue_DateTime>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return dateTime(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return dateTime?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return dateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return dateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_DateTime implements LiteralValue {
  const factory LiteralValue_DateTime(
      final DateTime field0, final TimeUnit field1) = _$LiteralValue_DateTime;

  DateTime get field0;
  TimeUnit get field1;
  @JsonKey(ignore: true)
  _$$LiteralValue_DateTimeCopyWith<_$LiteralValue_DateTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_DurationCopyWith<$Res> {
  factory _$$LiteralValue_DurationCopyWith(_$LiteralValue_Duration value,
          $Res Function(_$LiteralValue_Duration) then) =
      __$$LiteralValue_DurationCopyWithImpl<$Res>;
  @useResult
  $Res call({Duration field0, TimeUnit field1});
}

/// @nodoc
class __$$LiteralValue_DurationCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Duration>
    implements _$$LiteralValue_DurationCopyWith<$Res> {
  __$$LiteralValue_DurationCopyWithImpl(_$LiteralValue_Duration _value,
      $Res Function(_$LiteralValue_Duration) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$LiteralValue_Duration(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Duration,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Duration implements LiteralValue_Duration {
  const _$LiteralValue_Duration(this.field0, this.field1);

  @override
  final Duration field0;
  @override
  final TimeUnit field1;

  @override
  String toString() {
    return 'LiteralValue.duration(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Duration &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_DurationCopyWith<_$LiteralValue_Duration> get copyWith =>
      __$$LiteralValue_DurationCopyWithImpl<_$LiteralValue_Duration>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(DateTime field0, TimeUnit field1) dateTime,
    required TResult Function(Duration field0, TimeUnit field1) duration,
  }) {
    return duration(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult? Function(Duration field0, TimeUnit field1)? duration,
  }) {
    return duration?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(DateTime field0, TimeUnit field1)? dateTime,
    TResult Function(Duration field0, TimeUnit field1)? duration,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
  }) {
    return duration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
  }) {
    return duration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Duration implements LiteralValue {
  const factory LiteralValue_Duration(
      final Duration field0, final TimeUnit field1) = _$LiteralValue_Duration;

  Duration get field0;
  TimeUnit get field1;
  @JsonKey(ignore: true)
  _$$LiteralValue_DurationCopyWith<_$LiteralValue_Duration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NullValues {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) allColumnsSingle,
    required TResult Function(List<String> field0) allColumns,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? allColumnsSingle,
    TResult? Function(List<String> field0)? allColumns,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? allColumnsSingle,
    TResult Function(List<String> field0)? allColumns,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullValues_AllColumnsSingle value)
        allColumnsSingle,
    required TResult Function(NullValues_AllColumns value) allColumns,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult? Function(NullValues_AllColumns value)? allColumns,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult Function(NullValues_AllColumns value)? allColumns,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NullValuesCopyWith<$Res> {
  factory $NullValuesCopyWith(
          NullValues value, $Res Function(NullValues) then) =
      _$NullValuesCopyWithImpl<$Res, NullValues>;
}

/// @nodoc
class _$NullValuesCopyWithImpl<$Res, $Val extends NullValues>
    implements $NullValuesCopyWith<$Res> {
  _$NullValuesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NullValues_AllColumnsSingleCopyWith<$Res> {
  factory _$$NullValues_AllColumnsSingleCopyWith(
          _$NullValues_AllColumnsSingle value,
          $Res Function(_$NullValues_AllColumnsSingle) then) =
      __$$NullValues_AllColumnsSingleCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$NullValues_AllColumnsSingleCopyWithImpl<$Res>
    extends _$NullValuesCopyWithImpl<$Res, _$NullValues_AllColumnsSingle>
    implements _$$NullValues_AllColumnsSingleCopyWith<$Res> {
  __$$NullValues_AllColumnsSingleCopyWithImpl(
      _$NullValues_AllColumnsSingle _value,
      $Res Function(_$NullValues_AllColumnsSingle) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$NullValues_AllColumnsSingle(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$NullValues_AllColumnsSingle implements NullValues_AllColumnsSingle {
  const _$NullValues_AllColumnsSingle(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'NullValues.allColumnsSingle(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NullValues_AllColumnsSingle &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NullValues_AllColumnsSingleCopyWith<_$NullValues_AllColumnsSingle>
      get copyWith => __$$NullValues_AllColumnsSingleCopyWithImpl<
          _$NullValues_AllColumnsSingle>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) allColumnsSingle,
    required TResult Function(List<String> field0) allColumns,
  }) {
    return allColumnsSingle(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? allColumnsSingle,
    TResult? Function(List<String> field0)? allColumns,
  }) {
    return allColumnsSingle?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? allColumnsSingle,
    TResult Function(List<String> field0)? allColumns,
    required TResult orElse(),
  }) {
    if (allColumnsSingle != null) {
      return allColumnsSingle(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullValues_AllColumnsSingle value)
        allColumnsSingle,
    required TResult Function(NullValues_AllColumns value) allColumns,
  }) {
    return allColumnsSingle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult? Function(NullValues_AllColumns value)? allColumns,
  }) {
    return allColumnsSingle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult Function(NullValues_AllColumns value)? allColumns,
    required TResult orElse(),
  }) {
    if (allColumnsSingle != null) {
      return allColumnsSingle(this);
    }
    return orElse();
  }
}

abstract class NullValues_AllColumnsSingle implements NullValues {
  const factory NullValues_AllColumnsSingle(final String field0) =
      _$NullValues_AllColumnsSingle;

  @override
  String get field0;
  @JsonKey(ignore: true)
  _$$NullValues_AllColumnsSingleCopyWith<_$NullValues_AllColumnsSingle>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NullValues_AllColumnsCopyWith<$Res> {
  factory _$$NullValues_AllColumnsCopyWith(_$NullValues_AllColumns value,
          $Res Function(_$NullValues_AllColumns) then) =
      __$$NullValues_AllColumnsCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> field0});
}

/// @nodoc
class __$$NullValues_AllColumnsCopyWithImpl<$Res>
    extends _$NullValuesCopyWithImpl<$Res, _$NullValues_AllColumns>
    implements _$$NullValues_AllColumnsCopyWith<$Res> {
  __$$NullValues_AllColumnsCopyWithImpl(_$NullValues_AllColumns _value,
      $Res Function(_$NullValues_AllColumns) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$NullValues_AllColumns(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$NullValues_AllColumns implements NullValues_AllColumns {
  const _$NullValues_AllColumns(final List<String> field0) : _field0 = field0;

  final List<String> _field0;
  @override
  List<String> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'NullValues.allColumns(field0: $field0)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NullValues_AllColumns &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NullValues_AllColumnsCopyWith<_$NullValues_AllColumns> get copyWith =>
      __$$NullValues_AllColumnsCopyWithImpl<_$NullValues_AllColumns>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) allColumnsSingle,
    required TResult Function(List<String> field0) allColumns,
  }) {
    return allColumns(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? allColumnsSingle,
    TResult? Function(List<String> field0)? allColumns,
  }) {
    return allColumns?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? allColumnsSingle,
    TResult Function(List<String> field0)? allColumns,
    required TResult orElse(),
  }) {
    if (allColumns != null) {
      return allColumns(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullValues_AllColumnsSingle value)
        allColumnsSingle,
    required TResult Function(NullValues_AllColumns value) allColumns,
  }) {
    return allColumns(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult? Function(NullValues_AllColumns value)? allColumns,
  }) {
    return allColumns?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult Function(NullValues_AllColumns value)? allColumns,
    required TResult orElse(),
  }) {
    if (allColumns != null) {
      return allColumns(this);
    }
    return orElse();
  }
}

abstract class NullValues_AllColumns implements NullValues {
  const factory NullValues_AllColumns(final List<String> field0) =
      _$NullValues_AllColumns;

  @override
  List<String> get field0;
  @JsonKey(ignore: true)
  _$$NullValues_AllColumnsCopyWith<_$NullValues_AllColumns> get copyWith =>
      throw _privateConstructorUsedError;
}
