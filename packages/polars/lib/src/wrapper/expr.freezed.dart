// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'expr.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$DataType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataTypeCopyWith<$Res> {
  factory $DataTypeCopyWith(DataType value, $Res Function(DataType) then) =
      _$DataTypeCopyWithImpl<$Res, DataType>;
}

/// @nodoc
class _$DataTypeCopyWithImpl<$Res, $Val extends DataType>
    implements $DataTypeCopyWith<$Res> {
  _$DataTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DataType_BooleanImplCopyWith<$Res> {
  factory _$$DataType_BooleanImplCopyWith(_$DataType_BooleanImpl value,
          $Res Function(_$DataType_BooleanImpl) then) =
      __$$DataType_BooleanImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_BooleanImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_BooleanImpl>
    implements _$$DataType_BooleanImplCopyWith<$Res> {
  __$$DataType_BooleanImplCopyWithImpl(_$DataType_BooleanImpl _value,
      $Res Function(_$DataType_BooleanImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_BooleanImpl implements DataType_Boolean {
  const _$DataType_BooleanImpl();

  @override
  String toString() {
    return 'DataType.boolean()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_BooleanImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return boolean();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return boolean?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class DataType_Boolean implements DataType {
  const factory DataType_Boolean() = _$DataType_BooleanImpl;
}

/// @nodoc
abstract class _$$DataType_UInt8ImplCopyWith<$Res> {
  factory _$$DataType_UInt8ImplCopyWith(_$DataType_UInt8Impl value,
          $Res Function(_$DataType_UInt8Impl) then) =
      __$$DataType_UInt8ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt8ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt8Impl>
    implements _$$DataType_UInt8ImplCopyWith<$Res> {
  __$$DataType_UInt8ImplCopyWithImpl(
      _$DataType_UInt8Impl _value, $Res Function(_$DataType_UInt8Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt8Impl implements DataType_UInt8 {
  const _$DataType_UInt8Impl();

  @override
  String toString() {
    return 'DataType.uInt8()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt8Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return uInt8();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return uInt8?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt8 implements DataType {
  const factory DataType_UInt8() = _$DataType_UInt8Impl;
}

/// @nodoc
abstract class _$$DataType_UInt16ImplCopyWith<$Res> {
  factory _$$DataType_UInt16ImplCopyWith(_$DataType_UInt16Impl value,
          $Res Function(_$DataType_UInt16Impl) then) =
      __$$DataType_UInt16ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt16ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt16Impl>
    implements _$$DataType_UInt16ImplCopyWith<$Res> {
  __$$DataType_UInt16ImplCopyWithImpl(
      _$DataType_UInt16Impl _value, $Res Function(_$DataType_UInt16Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt16Impl implements DataType_UInt16 {
  const _$DataType_UInt16Impl();

  @override
  String toString() {
    return 'DataType.uInt16()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt16Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return uInt16();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return uInt16?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt16 implements DataType {
  const factory DataType_UInt16() = _$DataType_UInt16Impl;
}

/// @nodoc
abstract class _$$DataType_UInt32ImplCopyWith<$Res> {
  factory _$$DataType_UInt32ImplCopyWith(_$DataType_UInt32Impl value,
          $Res Function(_$DataType_UInt32Impl) then) =
      __$$DataType_UInt32ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt32ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt32Impl>
    implements _$$DataType_UInt32ImplCopyWith<$Res> {
  __$$DataType_UInt32ImplCopyWithImpl(
      _$DataType_UInt32Impl _value, $Res Function(_$DataType_UInt32Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt32Impl implements DataType_UInt32 {
  const _$DataType_UInt32Impl();

  @override
  String toString() {
    return 'DataType.uInt32()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt32Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return uInt32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return uInt32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt32 implements DataType {
  const factory DataType_UInt32() = _$DataType_UInt32Impl;
}

/// @nodoc
abstract class _$$DataType_UInt64ImplCopyWith<$Res> {
  factory _$$DataType_UInt64ImplCopyWith(_$DataType_UInt64Impl value,
          $Res Function(_$DataType_UInt64Impl) then) =
      __$$DataType_UInt64ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt64ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt64Impl>
    implements _$$DataType_UInt64ImplCopyWith<$Res> {
  __$$DataType_UInt64ImplCopyWithImpl(
      _$DataType_UInt64Impl _value, $Res Function(_$DataType_UInt64Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt64Impl implements DataType_UInt64 {
  const _$DataType_UInt64Impl();

  @override
  String toString() {
    return 'DataType.uInt64()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt64Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return uInt64();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return uInt64?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt64 implements DataType {
  const factory DataType_UInt64() = _$DataType_UInt64Impl;
}

/// @nodoc
abstract class _$$DataType_Int8ImplCopyWith<$Res> {
  factory _$$DataType_Int8ImplCopyWith(
          _$DataType_Int8Impl value, $Res Function(_$DataType_Int8Impl) then) =
      __$$DataType_Int8ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int8ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int8Impl>
    implements _$$DataType_Int8ImplCopyWith<$Res> {
  __$$DataType_Int8ImplCopyWithImpl(
      _$DataType_Int8Impl _value, $Res Function(_$DataType_Int8Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int8Impl implements DataType_Int8 {
  const _$DataType_Int8Impl();

  @override
  String toString() {
    return 'DataType.int8()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int8Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return int8();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return int8?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8(this);
    }
    return orElse();
  }
}

abstract class DataType_Int8 implements DataType {
  const factory DataType_Int8() = _$DataType_Int8Impl;
}

/// @nodoc
abstract class _$$DataType_Int16ImplCopyWith<$Res> {
  factory _$$DataType_Int16ImplCopyWith(_$DataType_Int16Impl value,
          $Res Function(_$DataType_Int16Impl) then) =
      __$$DataType_Int16ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int16ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int16Impl>
    implements _$$DataType_Int16ImplCopyWith<$Res> {
  __$$DataType_Int16ImplCopyWithImpl(
      _$DataType_Int16Impl _value, $Res Function(_$DataType_Int16Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int16Impl implements DataType_Int16 {
  const _$DataType_Int16Impl();

  @override
  String toString() {
    return 'DataType.int16()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int16Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return int16();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return int16?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16(this);
    }
    return orElse();
  }
}

abstract class DataType_Int16 implements DataType {
  const factory DataType_Int16() = _$DataType_Int16Impl;
}

/// @nodoc
abstract class _$$DataType_Int32ImplCopyWith<$Res> {
  factory _$$DataType_Int32ImplCopyWith(_$DataType_Int32Impl value,
          $Res Function(_$DataType_Int32Impl) then) =
      __$$DataType_Int32ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int32ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int32Impl>
    implements _$$DataType_Int32ImplCopyWith<$Res> {
  __$$DataType_Int32ImplCopyWithImpl(
      _$DataType_Int32Impl _value, $Res Function(_$DataType_Int32Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int32Impl implements DataType_Int32 {
  const _$DataType_Int32Impl();

  @override
  String toString() {
    return 'DataType.int32()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int32Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return int32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return int32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(this);
    }
    return orElse();
  }
}

abstract class DataType_Int32 implements DataType {
  const factory DataType_Int32() = _$DataType_Int32Impl;
}

/// @nodoc
abstract class _$$DataType_Int64ImplCopyWith<$Res> {
  factory _$$DataType_Int64ImplCopyWith(_$DataType_Int64Impl value,
          $Res Function(_$DataType_Int64Impl) then) =
      __$$DataType_Int64ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int64ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int64Impl>
    implements _$$DataType_Int64ImplCopyWith<$Res> {
  __$$DataType_Int64ImplCopyWithImpl(
      _$DataType_Int64Impl _value, $Res Function(_$DataType_Int64Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int64Impl implements DataType_Int64 {
  const _$DataType_Int64Impl();

  @override
  String toString() {
    return 'DataType.int64()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int64Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return int64();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return int64?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(this);
    }
    return orElse();
  }
}

abstract class DataType_Int64 implements DataType {
  const factory DataType_Int64() = _$DataType_Int64Impl;
}

/// @nodoc
abstract class _$$DataType_Float32ImplCopyWith<$Res> {
  factory _$$DataType_Float32ImplCopyWith(_$DataType_Float32Impl value,
          $Res Function(_$DataType_Float32Impl) then) =
      __$$DataType_Float32ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Float32ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Float32Impl>
    implements _$$DataType_Float32ImplCopyWith<$Res> {
  __$$DataType_Float32ImplCopyWithImpl(_$DataType_Float32Impl _value,
      $Res Function(_$DataType_Float32Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Float32Impl implements DataType_Float32 {
  const _$DataType_Float32Impl();

  @override
  String toString() {
    return 'DataType.float32()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Float32Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return float32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return float32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return float32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return float32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32(this);
    }
    return orElse();
  }
}

abstract class DataType_Float32 implements DataType {
  const factory DataType_Float32() = _$DataType_Float32Impl;
}

/// @nodoc
abstract class _$$DataType_Float64ImplCopyWith<$Res> {
  factory _$$DataType_Float64ImplCopyWith(_$DataType_Float64Impl value,
          $Res Function(_$DataType_Float64Impl) then) =
      __$$DataType_Float64ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Float64ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Float64Impl>
    implements _$$DataType_Float64ImplCopyWith<$Res> {
  __$$DataType_Float64ImplCopyWithImpl(_$DataType_Float64Impl _value,
      $Res Function(_$DataType_Float64Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Float64Impl implements DataType_Float64 {
  const _$DataType_Float64Impl();

  @override
  String toString() {
    return 'DataType.float64()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Float64Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return float64();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return float64?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return float64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return float64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(this);
    }
    return orElse();
  }
}

abstract class DataType_Float64 implements DataType {
  const factory DataType_Float64() = _$DataType_Float64Impl;
}

/// @nodoc
abstract class _$$DataType_Utf8ImplCopyWith<$Res> {
  factory _$$DataType_Utf8ImplCopyWith(
          _$DataType_Utf8Impl value, $Res Function(_$DataType_Utf8Impl) then) =
      __$$DataType_Utf8ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Utf8ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Utf8Impl>
    implements _$$DataType_Utf8ImplCopyWith<$Res> {
  __$$DataType_Utf8ImplCopyWithImpl(
      _$DataType_Utf8Impl _value, $Res Function(_$DataType_Utf8Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Utf8Impl implements DataType_Utf8 {
  const _$DataType_Utf8Impl();

  @override
  String toString() {
    return 'DataType.utf8()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Utf8Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return utf8();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return utf8?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return utf8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return utf8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8(this);
    }
    return orElse();
  }
}

abstract class DataType_Utf8 implements DataType {
  const factory DataType_Utf8() = _$DataType_Utf8Impl;
}

/// @nodoc
abstract class _$$DataType_BinaryImplCopyWith<$Res> {
  factory _$$DataType_BinaryImplCopyWith(_$DataType_BinaryImpl value,
          $Res Function(_$DataType_BinaryImpl) then) =
      __$$DataType_BinaryImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_BinaryImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_BinaryImpl>
    implements _$$DataType_BinaryImplCopyWith<$Res> {
  __$$DataType_BinaryImplCopyWithImpl(
      _$DataType_BinaryImpl _value, $Res Function(_$DataType_BinaryImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_BinaryImpl implements DataType_Binary {
  const _$DataType_BinaryImpl();

  @override
  String toString() {
    return 'DataType.binary()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_BinaryImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return binary();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return binary?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return binary(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return binary?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(this);
    }
    return orElse();
  }
}

abstract class DataType_Binary implements DataType {
  const factory DataType_Binary() = _$DataType_BinaryImpl;
}

/// @nodoc
abstract class _$$DataType_DateImplCopyWith<$Res> {
  factory _$$DataType_DateImplCopyWith(
          _$DataType_DateImpl value, $Res Function(_$DataType_DateImpl) then) =
      __$$DataType_DateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_DateImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_DateImpl>
    implements _$$DataType_DateImplCopyWith<$Res> {
  __$$DataType_DateImplCopyWithImpl(
      _$DataType_DateImpl _value, $Res Function(_$DataType_DateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_DateImpl implements DataType_Date {
  const _$DataType_DateImpl();

  @override
  String toString() {
    return 'DataType.date()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_DateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return date();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return date?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return date(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return date?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date(this);
    }
    return orElse();
  }
}

abstract class DataType_Date implements DataType {
  const factory DataType_Date() = _$DataType_DateImpl;
}

/// @nodoc
abstract class _$$DataType_DatetimeImplCopyWith<$Res> {
  factory _$$DataType_DatetimeImplCopyWith(_$DataType_DatetimeImpl value,
          $Res Function(_$DataType_DatetimeImpl) then) =
      __$$DataType_DatetimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TimeUnit field0, String? field1});
}

/// @nodoc
class __$$DataType_DatetimeImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_DatetimeImpl>
    implements _$$DataType_DatetimeImplCopyWith<$Res> {
  __$$DataType_DatetimeImplCopyWithImpl(_$DataType_DatetimeImpl _value,
      $Res Function(_$DataType_DatetimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = freezed,
  }) {
    return _then(_$DataType_DatetimeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
      freezed == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$DataType_DatetimeImpl implements DataType_Datetime {
  const _$DataType_DatetimeImpl(this.field0, [this.field1]);

  @override
  final TimeUnit field0;
  @override
  final String? field1;

  @override
  String toString() {
    return 'DataType.datetime(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_DatetimeImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_DatetimeImplCopyWith<_$DataType_DatetimeImpl> get copyWith =>
      __$$DataType_DatetimeImplCopyWithImpl<_$DataType_DatetimeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return datetime(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return datetime?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (datetime != null) {
      return datetime(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return datetime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return datetime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (datetime != null) {
      return datetime(this);
    }
    return orElse();
  }
}

abstract class DataType_Datetime implements DataType {
  const factory DataType_Datetime(final TimeUnit field0,
      [final String? field1]) = _$DataType_DatetimeImpl;

  TimeUnit get field0;
  String? get field1;
  @JsonKey(ignore: true)
  _$$DataType_DatetimeImplCopyWith<_$DataType_DatetimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_DurationImplCopyWith<$Res> {
  factory _$$DataType_DurationImplCopyWith(_$DataType_DurationImpl value,
          $Res Function(_$DataType_DurationImpl) then) =
      __$$DataType_DurationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TimeUnit field0});
}

/// @nodoc
class __$$DataType_DurationImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_DurationImpl>
    implements _$$DataType_DurationImplCopyWith<$Res> {
  __$$DataType_DurationImplCopyWithImpl(_$DataType_DurationImpl _value,
      $Res Function(_$DataType_DurationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DataType_DurationImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
    ));
  }
}

/// @nodoc

class _$DataType_DurationImpl implements DataType_Duration {
  const _$DataType_DurationImpl(this.field0);

  @override
  final TimeUnit field0;

  @override
  String toString() {
    return 'DataType.duration(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_DurationImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_DurationImplCopyWith<_$DataType_DurationImpl> get copyWith =>
      __$$DataType_DurationImplCopyWithImpl<_$DataType_DurationImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return duration(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return duration?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return duration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return duration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(this);
    }
    return orElse();
  }
}

abstract class DataType_Duration implements DataType {
  const factory DataType_Duration(final TimeUnit field0) =
      _$DataType_DurationImpl;

  TimeUnit get field0;
  @JsonKey(ignore: true)
  _$$DataType_DurationImplCopyWith<_$DataType_DurationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_TimeImplCopyWith<$Res> {
  factory _$$DataType_TimeImplCopyWith(
          _$DataType_TimeImpl value, $Res Function(_$DataType_TimeImpl) then) =
      __$$DataType_TimeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_TimeImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_TimeImpl>
    implements _$$DataType_TimeImplCopyWith<$Res> {
  __$$DataType_TimeImplCopyWithImpl(
      _$DataType_TimeImpl _value, $Res Function(_$DataType_TimeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_TimeImpl implements DataType_Time {
  const _$DataType_TimeImpl();

  @override
  String toString() {
    return 'DataType.time()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_TimeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return time();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return time?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return time(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return time?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time(this);
    }
    return orElse();
  }
}

abstract class DataType_Time implements DataType {
  const factory DataType_Time() = _$DataType_TimeImpl;
}

/// @nodoc
abstract class _$$DataType_ListImplCopyWith<$Res> {
  factory _$$DataType_ListImplCopyWith(
          _$DataType_ListImpl value, $Res Function(_$DataType_ListImpl) then) =
      __$$DataType_ListImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DataType field0});

  $DataTypeCopyWith<$Res> get field0;
}

/// @nodoc
class __$$DataType_ListImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_ListImpl>
    implements _$$DataType_ListImplCopyWith<$Res> {
  __$$DataType_ListImplCopyWithImpl(
      _$DataType_ListImpl _value, $Res Function(_$DataType_ListImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DataType_ListImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get field0 {
    return $DataTypeCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$DataType_ListImpl implements DataType_List {
  const _$DataType_ListImpl(this.field0);

  @override
  final DataType field0;

  @override
  String toString() {
    return 'DataType.list(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_ListImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_ListImplCopyWith<_$DataType_ListImpl> get copyWith =>
      __$$DataType_ListImplCopyWithImpl<_$DataType_ListImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return list(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return list?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return list(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return list?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(this);
    }
    return orElse();
  }
}

abstract class DataType_List implements DataType {
  const factory DataType_List(final DataType field0) = _$DataType_ListImpl;

  DataType get field0;
  @JsonKey(ignore: true)
  _$$DataType_ListImplCopyWith<_$DataType_ListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_StructImplCopyWith<$Res> {
  factory _$$DataType_StructImplCopyWith(_$DataType_StructImpl value,
          $Res Function(_$DataType_StructImpl) then) =
      __$$DataType_StructImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Field> field0});
}

/// @nodoc
class __$$DataType_StructImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_StructImpl>
    implements _$$DataType_StructImplCopyWith<$Res> {
  __$$DataType_StructImplCopyWithImpl(
      _$DataType_StructImpl _value, $Res Function(_$DataType_StructImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DataType_StructImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<Field>,
    ));
  }
}

/// @nodoc

class _$DataType_StructImpl implements DataType_Struct {
  const _$DataType_StructImpl(final List<Field> field0) : _field0 = field0;

  final List<Field> _field0;
  @override
  List<Field> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'DataType.struct(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_StructImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_StructImplCopyWith<_$DataType_StructImpl> get copyWith =>
      __$$DataType_StructImplCopyWithImpl<_$DataType_StructImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return struct(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return struct?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (struct != null) {
      return struct(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return struct(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return struct?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (struct != null) {
      return struct(this);
    }
    return orElse();
  }
}

abstract class DataType_Struct implements DataType {
  const factory DataType_Struct(final List<Field> field0) =
      _$DataType_StructImpl;

  List<Field> get field0;
  @JsonKey(ignore: true)
  _$$DataType_StructImplCopyWith<_$DataType_StructImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_NullImplCopyWith<$Res> {
  factory _$$DataType_NullImplCopyWith(
          _$DataType_NullImpl value, $Res Function(_$DataType_NullImpl) then) =
      __$$DataType_NullImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_NullImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_NullImpl>
    implements _$$DataType_NullImplCopyWith<$Res> {
  __$$DataType_NullImplCopyWithImpl(
      _$DataType_NullImpl _value, $Res Function(_$DataType_NullImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_NullImpl implements DataType_Null {
  const _$DataType_NullImpl();

  @override
  String toString() {
    return 'DataType.Null()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_NullImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return Null();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return Null?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (Null != null) {
      return Null();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return Null(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return Null?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (Null != null) {
      return Null(this);
    }
    return orElse();
  }
}

abstract class DataType_Null implements DataType {
  const factory DataType_Null() = _$DataType_NullImpl;
}

/// @nodoc
abstract class _$$DataType_UnknownImplCopyWith<$Res> {
  factory _$$DataType_UnknownImplCopyWith(_$DataType_UnknownImpl value,
          $Res Function(_$DataType_UnknownImpl) then) =
      __$$DataType_UnknownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UnknownImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UnknownImpl>
    implements _$$DataType_UnknownImplCopyWith<$Res> {
  __$$DataType_UnknownImplCopyWithImpl(_$DataType_UnknownImpl _value,
      $Res Function(_$DataType_UnknownImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UnknownImpl implements DataType_Unknown {
  const _$DataType_UnknownImpl();

  @override
  String toString() {
    return 'DataType.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UnknownImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() Null,
    required TResult Function() unknown,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? Null,
    TResult? Function()? unknown,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? Null,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class DataType_Unknown implements DataType {
  const factory DataType_Unknown() = _$DataType_UnknownImpl;
}

/// @nodoc
mixin _$LiteralValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LiteralValueCopyWith<$Res> {
  factory $LiteralValueCopyWith(
          LiteralValue value, $Res Function(LiteralValue) then) =
      _$LiteralValueCopyWithImpl<$Res, LiteralValue>;
}

/// @nodoc
class _$LiteralValueCopyWithImpl<$Res, $Val extends LiteralValue>
    implements $LiteralValueCopyWith<$Res> {
  _$LiteralValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LiteralValue_NullImplCopyWith<$Res> {
  factory _$$LiteralValue_NullImplCopyWith(_$LiteralValue_NullImpl value,
          $Res Function(_$LiteralValue_NullImpl) then) =
      __$$LiteralValue_NullImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LiteralValue_NullImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_NullImpl>
    implements _$$LiteralValue_NullImplCopyWith<$Res> {
  __$$LiteralValue_NullImplCopyWithImpl(_$LiteralValue_NullImpl _value,
      $Res Function(_$LiteralValue_NullImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LiteralValue_NullImpl implements LiteralValue_Null {
  const _$LiteralValue_NullImpl();

  @override
  String toString() {
    return 'LiteralValue.Null()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LiteralValue_NullImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return Null();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return Null?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (Null != null) {
      return Null();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return Null(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return Null?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (Null != null) {
      return Null(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Null implements LiteralValue {
  const factory LiteralValue_Null() = _$LiteralValue_NullImpl;
}

/// @nodoc
abstract class _$$LiteralValue_BooleanImplCopyWith<$Res> {
  factory _$$LiteralValue_BooleanImplCopyWith(_$LiteralValue_BooleanImpl value,
          $Res Function(_$LiteralValue_BooleanImpl) then) =
      __$$LiteralValue_BooleanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool field0});
}

/// @nodoc
class __$$LiteralValue_BooleanImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_BooleanImpl>
    implements _$$LiteralValue_BooleanImplCopyWith<$Res> {
  __$$LiteralValue_BooleanImplCopyWithImpl(_$LiteralValue_BooleanImpl _value,
      $Res Function(_$LiteralValue_BooleanImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_BooleanImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$LiteralValue_BooleanImpl implements LiteralValue_Boolean {
  const _$LiteralValue_BooleanImpl(this.field0);

  @override
  final bool field0;

  @override
  String toString() {
    return 'LiteralValue.boolean(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_BooleanImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_BooleanImplCopyWith<_$LiteralValue_BooleanImpl>
      get copyWith =>
          __$$LiteralValue_BooleanImplCopyWithImpl<_$LiteralValue_BooleanImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return boolean(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return boolean?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Boolean implements LiteralValue {
  const factory LiteralValue_Boolean(final bool field0) =
      _$LiteralValue_BooleanImpl;

  bool get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_BooleanImplCopyWith<_$LiteralValue_BooleanImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Utf8ImplCopyWith<$Res> {
  factory _$$LiteralValue_Utf8ImplCopyWith(_$LiteralValue_Utf8Impl value,
          $Res Function(_$LiteralValue_Utf8Impl) then) =
      __$$LiteralValue_Utf8ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$LiteralValue_Utf8ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Utf8Impl>
    implements _$$LiteralValue_Utf8ImplCopyWith<$Res> {
  __$$LiteralValue_Utf8ImplCopyWithImpl(_$LiteralValue_Utf8Impl _value,
      $Res Function(_$LiteralValue_Utf8Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Utf8Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Utf8Impl implements LiteralValue_Utf8 {
  const _$LiteralValue_Utf8Impl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'LiteralValue.utf8(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Utf8Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Utf8ImplCopyWith<_$LiteralValue_Utf8Impl> get copyWith =>
      __$$LiteralValue_Utf8ImplCopyWithImpl<_$LiteralValue_Utf8Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return utf8(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return utf8?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return utf8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return utf8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Utf8 implements LiteralValue {
  const factory LiteralValue_Utf8(final String field0) =
      _$LiteralValue_Utf8Impl;

  String get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Utf8ImplCopyWith<_$LiteralValue_Utf8Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_BinaryImplCopyWith<$Res> {
  factory _$$LiteralValue_BinaryImplCopyWith(_$LiteralValue_BinaryImpl value,
          $Res Function(_$LiteralValue_BinaryImpl) then) =
      __$$LiteralValue_BinaryImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$LiteralValue_BinaryImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_BinaryImpl>
    implements _$$LiteralValue_BinaryImplCopyWith<$Res> {
  __$$LiteralValue_BinaryImplCopyWithImpl(_$LiteralValue_BinaryImpl _value,
      $Res Function(_$LiteralValue_BinaryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_BinaryImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$LiteralValue_BinaryImpl implements LiteralValue_Binary {
  const _$LiteralValue_BinaryImpl(this.field0);

  @override
  final Uint8List field0;

  @override
  String toString() {
    return 'LiteralValue.binary(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_BinaryImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_BinaryImplCopyWith<_$LiteralValue_BinaryImpl> get copyWith =>
      __$$LiteralValue_BinaryImplCopyWithImpl<_$LiteralValue_BinaryImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return binary(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return binary?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return binary(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return binary?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Binary implements LiteralValue {
  const factory LiteralValue_Binary(final Uint8List field0) =
      _$LiteralValue_BinaryImpl;

  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_BinaryImplCopyWith<_$LiteralValue_BinaryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt32ImplCopyWith<$Res> {
  factory _$$LiteralValue_UInt32ImplCopyWith(_$LiteralValue_UInt32Impl value,
          $Res Function(_$LiteralValue_UInt32Impl) then) =
      __$$LiteralValue_UInt32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt32ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt32Impl>
    implements _$$LiteralValue_UInt32ImplCopyWith<$Res> {
  __$$LiteralValue_UInt32ImplCopyWithImpl(_$LiteralValue_UInt32Impl _value,
      $Res Function(_$LiteralValue_UInt32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt32Impl implements LiteralValue_UInt32 {
  const _$LiteralValue_UInt32Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt32ImplCopyWith<_$LiteralValue_UInt32Impl> get copyWith =>
      __$$LiteralValue_UInt32ImplCopyWithImpl<_$LiteralValue_UInt32Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return uInt32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return uInt32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return uInt32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return uInt32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt32 implements LiteralValue {
  const factory LiteralValue_UInt32(final int field0) =
      _$LiteralValue_UInt32Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt32ImplCopyWith<_$LiteralValue_UInt32Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt64ImplCopyWith<$Res> {
  factory _$$LiteralValue_UInt64ImplCopyWith(_$LiteralValue_UInt64Impl value,
          $Res Function(_$LiteralValue_UInt64Impl) then) =
      __$$LiteralValue_UInt64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt64ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt64Impl>
    implements _$$LiteralValue_UInt64ImplCopyWith<$Res> {
  __$$LiteralValue_UInt64ImplCopyWithImpl(_$LiteralValue_UInt64Impl _value,
      $Res Function(_$LiteralValue_UInt64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt64Impl implements LiteralValue_UInt64 {
  const _$LiteralValue_UInt64Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt64ImplCopyWith<_$LiteralValue_UInt64Impl> get copyWith =>
      __$$LiteralValue_UInt64ImplCopyWithImpl<_$LiteralValue_UInt64Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return uInt64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return uInt64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return uInt64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return uInt64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt64 implements LiteralValue {
  const factory LiteralValue_UInt64(final int field0) =
      _$LiteralValue_UInt64Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt64ImplCopyWith<_$LiteralValue_UInt64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int32ImplCopyWith<$Res> {
  factory _$$LiteralValue_Int32ImplCopyWith(_$LiteralValue_Int32Impl value,
          $Res Function(_$LiteralValue_Int32Impl) then) =
      __$$LiteralValue_Int32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int32ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int32Impl>
    implements _$$LiteralValue_Int32ImplCopyWith<$Res> {
  __$$LiteralValue_Int32ImplCopyWithImpl(_$LiteralValue_Int32Impl _value,
      $Res Function(_$LiteralValue_Int32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int32Impl implements LiteralValue_Int32 {
  const _$LiteralValue_Int32Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int32ImplCopyWith<_$LiteralValue_Int32Impl> get copyWith =>
      __$$LiteralValue_Int32ImplCopyWithImpl<_$LiteralValue_Int32Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return int32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return int32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return int32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return int32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int32 implements LiteralValue {
  const factory LiteralValue_Int32(final int field0) = _$LiteralValue_Int32Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int32ImplCopyWith<_$LiteralValue_Int32Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int64ImplCopyWith<$Res> {
  factory _$$LiteralValue_Int64ImplCopyWith(_$LiteralValue_Int64Impl value,
          $Res Function(_$LiteralValue_Int64Impl) then) =
      __$$LiteralValue_Int64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int64ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int64Impl>
    implements _$$LiteralValue_Int64ImplCopyWith<$Res> {
  __$$LiteralValue_Int64ImplCopyWithImpl(_$LiteralValue_Int64Impl _value,
      $Res Function(_$LiteralValue_Int64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int64Impl implements LiteralValue_Int64 {
  const _$LiteralValue_Int64Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int64ImplCopyWith<_$LiteralValue_Int64Impl> get copyWith =>
      __$$LiteralValue_Int64ImplCopyWithImpl<_$LiteralValue_Int64Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return int64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return int64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return int64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return int64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int64 implements LiteralValue {
  const factory LiteralValue_Int64(final int field0) = _$LiteralValue_Int64Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int64ImplCopyWith<_$LiteralValue_Int64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Float32ImplCopyWith<$Res> {
  factory _$$LiteralValue_Float32ImplCopyWith(_$LiteralValue_Float32Impl value,
          $Res Function(_$LiteralValue_Float32Impl) then) =
      __$$LiteralValue_Float32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$LiteralValue_Float32ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Float32Impl>
    implements _$$LiteralValue_Float32ImplCopyWith<$Res> {
  __$$LiteralValue_Float32ImplCopyWithImpl(_$LiteralValue_Float32Impl _value,
      $Res Function(_$LiteralValue_Float32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Float32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Float32Impl implements LiteralValue_Float32 {
  const _$LiteralValue_Float32Impl(this.field0);

  @override
  final double field0;

  @override
  String toString() {
    return 'LiteralValue.float32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Float32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Float32ImplCopyWith<_$LiteralValue_Float32Impl>
      get copyWith =>
          __$$LiteralValue_Float32ImplCopyWithImpl<_$LiteralValue_Float32Impl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return float32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return float32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return float32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return float32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Float32 implements LiteralValue {
  const factory LiteralValue_Float32(final double field0) =
      _$LiteralValue_Float32Impl;

  double get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Float32ImplCopyWith<_$LiteralValue_Float32Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Float64ImplCopyWith<$Res> {
  factory _$$LiteralValue_Float64ImplCopyWith(_$LiteralValue_Float64Impl value,
          $Res Function(_$LiteralValue_Float64Impl) then) =
      __$$LiteralValue_Float64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$LiteralValue_Float64ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Float64Impl>
    implements _$$LiteralValue_Float64ImplCopyWith<$Res> {
  __$$LiteralValue_Float64ImplCopyWithImpl(_$LiteralValue_Float64Impl _value,
      $Res Function(_$LiteralValue_Float64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Float64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Float64Impl implements LiteralValue_Float64 {
  const _$LiteralValue_Float64Impl(this.field0);

  @override
  final double field0;

  @override
  String toString() {
    return 'LiteralValue.float64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Float64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Float64ImplCopyWith<_$LiteralValue_Float64Impl>
      get copyWith =>
          __$$LiteralValue_Float64ImplCopyWithImpl<_$LiteralValue_Float64Impl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return float64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return float64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return float64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return float64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Float64 implements LiteralValue {
  const factory LiteralValue_Float64(final double field0) =
      _$LiteralValue_Float64Impl;

  double get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Float64ImplCopyWith<_$LiteralValue_Float64Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_RangeImplCopyWith<$Res> {
  factory _$$LiteralValue_RangeImplCopyWith(_$LiteralValue_RangeImpl value,
          $Res Function(_$LiteralValue_RangeImpl) then) =
      __$$LiteralValue_RangeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int low, int high, DataType dataType});

  $DataTypeCopyWith<$Res> get dataType;
}

/// @nodoc
class __$$LiteralValue_RangeImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_RangeImpl>
    implements _$$LiteralValue_RangeImplCopyWith<$Res> {
  __$$LiteralValue_RangeImplCopyWithImpl(_$LiteralValue_RangeImpl _value,
      $Res Function(_$LiteralValue_RangeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? low = null,
    Object? high = null,
    Object? dataType = null,
  }) {
    return _then(_$LiteralValue_RangeImpl(
      low: null == low
          ? _value.low
          : low // ignore: cast_nullable_to_non_nullable
              as int,
      high: null == high
          ? _value.high
          : high // ignore: cast_nullable_to_non_nullable
              as int,
      dataType: null == dataType
          ? _value.dataType
          : dataType // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get dataType {
    return $DataTypeCopyWith<$Res>(_value.dataType, (value) {
      return _then(_value.copyWith(dataType: value));
    });
  }
}

/// @nodoc

class _$LiteralValue_RangeImpl implements LiteralValue_Range {
  const _$LiteralValue_RangeImpl(
      {required this.low, required this.high, required this.dataType});

  /// The starting value of the range.
  @override
  final int low;

  /// The ending value of the range.
  @override
  final int high;

  /// The datatype of this range's ends.
  @override
  final DataType dataType;

  @override
  String toString() {
    return 'LiteralValue.range(low: $low, high: $high, dataType: $dataType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_RangeImpl &&
            (identical(other.low, low) || other.low == low) &&
            (identical(other.high, high) || other.high == high) &&
            (identical(other.dataType, dataType) ||
                other.dataType == dataType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, low, high, dataType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_RangeImplCopyWith<_$LiteralValue_RangeImpl> get copyWith =>
      __$$LiteralValue_RangeImplCopyWithImpl<_$LiteralValue_RangeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return range(low, high, dataType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return range?.call(low, high, dataType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (range != null) {
      return range(low, high, dataType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return range(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return range?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (range != null) {
      return range(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Range implements LiteralValue {
  const factory LiteralValue_Range(
      {required final int low,
      required final int high,
      required final DataType dataType}) = _$LiteralValue_RangeImpl;

  /// The starting value of the range.
  int get low;

  /// The ending value of the range.
  int get high;

  /// The datatype of this range's ends.
  DataType get dataType;
  @JsonKey(ignore: true)
  _$$LiteralValue_RangeImplCopyWith<_$LiteralValue_RangeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_DateTimeImplCopyWith<$Res> {
  factory _$$LiteralValue_DateTimeImplCopyWith(
          _$LiteralValue_DateTimeImpl value,
          $Res Function(_$LiteralValue_DateTimeImpl) then) =
      __$$LiteralValue_DateTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0, TimeUnit field1, String? field2});
}

/// @nodoc
class __$$LiteralValue_DateTimeImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_DateTimeImpl>
    implements _$$LiteralValue_DateTimeImplCopyWith<$Res> {
  __$$LiteralValue_DateTimeImplCopyWithImpl(_$LiteralValue_DateTimeImpl _value,
      $Res Function(_$LiteralValue_DateTimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
    Object? field2 = freezed,
  }) {
    return _then(_$LiteralValue_DateTimeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
      freezed == field2
          ? _value.field2
          : field2 // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$LiteralValue_DateTimeImpl implements LiteralValue_DateTime {
  const _$LiteralValue_DateTimeImpl(this.field0, this.field1, [this.field2]);

  @override
  final int field0;
  @override
  final TimeUnit field1;
  @override
  final String? field2;

  @override
  String toString() {
    return 'LiteralValue.dateTime(field0: $field0, field1: $field1, field2: $field2)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_DateTimeImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1) &&
            (identical(other.field2, field2) || other.field2 == field2));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1, field2);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_DateTimeImplCopyWith<_$LiteralValue_DateTimeImpl>
      get copyWith => __$$LiteralValue_DateTimeImplCopyWithImpl<
          _$LiteralValue_DateTimeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return dateTime(field0, field1, field2);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return dateTime?.call(field0, field1, field2);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(field0, field1, field2);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return dateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return dateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_DateTime implements LiteralValue {
  const factory LiteralValue_DateTime(final int field0, final TimeUnit field1,
      [final String? field2]) = _$LiteralValue_DateTimeImpl;

  int get field0;
  TimeUnit get field1;
  String? get field2;
  @JsonKey(ignore: true)
  _$$LiteralValue_DateTimeImplCopyWith<_$LiteralValue_DateTimeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_DurationImplCopyWith<$Res> {
  factory _$$LiteralValue_DurationImplCopyWith(
          _$LiteralValue_DurationImpl value,
          $Res Function(_$LiteralValue_DurationImpl) then) =
      __$$LiteralValue_DurationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0, TimeUnit field1});
}

/// @nodoc
class __$$LiteralValue_DurationImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_DurationImpl>
    implements _$$LiteralValue_DurationImplCopyWith<$Res> {
  __$$LiteralValue_DurationImplCopyWithImpl(_$LiteralValue_DurationImpl _value,
      $Res Function(_$LiteralValue_DurationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$LiteralValue_DurationImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
    ));
  }
}

/// @nodoc

class _$LiteralValue_DurationImpl implements LiteralValue_Duration {
  const _$LiteralValue_DurationImpl(this.field0, this.field1);

  @override
  final int field0;
  @override
  final TimeUnit field1;

  @override
  String toString() {
    return 'LiteralValue.duration(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_DurationImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_DurationImplCopyWith<_$LiteralValue_DurationImpl>
      get copyWith => __$$LiteralValue_DurationImplCopyWithImpl<
          _$LiteralValue_DurationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return duration(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return duration?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return duration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return duration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Duration implements LiteralValue {
  const factory LiteralValue_Duration(final int field0, final TimeUnit field1) =
      _$LiteralValue_DurationImpl;

  int get field0;
  TimeUnit get field1;
  @JsonKey(ignore: true)
  _$$LiteralValue_DurationImplCopyWith<_$LiteralValue_DurationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_DateImplCopyWith<$Res> {
  factory _$$LiteralValue_DateImplCopyWith(_$LiteralValue_DateImpl value,
          $Res Function(_$LiteralValue_DateImpl) then) =
      __$$LiteralValue_DateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_DateImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_DateImpl>
    implements _$$LiteralValue_DateImplCopyWith<$Res> {
  __$$LiteralValue_DateImplCopyWithImpl(_$LiteralValue_DateImpl _value,
      $Res Function(_$LiteralValue_DateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_DateImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_DateImpl implements LiteralValue_Date {
  const _$LiteralValue_DateImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.date(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_DateImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_DateImplCopyWith<_$LiteralValue_DateImpl> get copyWith =>
      __$$LiteralValue_DateImplCopyWithImpl<_$LiteralValue_DateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return date(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return date?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return date(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return date?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Date implements LiteralValue {
  const factory LiteralValue_Date(final int field0) = _$LiteralValue_DateImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_DateImplCopyWith<_$LiteralValue_DateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_TimeImplCopyWith<$Res> {
  factory _$$LiteralValue_TimeImplCopyWith(_$LiteralValue_TimeImpl value,
          $Res Function(_$LiteralValue_TimeImpl) then) =
      __$$LiteralValue_TimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_TimeImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_TimeImpl>
    implements _$$LiteralValue_TimeImplCopyWith<$Res> {
  __$$LiteralValue_TimeImplCopyWithImpl(_$LiteralValue_TimeImpl _value,
      $Res Function(_$LiteralValue_TimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_TimeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_TimeImpl implements LiteralValue_Time {
  const _$LiteralValue_TimeImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.time(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_TimeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_TimeImplCopyWith<_$LiteralValue_TimeImpl> get copyWith =>
      __$$LiteralValue_TimeImplCopyWithImpl<_$LiteralValue_TimeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return time(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return time?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return time(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return time?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Time implements LiteralValue {
  const factory LiteralValue_Time(final int field0) = _$LiteralValue_TimeImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_TimeImplCopyWith<_$LiteralValue_TimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
