// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'wrapper.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AggExpr {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AggExprCopyWith<$Res> {
  factory $AggExprCopyWith(AggExpr value, $Res Function(AggExpr) then) =
      _$AggExprCopyWithImpl<$Res, AggExpr>;
}

/// @nodoc
class _$AggExprCopyWithImpl<$Res, $Val extends AggExpr>
    implements $AggExprCopyWith<$Res> {
  _$AggExprCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AggExpr_MinImplCopyWith<$Res> {
  factory _$$AggExpr_MinImplCopyWith(
          _$AggExpr_MinImpl value, $Res Function(_$AggExpr_MinImpl) then) =
      __$$AggExpr_MinImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr input, bool propagateNans});

  $ExprCopyWith<$Res> get input;
}

/// @nodoc
class __$$AggExpr_MinImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_MinImpl>
    implements _$$AggExpr_MinImplCopyWith<$Res> {
  __$$AggExpr_MinImplCopyWithImpl(
      _$AggExpr_MinImpl _value, $Res Function(_$AggExpr_MinImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? propagateNans = null,
  }) {
    return _then(_$AggExpr_MinImpl(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as Expr,
      propagateNans: null == propagateNans
          ? _value.propagateNans
          : propagateNans // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get input {
    return $ExprCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value));
    });
  }
}

/// @nodoc

class _$AggExpr_MinImpl implements AggExpr_Min {
  const _$AggExpr_MinImpl({required this.input, required this.propagateNans});

  @override
  final Expr input;
  @override
  final bool propagateNans;

  @override
  String toString() {
    return 'AggExpr.min(input: $input, propagateNans: $propagateNans)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_MinImpl &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.propagateNans, propagateNans) ||
                other.propagateNans == propagateNans));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input, propagateNans);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_MinImplCopyWith<_$AggExpr_MinImpl> get copyWith =>
      __$$AggExpr_MinImplCopyWithImpl<_$AggExpr_MinImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return min(input, propagateNans);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return min?.call(input, propagateNans);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (min != null) {
      return min(input, propagateNans);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return min(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return min?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (min != null) {
      return min(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Min implements AggExpr {
  const factory AggExpr_Min(
      {required final Expr input,
      required final bool propagateNans}) = _$AggExpr_MinImpl;

  Expr get input;
  bool get propagateNans;
  @JsonKey(ignore: true)
  _$$AggExpr_MinImplCopyWith<_$AggExpr_MinImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_MaxImplCopyWith<$Res> {
  factory _$$AggExpr_MaxImplCopyWith(
          _$AggExpr_MaxImpl value, $Res Function(_$AggExpr_MaxImpl) then) =
      __$$AggExpr_MaxImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr input, bool propagateNans});

  $ExprCopyWith<$Res> get input;
}

/// @nodoc
class __$$AggExpr_MaxImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_MaxImpl>
    implements _$$AggExpr_MaxImplCopyWith<$Res> {
  __$$AggExpr_MaxImplCopyWithImpl(
      _$AggExpr_MaxImpl _value, $Res Function(_$AggExpr_MaxImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? propagateNans = null,
  }) {
    return _then(_$AggExpr_MaxImpl(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as Expr,
      propagateNans: null == propagateNans
          ? _value.propagateNans
          : propagateNans // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get input {
    return $ExprCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value));
    });
  }
}

/// @nodoc

class _$AggExpr_MaxImpl implements AggExpr_Max {
  const _$AggExpr_MaxImpl({required this.input, required this.propagateNans});

  @override
  final Expr input;
  @override
  final bool propagateNans;

  @override
  String toString() {
    return 'AggExpr.max(input: $input, propagateNans: $propagateNans)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_MaxImpl &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.propagateNans, propagateNans) ||
                other.propagateNans == propagateNans));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input, propagateNans);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_MaxImplCopyWith<_$AggExpr_MaxImpl> get copyWith =>
      __$$AggExpr_MaxImplCopyWithImpl<_$AggExpr_MaxImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return max(input, propagateNans);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return max?.call(input, propagateNans);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (max != null) {
      return max(input, propagateNans);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return max(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return max?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (max != null) {
      return max(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Max implements AggExpr {
  const factory AggExpr_Max(
      {required final Expr input,
      required final bool propagateNans}) = _$AggExpr_MaxImpl;

  Expr get input;
  bool get propagateNans;
  @JsonKey(ignore: true)
  _$$AggExpr_MaxImplCopyWith<_$AggExpr_MaxImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_MedianImplCopyWith<$Res> {
  factory _$$AggExpr_MedianImplCopyWith(_$AggExpr_MedianImpl value,
          $Res Function(_$AggExpr_MedianImpl) then) =
      __$$AggExpr_MedianImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_MedianImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_MedianImpl>
    implements _$$AggExpr_MedianImplCopyWith<$Res> {
  __$$AggExpr_MedianImplCopyWithImpl(
      _$AggExpr_MedianImpl _value, $Res Function(_$AggExpr_MedianImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_MedianImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_MedianImpl implements AggExpr_Median {
  const _$AggExpr_MedianImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.median(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_MedianImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_MedianImplCopyWith<_$AggExpr_MedianImpl> get copyWith =>
      __$$AggExpr_MedianImplCopyWithImpl<_$AggExpr_MedianImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return median(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return median?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (median != null) {
      return median(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return median(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return median?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (median != null) {
      return median(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Median implements AggExpr {
  const factory AggExpr_Median(final Expr field0) = _$AggExpr_MedianImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_MedianImplCopyWith<_$AggExpr_MedianImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_NUniqueImplCopyWith<$Res> {
  factory _$$AggExpr_NUniqueImplCopyWith(_$AggExpr_NUniqueImpl value,
          $Res Function(_$AggExpr_NUniqueImpl) then) =
      __$$AggExpr_NUniqueImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_NUniqueImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_NUniqueImpl>
    implements _$$AggExpr_NUniqueImplCopyWith<$Res> {
  __$$AggExpr_NUniqueImplCopyWithImpl(
      _$AggExpr_NUniqueImpl _value, $Res Function(_$AggExpr_NUniqueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_NUniqueImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_NUniqueImpl implements AggExpr_NUnique {
  const _$AggExpr_NUniqueImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.nUnique(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_NUniqueImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_NUniqueImplCopyWith<_$AggExpr_NUniqueImpl> get copyWith =>
      __$$AggExpr_NUniqueImplCopyWithImpl<_$AggExpr_NUniqueImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return nUnique(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return nUnique?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (nUnique != null) {
      return nUnique(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return nUnique(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return nUnique?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (nUnique != null) {
      return nUnique(this);
    }
    return orElse();
  }
}

abstract class AggExpr_NUnique implements AggExpr {
  const factory AggExpr_NUnique(final Expr field0) = _$AggExpr_NUniqueImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_NUniqueImplCopyWith<_$AggExpr_NUniqueImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_FirstImplCopyWith<$Res> {
  factory _$$AggExpr_FirstImplCopyWith(
          _$AggExpr_FirstImpl value, $Res Function(_$AggExpr_FirstImpl) then) =
      __$$AggExpr_FirstImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_FirstImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_FirstImpl>
    implements _$$AggExpr_FirstImplCopyWith<$Res> {
  __$$AggExpr_FirstImplCopyWithImpl(
      _$AggExpr_FirstImpl _value, $Res Function(_$AggExpr_FirstImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_FirstImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_FirstImpl implements AggExpr_First {
  const _$AggExpr_FirstImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.first(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_FirstImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_FirstImplCopyWith<_$AggExpr_FirstImpl> get copyWith =>
      __$$AggExpr_FirstImplCopyWithImpl<_$AggExpr_FirstImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return first(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return first?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return first(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return first?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first(this);
    }
    return orElse();
  }
}

abstract class AggExpr_First implements AggExpr {
  const factory AggExpr_First(final Expr field0) = _$AggExpr_FirstImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_FirstImplCopyWith<_$AggExpr_FirstImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_LastImplCopyWith<$Res> {
  factory _$$AggExpr_LastImplCopyWith(
          _$AggExpr_LastImpl value, $Res Function(_$AggExpr_LastImpl) then) =
      __$$AggExpr_LastImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_LastImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_LastImpl>
    implements _$$AggExpr_LastImplCopyWith<$Res> {
  __$$AggExpr_LastImplCopyWithImpl(
      _$AggExpr_LastImpl _value, $Res Function(_$AggExpr_LastImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_LastImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_LastImpl implements AggExpr_Last {
  const _$AggExpr_LastImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.last(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_LastImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_LastImplCopyWith<_$AggExpr_LastImpl> get copyWith =>
      __$$AggExpr_LastImplCopyWithImpl<_$AggExpr_LastImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return last(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return last?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (last != null) {
      return last(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return last(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return last?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (last != null) {
      return last(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Last implements AggExpr {
  const factory AggExpr_Last(final Expr field0) = _$AggExpr_LastImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_LastImplCopyWith<_$AggExpr_LastImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_MeanImplCopyWith<$Res> {
  factory _$$AggExpr_MeanImplCopyWith(
          _$AggExpr_MeanImpl value, $Res Function(_$AggExpr_MeanImpl) then) =
      __$$AggExpr_MeanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_MeanImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_MeanImpl>
    implements _$$AggExpr_MeanImplCopyWith<$Res> {
  __$$AggExpr_MeanImplCopyWithImpl(
      _$AggExpr_MeanImpl _value, $Res Function(_$AggExpr_MeanImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_MeanImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_MeanImpl implements AggExpr_Mean {
  const _$AggExpr_MeanImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.mean(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_MeanImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_MeanImplCopyWith<_$AggExpr_MeanImpl> get copyWith =>
      __$$AggExpr_MeanImplCopyWithImpl<_$AggExpr_MeanImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return mean(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return mean?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (mean != null) {
      return mean(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return mean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return mean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (mean != null) {
      return mean(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Mean implements AggExpr {
  const factory AggExpr_Mean(final Expr field0) = _$AggExpr_MeanImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_MeanImplCopyWith<_$AggExpr_MeanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_CountImplCopyWith<$Res> {
  factory _$$AggExpr_CountImplCopyWith(
          _$AggExpr_CountImpl value, $Res Function(_$AggExpr_CountImpl) then) =
      __$$AggExpr_CountImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_CountImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_CountImpl>
    implements _$$AggExpr_CountImplCopyWith<$Res> {
  __$$AggExpr_CountImplCopyWithImpl(
      _$AggExpr_CountImpl _value, $Res Function(_$AggExpr_CountImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_CountImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_CountImpl implements AggExpr_Count {
  const _$AggExpr_CountImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.count(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_CountImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_CountImplCopyWith<_$AggExpr_CountImpl> get copyWith =>
      __$$AggExpr_CountImplCopyWithImpl<_$AggExpr_CountImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return count(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return count?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (count != null) {
      return count(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return count(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return count?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (count != null) {
      return count(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Count implements AggExpr {
  const factory AggExpr_Count(final Expr field0) = _$AggExpr_CountImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_CountImplCopyWith<_$AggExpr_CountImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_QuantileImplCopyWith<$Res> {
  factory _$$AggExpr_QuantileImplCopyWith(_$AggExpr_QuantileImpl value,
          $Res Function(_$AggExpr_QuantileImpl) then) =
      __$$AggExpr_QuantileImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr expr, Expr quantile, QuantileInterpolOptions interpol});

  $ExprCopyWith<$Res> get expr;
  $ExprCopyWith<$Res> get quantile;
}

/// @nodoc
class __$$AggExpr_QuantileImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_QuantileImpl>
    implements _$$AggExpr_QuantileImplCopyWith<$Res> {
  __$$AggExpr_QuantileImplCopyWithImpl(_$AggExpr_QuantileImpl _value,
      $Res Function(_$AggExpr_QuantileImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expr = null,
    Object? quantile = null,
    Object? interpol = null,
  }) {
    return _then(_$AggExpr_QuantileImpl(
      expr: null == expr
          ? _value.expr
          : expr // ignore: cast_nullable_to_non_nullable
              as Expr,
      quantile: null == quantile
          ? _value.quantile
          : quantile // ignore: cast_nullable_to_non_nullable
              as Expr,
      interpol: null == interpol
          ? _value.interpol
          : interpol // ignore: cast_nullable_to_non_nullable
              as QuantileInterpolOptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get expr {
    return $ExprCopyWith<$Res>(_value.expr, (value) {
      return _then(_value.copyWith(expr: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get quantile {
    return $ExprCopyWith<$Res>(_value.quantile, (value) {
      return _then(_value.copyWith(quantile: value));
    });
  }
}

/// @nodoc

class _$AggExpr_QuantileImpl implements AggExpr_Quantile {
  const _$AggExpr_QuantileImpl(
      {required this.expr, required this.quantile, required this.interpol});

  @override
  final Expr expr;
  @override
  final Expr quantile;
  @override
  final QuantileInterpolOptions interpol;

  @override
  String toString() {
    return 'AggExpr.quantile(expr: $expr, quantile: $quantile, interpol: $interpol)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_QuantileImpl &&
            (identical(other.expr, expr) || other.expr == expr) &&
            (identical(other.quantile, quantile) ||
                other.quantile == quantile) &&
            (identical(other.interpol, interpol) ||
                other.interpol == interpol));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expr, quantile, interpol);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_QuantileImplCopyWith<_$AggExpr_QuantileImpl> get copyWith =>
      __$$AggExpr_QuantileImplCopyWithImpl<_$AggExpr_QuantileImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return quantile(expr, this.quantile, interpol);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return quantile?.call(expr, this.quantile, interpol);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (quantile != null) {
      return quantile(expr, this.quantile, interpol);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return quantile(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return quantile?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (quantile != null) {
      return quantile(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Quantile implements AggExpr {
  const factory AggExpr_Quantile(
          {required final Expr expr,
          required final Expr quantile,
          required final QuantileInterpolOptions interpol}) =
      _$AggExpr_QuantileImpl;

  Expr get expr;
  Expr get quantile;
  QuantileInterpolOptions get interpol;
  @JsonKey(ignore: true)
  _$$AggExpr_QuantileImplCopyWith<_$AggExpr_QuantileImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_SumImplCopyWith<$Res> {
  factory _$$AggExpr_SumImplCopyWith(
          _$AggExpr_SumImpl value, $Res Function(_$AggExpr_SumImpl) then) =
      __$$AggExpr_SumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_SumImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_SumImpl>
    implements _$$AggExpr_SumImplCopyWith<$Res> {
  __$$AggExpr_SumImplCopyWithImpl(
      _$AggExpr_SumImpl _value, $Res Function(_$AggExpr_SumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_SumImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_SumImpl implements AggExpr_Sum {
  const _$AggExpr_SumImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.sum(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_SumImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_SumImplCopyWith<_$AggExpr_SumImpl> get copyWith =>
      __$$AggExpr_SumImplCopyWithImpl<_$AggExpr_SumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return sum(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return sum?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (sum != null) {
      return sum(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return sum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return sum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (sum != null) {
      return sum(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Sum implements AggExpr {
  const factory AggExpr_Sum(final Expr field0) = _$AggExpr_SumImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_SumImplCopyWith<_$AggExpr_SumImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_AggGroupsImplCopyWith<$Res> {
  factory _$$AggExpr_AggGroupsImplCopyWith(_$AggExpr_AggGroupsImpl value,
          $Res Function(_$AggExpr_AggGroupsImpl) then) =
      __$$AggExpr_AggGroupsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_AggGroupsImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_AggGroupsImpl>
    implements _$$AggExpr_AggGroupsImplCopyWith<$Res> {
  __$$AggExpr_AggGroupsImplCopyWithImpl(_$AggExpr_AggGroupsImpl _value,
      $Res Function(_$AggExpr_AggGroupsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$AggExpr_AggGroupsImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_AggGroupsImpl implements AggExpr_AggGroups {
  const _$AggExpr_AggGroupsImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'AggExpr.aggGroups(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_AggGroupsImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_AggGroupsImplCopyWith<_$AggExpr_AggGroupsImpl> get copyWith =>
      __$$AggExpr_AggGroupsImplCopyWithImpl<_$AggExpr_AggGroupsImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return aggGroups(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return aggGroups?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (aggGroups != null) {
      return aggGroups(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return aggGroups(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return aggGroups?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (aggGroups != null) {
      return aggGroups(this);
    }
    return orElse();
  }
}

abstract class AggExpr_AggGroups implements AggExpr {
  const factory AggExpr_AggGroups(final Expr field0) = _$AggExpr_AggGroupsImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$AggExpr_AggGroupsImplCopyWith<_$AggExpr_AggGroupsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_StdImplCopyWith<$Res> {
  factory _$$AggExpr_StdImplCopyWith(
          _$AggExpr_StdImpl value, $Res Function(_$AggExpr_StdImpl) then) =
      __$$AggExpr_StdImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0, int field1});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_StdImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_StdImpl>
    implements _$$AggExpr_StdImplCopyWith<$Res> {
  __$$AggExpr_StdImplCopyWithImpl(
      _$AggExpr_StdImpl _value, $Res Function(_$AggExpr_StdImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$AggExpr_StdImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_StdImpl implements AggExpr_Std {
  const _$AggExpr_StdImpl(this.field0, this.field1);

  @override
  final Expr field0;
  @override
  final int field1;

  @override
  String toString() {
    return 'AggExpr.std(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_StdImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_StdImplCopyWith<_$AggExpr_StdImpl> get copyWith =>
      __$$AggExpr_StdImplCopyWithImpl<_$AggExpr_StdImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return std(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return std?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (std != null) {
      return std(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return std(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return std?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (std != null) {
      return std(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Std implements AggExpr {
  const factory AggExpr_Std(final Expr field0, final int field1) =
      _$AggExpr_StdImpl;

  Expr get field0;
  int get field1;
  @JsonKey(ignore: true)
  _$$AggExpr_StdImplCopyWith<_$AggExpr_StdImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AggExpr_VarImplCopyWith<$Res> {
  factory _$$AggExpr_VarImplCopyWith(
          _$AggExpr_VarImpl value, $Res Function(_$AggExpr_VarImpl) then) =
      __$$AggExpr_VarImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0, int field1});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$AggExpr_VarImplCopyWithImpl<$Res>
    extends _$AggExprCopyWithImpl<$Res, _$AggExpr_VarImpl>
    implements _$$AggExpr_VarImplCopyWith<$Res> {
  __$$AggExpr_VarImplCopyWithImpl(
      _$AggExpr_VarImpl _value, $Res Function(_$AggExpr_VarImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$AggExpr_VarImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$AggExpr_VarImpl implements AggExpr_Var {
  const _$AggExpr_VarImpl(this.field0, this.field1);

  @override
  final Expr field0;
  @override
  final int field1;

  @override
  String toString() {
    return 'AggExpr.Var(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AggExpr_VarImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AggExpr_VarImplCopyWith<_$AggExpr_VarImpl> get copyWith =>
      __$$AggExpr_VarImplCopyWithImpl<_$AggExpr_VarImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr input, bool propagateNans) min,
    required TResult Function(Expr input, bool propagateNans) max,
    required TResult Function(Expr field0) median,
    required TResult Function(Expr field0) nUnique,
    required TResult Function(Expr field0) first,
    required TResult Function(Expr field0) last,
    required TResult Function(Expr field0) mean,
    required TResult Function(Expr field0) count,
    required TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)
        quantile,
    required TResult Function(Expr field0) sum,
    required TResult Function(Expr field0) aggGroups,
    required TResult Function(Expr field0, int field1) std,
    required TResult Function(Expr field0, int field1) Var,
  }) {
    return Var(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr input, bool propagateNans)? min,
    TResult? Function(Expr input, bool propagateNans)? max,
    TResult? Function(Expr field0)? median,
    TResult? Function(Expr field0)? nUnique,
    TResult? Function(Expr field0)? first,
    TResult? Function(Expr field0)? last,
    TResult? Function(Expr field0)? mean,
    TResult? Function(Expr field0)? count,
    TResult? Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult? Function(Expr field0)? sum,
    TResult? Function(Expr field0)? aggGroups,
    TResult? Function(Expr field0, int field1)? std,
    TResult? Function(Expr field0, int field1)? Var,
  }) {
    return Var?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr input, bool propagateNans)? min,
    TResult Function(Expr input, bool propagateNans)? max,
    TResult Function(Expr field0)? median,
    TResult Function(Expr field0)? nUnique,
    TResult Function(Expr field0)? first,
    TResult Function(Expr field0)? last,
    TResult Function(Expr field0)? mean,
    TResult Function(Expr field0)? count,
    TResult Function(
            Expr expr, Expr quantile, QuantileInterpolOptions interpol)?
        quantile,
    TResult Function(Expr field0)? sum,
    TResult Function(Expr field0)? aggGroups,
    TResult Function(Expr field0, int field1)? std,
    TResult Function(Expr field0, int field1)? Var,
    required TResult orElse(),
  }) {
    if (Var != null) {
      return Var(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AggExpr_Min value) min,
    required TResult Function(AggExpr_Max value) max,
    required TResult Function(AggExpr_Median value) median,
    required TResult Function(AggExpr_NUnique value) nUnique,
    required TResult Function(AggExpr_First value) first,
    required TResult Function(AggExpr_Last value) last,
    required TResult Function(AggExpr_Mean value) mean,
    required TResult Function(AggExpr_Count value) count,
    required TResult Function(AggExpr_Quantile value) quantile,
    required TResult Function(AggExpr_Sum value) sum,
    required TResult Function(AggExpr_AggGroups value) aggGroups,
    required TResult Function(AggExpr_Std value) std,
    required TResult Function(AggExpr_Var value) Var,
  }) {
    return Var(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AggExpr_Min value)? min,
    TResult? Function(AggExpr_Max value)? max,
    TResult? Function(AggExpr_Median value)? median,
    TResult? Function(AggExpr_NUnique value)? nUnique,
    TResult? Function(AggExpr_First value)? first,
    TResult? Function(AggExpr_Last value)? last,
    TResult? Function(AggExpr_Mean value)? mean,
    TResult? Function(AggExpr_Count value)? count,
    TResult? Function(AggExpr_Quantile value)? quantile,
    TResult? Function(AggExpr_Sum value)? sum,
    TResult? Function(AggExpr_AggGroups value)? aggGroups,
    TResult? Function(AggExpr_Std value)? std,
    TResult? Function(AggExpr_Var value)? Var,
  }) {
    return Var?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AggExpr_Min value)? min,
    TResult Function(AggExpr_Max value)? max,
    TResult Function(AggExpr_Median value)? median,
    TResult Function(AggExpr_NUnique value)? nUnique,
    TResult Function(AggExpr_First value)? first,
    TResult Function(AggExpr_Last value)? last,
    TResult Function(AggExpr_Mean value)? mean,
    TResult Function(AggExpr_Count value)? count,
    TResult Function(AggExpr_Quantile value)? quantile,
    TResult Function(AggExpr_Sum value)? sum,
    TResult Function(AggExpr_AggGroups value)? aggGroups,
    TResult Function(AggExpr_Std value)? std,
    TResult Function(AggExpr_Var value)? Var,
    required TResult orElse(),
  }) {
    if (Var != null) {
      return Var(this);
    }
    return orElse();
  }
}

abstract class AggExpr_Var implements AggExpr {
  const factory AggExpr_Var(final Expr field0, final int field1) =
      _$AggExpr_VarImpl;

  Expr get field0;
  int get field1;
  @JsonKey(ignore: true)
  _$$AggExpr_VarImplCopyWith<_$AggExpr_VarImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DataType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataTypeCopyWith<$Res> {
  factory $DataTypeCopyWith(DataType value, $Res Function(DataType) then) =
      _$DataTypeCopyWithImpl<$Res, DataType>;
}

/// @nodoc
class _$DataTypeCopyWithImpl<$Res, $Val extends DataType>
    implements $DataTypeCopyWith<$Res> {
  _$DataTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DataType_BooleanImplCopyWith<$Res> {
  factory _$$DataType_BooleanImplCopyWith(_$DataType_BooleanImpl value,
          $Res Function(_$DataType_BooleanImpl) then) =
      __$$DataType_BooleanImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_BooleanImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_BooleanImpl>
    implements _$$DataType_BooleanImplCopyWith<$Res> {
  __$$DataType_BooleanImplCopyWithImpl(_$DataType_BooleanImpl _value,
      $Res Function(_$DataType_BooleanImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_BooleanImpl implements DataType_Boolean {
  const _$DataType_BooleanImpl();

  @override
  String toString() {
    return 'DataType.boolean()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_BooleanImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return boolean();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return boolean?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class DataType_Boolean implements DataType {
  const factory DataType_Boolean() = _$DataType_BooleanImpl;
}

/// @nodoc
abstract class _$$DataType_UInt8ImplCopyWith<$Res> {
  factory _$$DataType_UInt8ImplCopyWith(_$DataType_UInt8Impl value,
          $Res Function(_$DataType_UInt8Impl) then) =
      __$$DataType_UInt8ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt8ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt8Impl>
    implements _$$DataType_UInt8ImplCopyWith<$Res> {
  __$$DataType_UInt8ImplCopyWithImpl(
      _$DataType_UInt8Impl _value, $Res Function(_$DataType_UInt8Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt8Impl implements DataType_UInt8 {
  const _$DataType_UInt8Impl();

  @override
  String toString() {
    return 'DataType.uInt8()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt8Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return uInt8();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return uInt8?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt8 implements DataType {
  const factory DataType_UInt8() = _$DataType_UInt8Impl;
}

/// @nodoc
abstract class _$$DataType_UInt16ImplCopyWith<$Res> {
  factory _$$DataType_UInt16ImplCopyWith(_$DataType_UInt16Impl value,
          $Res Function(_$DataType_UInt16Impl) then) =
      __$$DataType_UInt16ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt16ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt16Impl>
    implements _$$DataType_UInt16ImplCopyWith<$Res> {
  __$$DataType_UInt16ImplCopyWithImpl(
      _$DataType_UInt16Impl _value, $Res Function(_$DataType_UInt16Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt16Impl implements DataType_UInt16 {
  const _$DataType_UInt16Impl();

  @override
  String toString() {
    return 'DataType.uInt16()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt16Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return uInt16();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return uInt16?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt16 implements DataType {
  const factory DataType_UInt16() = _$DataType_UInt16Impl;
}

/// @nodoc
abstract class _$$DataType_UInt32ImplCopyWith<$Res> {
  factory _$$DataType_UInt32ImplCopyWith(_$DataType_UInt32Impl value,
          $Res Function(_$DataType_UInt32Impl) then) =
      __$$DataType_UInt32ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt32ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt32Impl>
    implements _$$DataType_UInt32ImplCopyWith<$Res> {
  __$$DataType_UInt32ImplCopyWithImpl(
      _$DataType_UInt32Impl _value, $Res Function(_$DataType_UInt32Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt32Impl implements DataType_UInt32 {
  const _$DataType_UInt32Impl();

  @override
  String toString() {
    return 'DataType.uInt32()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt32Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return uInt32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return uInt32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt32 implements DataType {
  const factory DataType_UInt32() = _$DataType_UInt32Impl;
}

/// @nodoc
abstract class _$$DataType_UInt64ImplCopyWith<$Res> {
  factory _$$DataType_UInt64ImplCopyWith(_$DataType_UInt64Impl value,
          $Res Function(_$DataType_UInt64Impl) then) =
      __$$DataType_UInt64ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UInt64ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UInt64Impl>
    implements _$$DataType_UInt64ImplCopyWith<$Res> {
  __$$DataType_UInt64ImplCopyWithImpl(
      _$DataType_UInt64Impl _value, $Res Function(_$DataType_UInt64Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UInt64Impl implements DataType_UInt64 {
  const _$DataType_UInt64Impl();

  @override
  String toString() {
    return 'DataType.uInt64()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UInt64Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return uInt64();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return uInt64?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return uInt64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return uInt64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(this);
    }
    return orElse();
  }
}

abstract class DataType_UInt64 implements DataType {
  const factory DataType_UInt64() = _$DataType_UInt64Impl;
}

/// @nodoc
abstract class _$$DataType_Int8ImplCopyWith<$Res> {
  factory _$$DataType_Int8ImplCopyWith(
          _$DataType_Int8Impl value, $Res Function(_$DataType_Int8Impl) then) =
      __$$DataType_Int8ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int8ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int8Impl>
    implements _$$DataType_Int8ImplCopyWith<$Res> {
  __$$DataType_Int8ImplCopyWithImpl(
      _$DataType_Int8Impl _value, $Res Function(_$DataType_Int8Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int8Impl implements DataType_Int8 {
  const _$DataType_Int8Impl();

  @override
  String toString() {
    return 'DataType.int8()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int8Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return int8();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return int8?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8(this);
    }
    return orElse();
  }
}

abstract class DataType_Int8 implements DataType {
  const factory DataType_Int8() = _$DataType_Int8Impl;
}

/// @nodoc
abstract class _$$DataType_Int16ImplCopyWith<$Res> {
  factory _$$DataType_Int16ImplCopyWith(_$DataType_Int16Impl value,
          $Res Function(_$DataType_Int16Impl) then) =
      __$$DataType_Int16ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int16ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int16Impl>
    implements _$$DataType_Int16ImplCopyWith<$Res> {
  __$$DataType_Int16ImplCopyWithImpl(
      _$DataType_Int16Impl _value, $Res Function(_$DataType_Int16Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int16Impl implements DataType_Int16 {
  const _$DataType_Int16Impl();

  @override
  String toString() {
    return 'DataType.int16()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int16Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return int16();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return int16?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16(this);
    }
    return orElse();
  }
}

abstract class DataType_Int16 implements DataType {
  const factory DataType_Int16() = _$DataType_Int16Impl;
}

/// @nodoc
abstract class _$$DataType_Int32ImplCopyWith<$Res> {
  factory _$$DataType_Int32ImplCopyWith(_$DataType_Int32Impl value,
          $Res Function(_$DataType_Int32Impl) then) =
      __$$DataType_Int32ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int32ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int32Impl>
    implements _$$DataType_Int32ImplCopyWith<$Res> {
  __$$DataType_Int32ImplCopyWithImpl(
      _$DataType_Int32Impl _value, $Res Function(_$DataType_Int32Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int32Impl implements DataType_Int32 {
  const _$DataType_Int32Impl();

  @override
  String toString() {
    return 'DataType.int32()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int32Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return int32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return int32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(this);
    }
    return orElse();
  }
}

abstract class DataType_Int32 implements DataType {
  const factory DataType_Int32() = _$DataType_Int32Impl;
}

/// @nodoc
abstract class _$$DataType_Int64ImplCopyWith<$Res> {
  factory _$$DataType_Int64ImplCopyWith(_$DataType_Int64Impl value,
          $Res Function(_$DataType_Int64Impl) then) =
      __$$DataType_Int64ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Int64ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Int64Impl>
    implements _$$DataType_Int64ImplCopyWith<$Res> {
  __$$DataType_Int64ImplCopyWithImpl(
      _$DataType_Int64Impl _value, $Res Function(_$DataType_Int64Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Int64Impl implements DataType_Int64 {
  const _$DataType_Int64Impl();

  @override
  String toString() {
    return 'DataType.int64()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Int64Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return int64();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return int64?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return int64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return int64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(this);
    }
    return orElse();
  }
}

abstract class DataType_Int64 implements DataType {
  const factory DataType_Int64() = _$DataType_Int64Impl;
}

/// @nodoc
abstract class _$$DataType_Float32ImplCopyWith<$Res> {
  factory _$$DataType_Float32ImplCopyWith(_$DataType_Float32Impl value,
          $Res Function(_$DataType_Float32Impl) then) =
      __$$DataType_Float32ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Float32ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Float32Impl>
    implements _$$DataType_Float32ImplCopyWith<$Res> {
  __$$DataType_Float32ImplCopyWithImpl(_$DataType_Float32Impl _value,
      $Res Function(_$DataType_Float32Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Float32Impl implements DataType_Float32 {
  const _$DataType_Float32Impl();

  @override
  String toString() {
    return 'DataType.float32()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Float32Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return float32();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return float32?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return float32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return float32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32(this);
    }
    return orElse();
  }
}

abstract class DataType_Float32 implements DataType {
  const factory DataType_Float32() = _$DataType_Float32Impl;
}

/// @nodoc
abstract class _$$DataType_Float64ImplCopyWith<$Res> {
  factory _$$DataType_Float64ImplCopyWith(_$DataType_Float64Impl value,
          $Res Function(_$DataType_Float64Impl) then) =
      __$$DataType_Float64ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Float64ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Float64Impl>
    implements _$$DataType_Float64ImplCopyWith<$Res> {
  __$$DataType_Float64ImplCopyWithImpl(_$DataType_Float64Impl _value,
      $Res Function(_$DataType_Float64Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Float64Impl implements DataType_Float64 {
  const _$DataType_Float64Impl();

  @override
  String toString() {
    return 'DataType.float64()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Float64Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return float64();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return float64?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return float64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return float64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(this);
    }
    return orElse();
  }
}

abstract class DataType_Float64 implements DataType {
  const factory DataType_Float64() = _$DataType_Float64Impl;
}

/// @nodoc
abstract class _$$DataType_Utf8ImplCopyWith<$Res> {
  factory _$$DataType_Utf8ImplCopyWith(
          _$DataType_Utf8Impl value, $Res Function(_$DataType_Utf8Impl) then) =
      __$$DataType_Utf8ImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_Utf8ImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_Utf8Impl>
    implements _$$DataType_Utf8ImplCopyWith<$Res> {
  __$$DataType_Utf8ImplCopyWithImpl(
      _$DataType_Utf8Impl _value, $Res Function(_$DataType_Utf8Impl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_Utf8Impl implements DataType_Utf8 {
  const _$DataType_Utf8Impl();

  @override
  String toString() {
    return 'DataType.utf8()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_Utf8Impl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return utf8();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return utf8?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return utf8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return utf8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8(this);
    }
    return orElse();
  }
}

abstract class DataType_Utf8 implements DataType {
  const factory DataType_Utf8() = _$DataType_Utf8Impl;
}

/// @nodoc
abstract class _$$DataType_BinaryImplCopyWith<$Res> {
  factory _$$DataType_BinaryImplCopyWith(_$DataType_BinaryImpl value,
          $Res Function(_$DataType_BinaryImpl) then) =
      __$$DataType_BinaryImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_BinaryImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_BinaryImpl>
    implements _$$DataType_BinaryImplCopyWith<$Res> {
  __$$DataType_BinaryImplCopyWithImpl(
      _$DataType_BinaryImpl _value, $Res Function(_$DataType_BinaryImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_BinaryImpl implements DataType_Binary {
  const _$DataType_BinaryImpl();

  @override
  String toString() {
    return 'DataType.binary()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_BinaryImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return binary();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return binary?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return binary(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return binary?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(this);
    }
    return orElse();
  }
}

abstract class DataType_Binary implements DataType {
  const factory DataType_Binary() = _$DataType_BinaryImpl;
}

/// @nodoc
abstract class _$$DataType_DateImplCopyWith<$Res> {
  factory _$$DataType_DateImplCopyWith(
          _$DataType_DateImpl value, $Res Function(_$DataType_DateImpl) then) =
      __$$DataType_DateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_DateImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_DateImpl>
    implements _$$DataType_DateImplCopyWith<$Res> {
  __$$DataType_DateImplCopyWithImpl(
      _$DataType_DateImpl _value, $Res Function(_$DataType_DateImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_DateImpl implements DataType_Date {
  const _$DataType_DateImpl();

  @override
  String toString() {
    return 'DataType.date()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_DateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return date();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return date?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return date(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return date?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date(this);
    }
    return orElse();
  }
}

abstract class DataType_Date implements DataType {
  const factory DataType_Date() = _$DataType_DateImpl;
}

/// @nodoc
abstract class _$$DataType_DatetimeImplCopyWith<$Res> {
  factory _$$DataType_DatetimeImplCopyWith(_$DataType_DatetimeImpl value,
          $Res Function(_$DataType_DatetimeImpl) then) =
      __$$DataType_DatetimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TimeUnit field0, String? field1});
}

/// @nodoc
class __$$DataType_DatetimeImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_DatetimeImpl>
    implements _$$DataType_DatetimeImplCopyWith<$Res> {
  __$$DataType_DatetimeImplCopyWithImpl(_$DataType_DatetimeImpl _value,
      $Res Function(_$DataType_DatetimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = freezed,
  }) {
    return _then(_$DataType_DatetimeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
      freezed == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$DataType_DatetimeImpl implements DataType_Datetime {
  const _$DataType_DatetimeImpl(this.field0, [this.field1]);

  @override
  final TimeUnit field0;
  @override
  final String? field1;

  @override
  String toString() {
    return 'DataType.datetime(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_DatetimeImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_DatetimeImplCopyWith<_$DataType_DatetimeImpl> get copyWith =>
      __$$DataType_DatetimeImplCopyWithImpl<_$DataType_DatetimeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return datetime(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return datetime?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (datetime != null) {
      return datetime(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return datetime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return datetime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (datetime != null) {
      return datetime(this);
    }
    return orElse();
  }
}

abstract class DataType_Datetime implements DataType {
  const factory DataType_Datetime(final TimeUnit field0,
      [final String? field1]) = _$DataType_DatetimeImpl;

  TimeUnit get field0;
  String? get field1;
  @JsonKey(ignore: true)
  _$$DataType_DatetimeImplCopyWith<_$DataType_DatetimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_DurationImplCopyWith<$Res> {
  factory _$$DataType_DurationImplCopyWith(_$DataType_DurationImpl value,
          $Res Function(_$DataType_DurationImpl) then) =
      __$$DataType_DurationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TimeUnit field0});
}

/// @nodoc
class __$$DataType_DurationImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_DurationImpl>
    implements _$$DataType_DurationImplCopyWith<$Res> {
  __$$DataType_DurationImplCopyWithImpl(_$DataType_DurationImpl _value,
      $Res Function(_$DataType_DurationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DataType_DurationImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
    ));
  }
}

/// @nodoc

class _$DataType_DurationImpl implements DataType_Duration {
  const _$DataType_DurationImpl(this.field0);

  @override
  final TimeUnit field0;

  @override
  String toString() {
    return 'DataType.duration(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_DurationImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_DurationImplCopyWith<_$DataType_DurationImpl> get copyWith =>
      __$$DataType_DurationImplCopyWithImpl<_$DataType_DurationImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return duration(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return duration?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return duration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return duration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(this);
    }
    return orElse();
  }
}

abstract class DataType_Duration implements DataType {
  const factory DataType_Duration(final TimeUnit field0) =
      _$DataType_DurationImpl;

  TimeUnit get field0;
  @JsonKey(ignore: true)
  _$$DataType_DurationImplCopyWith<_$DataType_DurationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_TimeImplCopyWith<$Res> {
  factory _$$DataType_TimeImplCopyWith(
          _$DataType_TimeImpl value, $Res Function(_$DataType_TimeImpl) then) =
      __$$DataType_TimeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_TimeImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_TimeImpl>
    implements _$$DataType_TimeImplCopyWith<$Res> {
  __$$DataType_TimeImplCopyWithImpl(
      _$DataType_TimeImpl _value, $Res Function(_$DataType_TimeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_TimeImpl implements DataType_Time {
  const _$DataType_TimeImpl();

  @override
  String toString() {
    return 'DataType.time()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_TimeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return time();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return time?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return time(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return time?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time(this);
    }
    return orElse();
  }
}

abstract class DataType_Time implements DataType {
  const factory DataType_Time() = _$DataType_TimeImpl;
}

/// @nodoc
abstract class _$$DataType_ListImplCopyWith<$Res> {
  factory _$$DataType_ListImplCopyWith(
          _$DataType_ListImpl value, $Res Function(_$DataType_ListImpl) then) =
      __$$DataType_ListImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DataType field0});

  $DataTypeCopyWith<$Res> get field0;
}

/// @nodoc
class __$$DataType_ListImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_ListImpl>
    implements _$$DataType_ListImplCopyWith<$Res> {
  __$$DataType_ListImplCopyWithImpl(
      _$DataType_ListImpl _value, $Res Function(_$DataType_ListImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DataType_ListImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get field0 {
    return $DataTypeCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$DataType_ListImpl implements DataType_List {
  const _$DataType_ListImpl(this.field0);

  @override
  final DataType field0;

  @override
  String toString() {
    return 'DataType.list(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_ListImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_ListImplCopyWith<_$DataType_ListImpl> get copyWith =>
      __$$DataType_ListImplCopyWithImpl<_$DataType_ListImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return list(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return list?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return list(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return list?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (list != null) {
      return list(this);
    }
    return orElse();
  }
}

abstract class DataType_List implements DataType {
  const factory DataType_List(final DataType field0) = _$DataType_ListImpl;

  DataType get field0;
  @JsonKey(ignore: true)
  _$$DataType_ListImplCopyWith<_$DataType_ListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_NullImplCopyWith<$Res> {
  factory _$$DataType_NullImplCopyWith(
          _$DataType_NullImpl value, $Res Function(_$DataType_NullImpl) then) =
      __$$DataType_NullImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_NullImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_NullImpl>
    implements _$$DataType_NullImplCopyWith<$Res> {
  __$$DataType_NullImplCopyWithImpl(
      _$DataType_NullImpl _value, $Res Function(_$DataType_NullImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_NullImpl implements DataType_Null {
  const _$DataType_NullImpl();

  @override
  String toString() {
    return 'DataType.Null()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_NullImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return Null();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return Null?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (Null != null) {
      return Null();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return Null(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return Null?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (Null != null) {
      return Null(this);
    }
    return orElse();
  }
}

abstract class DataType_Null implements DataType {
  const factory DataType_Null() = _$DataType_NullImpl;
}

/// @nodoc
abstract class _$$DataType_StructImplCopyWith<$Res> {
  factory _$$DataType_StructImplCopyWith(_$DataType_StructImpl value,
          $Res Function(_$DataType_StructImpl) then) =
      __$$DataType_StructImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Field> field0});
}

/// @nodoc
class __$$DataType_StructImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_StructImpl>
    implements _$$DataType_StructImplCopyWith<$Res> {
  __$$DataType_StructImplCopyWithImpl(
      _$DataType_StructImpl _value, $Res Function(_$DataType_StructImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DataType_StructImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<Field>,
    ));
  }
}

/// @nodoc

class _$DataType_StructImpl implements DataType_Struct {
  const _$DataType_StructImpl(final List<Field> field0) : _field0 = field0;

  final List<Field> _field0;
  @override
  List<Field> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'DataType.struct(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataType_StructImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataType_StructImplCopyWith<_$DataType_StructImpl> get copyWith =>
      __$$DataType_StructImplCopyWithImpl<_$DataType_StructImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return struct(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return struct?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (struct != null) {
      return struct(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return struct(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return struct?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (struct != null) {
      return struct(this);
    }
    return orElse();
  }
}

abstract class DataType_Struct implements DataType {
  const factory DataType_Struct(final List<Field> field0) =
      _$DataType_StructImpl;

  List<Field> get field0;
  @JsonKey(ignore: true)
  _$$DataType_StructImplCopyWith<_$DataType_StructImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DataType_UnknownImplCopyWith<$Res> {
  factory _$$DataType_UnknownImplCopyWith(_$DataType_UnknownImpl value,
          $Res Function(_$DataType_UnknownImpl) then) =
      __$$DataType_UnknownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DataType_UnknownImplCopyWithImpl<$Res>
    extends _$DataTypeCopyWithImpl<$Res, _$DataType_UnknownImpl>
    implements _$$DataType_UnknownImplCopyWith<$Res> {
  __$$DataType_UnknownImplCopyWithImpl(_$DataType_UnknownImpl _value,
      $Res Function(_$DataType_UnknownImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DataType_UnknownImpl implements DataType_Unknown {
  const _$DataType_UnknownImpl();

  @override
  String toString() {
    return 'DataType.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$DataType_UnknownImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boolean,
    required TResult Function() uInt8,
    required TResult Function() uInt16,
    required TResult Function() uInt32,
    required TResult Function() uInt64,
    required TResult Function() int8,
    required TResult Function() int16,
    required TResult Function() int32,
    required TResult Function() int64,
    required TResult Function() float32,
    required TResult Function() float64,
    required TResult Function() utf8,
    required TResult Function() binary,
    required TResult Function() date,
    required TResult Function(TimeUnit field0, String? field1) datetime,
    required TResult Function(TimeUnit field0) duration,
    required TResult Function() time,
    required TResult Function(DataType field0) list,
    required TResult Function() Null,
    required TResult Function(List<Field> field0) struct,
    required TResult Function() unknown,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? boolean,
    TResult? Function()? uInt8,
    TResult? Function()? uInt16,
    TResult? Function()? uInt32,
    TResult? Function()? uInt64,
    TResult? Function()? int8,
    TResult? Function()? int16,
    TResult? Function()? int32,
    TResult? Function()? int64,
    TResult? Function()? float32,
    TResult? Function()? float64,
    TResult? Function()? utf8,
    TResult? Function()? binary,
    TResult? Function()? date,
    TResult? Function(TimeUnit field0, String? field1)? datetime,
    TResult? Function(TimeUnit field0)? duration,
    TResult? Function()? time,
    TResult? Function(DataType field0)? list,
    TResult? Function()? Null,
    TResult? Function(List<Field> field0)? struct,
    TResult? Function()? unknown,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boolean,
    TResult Function()? uInt8,
    TResult Function()? uInt16,
    TResult Function()? uInt32,
    TResult Function()? uInt64,
    TResult Function()? int8,
    TResult Function()? int16,
    TResult Function()? int32,
    TResult Function()? int64,
    TResult Function()? float32,
    TResult Function()? float64,
    TResult Function()? utf8,
    TResult Function()? binary,
    TResult Function()? date,
    TResult Function(TimeUnit field0, String? field1)? datetime,
    TResult Function(TimeUnit field0)? duration,
    TResult Function()? time,
    TResult Function(DataType field0)? list,
    TResult Function()? Null,
    TResult Function(List<Field> field0)? struct,
    TResult Function()? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DataType_Boolean value) boolean,
    required TResult Function(DataType_UInt8 value) uInt8,
    required TResult Function(DataType_UInt16 value) uInt16,
    required TResult Function(DataType_UInt32 value) uInt32,
    required TResult Function(DataType_UInt64 value) uInt64,
    required TResult Function(DataType_Int8 value) int8,
    required TResult Function(DataType_Int16 value) int16,
    required TResult Function(DataType_Int32 value) int32,
    required TResult Function(DataType_Int64 value) int64,
    required TResult Function(DataType_Float32 value) float32,
    required TResult Function(DataType_Float64 value) float64,
    required TResult Function(DataType_Utf8 value) utf8,
    required TResult Function(DataType_Binary value) binary,
    required TResult Function(DataType_Date value) date,
    required TResult Function(DataType_Datetime value) datetime,
    required TResult Function(DataType_Duration value) duration,
    required TResult Function(DataType_Time value) time,
    required TResult Function(DataType_List value) list,
    required TResult Function(DataType_Null value) Null,
    required TResult Function(DataType_Struct value) struct,
    required TResult Function(DataType_Unknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DataType_Boolean value)? boolean,
    TResult? Function(DataType_UInt8 value)? uInt8,
    TResult? Function(DataType_UInt16 value)? uInt16,
    TResult? Function(DataType_UInt32 value)? uInt32,
    TResult? Function(DataType_UInt64 value)? uInt64,
    TResult? Function(DataType_Int8 value)? int8,
    TResult? Function(DataType_Int16 value)? int16,
    TResult? Function(DataType_Int32 value)? int32,
    TResult? Function(DataType_Int64 value)? int64,
    TResult? Function(DataType_Float32 value)? float32,
    TResult? Function(DataType_Float64 value)? float64,
    TResult? Function(DataType_Utf8 value)? utf8,
    TResult? Function(DataType_Binary value)? binary,
    TResult? Function(DataType_Date value)? date,
    TResult? Function(DataType_Datetime value)? datetime,
    TResult? Function(DataType_Duration value)? duration,
    TResult? Function(DataType_Time value)? time,
    TResult? Function(DataType_List value)? list,
    TResult? Function(DataType_Null value)? Null,
    TResult? Function(DataType_Struct value)? struct,
    TResult? Function(DataType_Unknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DataType_Boolean value)? boolean,
    TResult Function(DataType_UInt8 value)? uInt8,
    TResult Function(DataType_UInt16 value)? uInt16,
    TResult Function(DataType_UInt32 value)? uInt32,
    TResult Function(DataType_UInt64 value)? uInt64,
    TResult Function(DataType_Int8 value)? int8,
    TResult Function(DataType_Int16 value)? int16,
    TResult Function(DataType_Int32 value)? int32,
    TResult Function(DataType_Int64 value)? int64,
    TResult Function(DataType_Float32 value)? float32,
    TResult Function(DataType_Float64 value)? float64,
    TResult Function(DataType_Utf8 value)? utf8,
    TResult Function(DataType_Binary value)? binary,
    TResult Function(DataType_Date value)? date,
    TResult Function(DataType_Datetime value)? datetime,
    TResult Function(DataType_Duration value)? duration,
    TResult Function(DataType_Time value)? time,
    TResult Function(DataType_List value)? list,
    TResult Function(DataType_Null value)? Null,
    TResult Function(DataType_Struct value)? struct,
    TResult Function(DataType_Unknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class DataType_Unknown implements DataType {
  const factory DataType_Unknown() = _$DataType_UnknownImpl;
}

/// @nodoc
mixin _$Excluded {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) name,
    required TResult Function(DataType field0) dtype,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? name,
    TResult? Function(DataType field0)? dtype,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? name,
    TResult Function(DataType field0)? dtype,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Excluded_Name value) name,
    required TResult Function(Excluded_Dtype value) dtype,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Excluded_Name value)? name,
    TResult? Function(Excluded_Dtype value)? dtype,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Excluded_Name value)? name,
    TResult Function(Excluded_Dtype value)? dtype,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExcludedCopyWith<$Res> {
  factory $ExcludedCopyWith(Excluded value, $Res Function(Excluded) then) =
      _$ExcludedCopyWithImpl<$Res, Excluded>;
}

/// @nodoc
class _$ExcludedCopyWithImpl<$Res, $Val extends Excluded>
    implements $ExcludedCopyWith<$Res> {
  _$ExcludedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Excluded_NameImplCopyWith<$Res> {
  factory _$$Excluded_NameImplCopyWith(
          _$Excluded_NameImpl value, $Res Function(_$Excluded_NameImpl) then) =
      __$$Excluded_NameImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$Excluded_NameImplCopyWithImpl<$Res>
    extends _$ExcludedCopyWithImpl<$Res, _$Excluded_NameImpl>
    implements _$$Excluded_NameImplCopyWith<$Res> {
  __$$Excluded_NameImplCopyWithImpl(
      _$Excluded_NameImpl _value, $Res Function(_$Excluded_NameImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Excluded_NameImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Excluded_NameImpl implements Excluded_Name {
  const _$Excluded_NameImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'Excluded.name(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Excluded_NameImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Excluded_NameImplCopyWith<_$Excluded_NameImpl> get copyWith =>
      __$$Excluded_NameImplCopyWithImpl<_$Excluded_NameImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) name,
    required TResult Function(DataType field0) dtype,
  }) {
    return name(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? name,
    TResult? Function(DataType field0)? dtype,
  }) {
    return name?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? name,
    TResult Function(DataType field0)? dtype,
    required TResult orElse(),
  }) {
    if (name != null) {
      return name(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Excluded_Name value) name,
    required TResult Function(Excluded_Dtype value) dtype,
  }) {
    return name(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Excluded_Name value)? name,
    TResult? Function(Excluded_Dtype value)? dtype,
  }) {
    return name?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Excluded_Name value)? name,
    TResult Function(Excluded_Dtype value)? dtype,
    required TResult orElse(),
  }) {
    if (name != null) {
      return name(this);
    }
    return orElse();
  }
}

abstract class Excluded_Name implements Excluded {
  const factory Excluded_Name(final String field0) = _$Excluded_NameImpl;

  @override
  String get field0;
  @JsonKey(ignore: true)
  _$$Excluded_NameImplCopyWith<_$Excluded_NameImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Excluded_DtypeImplCopyWith<$Res> {
  factory _$$Excluded_DtypeImplCopyWith(_$Excluded_DtypeImpl value,
          $Res Function(_$Excluded_DtypeImpl) then) =
      __$$Excluded_DtypeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DataType field0});

  $DataTypeCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Excluded_DtypeImplCopyWithImpl<$Res>
    extends _$ExcludedCopyWithImpl<$Res, _$Excluded_DtypeImpl>
    implements _$$Excluded_DtypeImplCopyWith<$Res> {
  __$$Excluded_DtypeImplCopyWithImpl(
      _$Excluded_DtypeImpl _value, $Res Function(_$Excluded_DtypeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Excluded_DtypeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get field0 {
    return $DataTypeCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Excluded_DtypeImpl implements Excluded_Dtype {
  const _$Excluded_DtypeImpl(this.field0);

  @override
  final DataType field0;

  @override
  String toString() {
    return 'Excluded.dtype(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Excluded_DtypeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Excluded_DtypeImplCopyWith<_$Excluded_DtypeImpl> get copyWith =>
      __$$Excluded_DtypeImplCopyWithImpl<_$Excluded_DtypeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) name,
    required TResult Function(DataType field0) dtype,
  }) {
    return dtype(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? name,
    TResult? Function(DataType field0)? dtype,
  }) {
    return dtype?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? name,
    TResult Function(DataType field0)? dtype,
    required TResult orElse(),
  }) {
    if (dtype != null) {
      return dtype(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Excluded_Name value) name,
    required TResult Function(Excluded_Dtype value) dtype,
  }) {
    return dtype(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Excluded_Name value)? name,
    TResult? Function(Excluded_Dtype value)? dtype,
  }) {
    return dtype?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Excluded_Name value)? name,
    TResult Function(Excluded_Dtype value)? dtype,
    required TResult orElse(),
  }) {
    if (dtype != null) {
      return dtype(this);
    }
    return orElse();
  }
}

abstract class Excluded_Dtype implements Excluded {
  const factory Excluded_Dtype(final DataType field0) = _$Excluded_DtypeImpl;

  @override
  DataType get field0;
  @JsonKey(ignore: true)
  _$$Excluded_DtypeImplCopyWith<_$Excluded_DtypeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Expr {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExprCopyWith<$Res> {
  factory $ExprCopyWith(Expr value, $Res Function(Expr) then) =
      _$ExprCopyWithImpl<$Res, Expr>;
}

/// @nodoc
class _$ExprCopyWithImpl<$Res, $Val extends Expr>
    implements $ExprCopyWith<$Res> {
  _$ExprCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Expr_AliasImplCopyWith<$Res> {
  factory _$$Expr_AliasImplCopyWith(
          _$Expr_AliasImpl value, $Res Function(_$Expr_AliasImpl) then) =
      __$$Expr_AliasImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0, String field1});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_AliasImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_AliasImpl>
    implements _$$Expr_AliasImplCopyWith<$Res> {
  __$$Expr_AliasImplCopyWithImpl(
      _$Expr_AliasImpl _value, $Res Function(_$Expr_AliasImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$Expr_AliasImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_AliasImpl implements Expr_Alias {
  const _$Expr_AliasImpl(this.field0, this.field1);

  @override
  final Expr field0;
  @override
  final String field1;

  @override
  String toString() {
    return 'Expr.alias(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_AliasImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_AliasImplCopyWith<_$Expr_AliasImpl> get copyWith =>
      __$$Expr_AliasImplCopyWithImpl<_$Expr_AliasImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return alias(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return alias?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (alias != null) {
      return alias(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return alias(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return alias?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (alias != null) {
      return alias(this);
    }
    return orElse();
  }
}

abstract class Expr_Alias implements Expr {
  const factory Expr_Alias(final Expr field0, final String field1) =
      _$Expr_AliasImpl;

  Expr get field0;
  String get field1;
  @JsonKey(ignore: true)
  _$$Expr_AliasImplCopyWith<_$Expr_AliasImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_ColumnImplCopyWith<$Res> {
  factory _$$Expr_ColumnImplCopyWith(
          _$Expr_ColumnImpl value, $Res Function(_$Expr_ColumnImpl) then) =
      __$$Expr_ColumnImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$Expr_ColumnImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_ColumnImpl>
    implements _$$Expr_ColumnImplCopyWith<$Res> {
  __$$Expr_ColumnImplCopyWithImpl(
      _$Expr_ColumnImpl _value, $Res Function(_$Expr_ColumnImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_ColumnImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Expr_ColumnImpl implements Expr_Column {
  const _$Expr_ColumnImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'Expr.column(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_ColumnImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_ColumnImplCopyWith<_$Expr_ColumnImpl> get copyWith =>
      __$$Expr_ColumnImplCopyWithImpl<_$Expr_ColumnImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return column(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return column?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (column != null) {
      return column(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return column(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return column?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (column != null) {
      return column(this);
    }
    return orElse();
  }
}

abstract class Expr_Column implements Expr {
  const factory Expr_Column(final String field0) = _$Expr_ColumnImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$Expr_ColumnImplCopyWith<_$Expr_ColumnImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_ColumnsImplCopyWith<$Res> {
  factory _$$Expr_ColumnsImplCopyWith(
          _$Expr_ColumnsImpl value, $Res Function(_$Expr_ColumnsImpl) then) =
      __$$Expr_ColumnsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> field0});
}

/// @nodoc
class __$$Expr_ColumnsImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_ColumnsImpl>
    implements _$$Expr_ColumnsImplCopyWith<$Res> {
  __$$Expr_ColumnsImplCopyWithImpl(
      _$Expr_ColumnsImpl _value, $Res Function(_$Expr_ColumnsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_ColumnsImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$Expr_ColumnsImpl implements Expr_Columns {
  const _$Expr_ColumnsImpl(final List<String> field0) : _field0 = field0;

  final List<String> _field0;
  @override
  List<String> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Expr.columns(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_ColumnsImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_ColumnsImplCopyWith<_$Expr_ColumnsImpl> get copyWith =>
      __$$Expr_ColumnsImplCopyWithImpl<_$Expr_ColumnsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return columns(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return columns?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (columns != null) {
      return columns(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return columns(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return columns?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (columns != null) {
      return columns(this);
    }
    return orElse();
  }
}

abstract class Expr_Columns implements Expr {
  const factory Expr_Columns(final List<String> field0) = _$Expr_ColumnsImpl;

  List<String> get field0;
  @JsonKey(ignore: true)
  _$$Expr_ColumnsImplCopyWith<_$Expr_ColumnsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_DtypeColumnImplCopyWith<$Res> {
  factory _$$Expr_DtypeColumnImplCopyWith(_$Expr_DtypeColumnImpl value,
          $Res Function(_$Expr_DtypeColumnImpl) then) =
      __$$Expr_DtypeColumnImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<DataType> field0});
}

/// @nodoc
class __$$Expr_DtypeColumnImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_DtypeColumnImpl>
    implements _$$Expr_DtypeColumnImplCopyWith<$Res> {
  __$$Expr_DtypeColumnImplCopyWithImpl(_$Expr_DtypeColumnImpl _value,
      $Res Function(_$Expr_DtypeColumnImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_DtypeColumnImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<DataType>,
    ));
  }
}

/// @nodoc

class _$Expr_DtypeColumnImpl implements Expr_DtypeColumn {
  const _$Expr_DtypeColumnImpl(final List<DataType> field0) : _field0 = field0;

  final List<DataType> _field0;
  @override
  List<DataType> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Expr.dtypeColumn(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_DtypeColumnImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_DtypeColumnImplCopyWith<_$Expr_DtypeColumnImpl> get copyWith =>
      __$$Expr_DtypeColumnImplCopyWithImpl<_$Expr_DtypeColumnImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return dtypeColumn(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return dtypeColumn?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (dtypeColumn != null) {
      return dtypeColumn(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return dtypeColumn(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return dtypeColumn?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (dtypeColumn != null) {
      return dtypeColumn(this);
    }
    return orElse();
  }
}

abstract class Expr_DtypeColumn implements Expr {
  const factory Expr_DtypeColumn(final List<DataType> field0) =
      _$Expr_DtypeColumnImpl;

  List<DataType> get field0;
  @JsonKey(ignore: true)
  _$$Expr_DtypeColumnImplCopyWith<_$Expr_DtypeColumnImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_LiteralImplCopyWith<$Res> {
  factory _$$Expr_LiteralImplCopyWith(
          _$Expr_LiteralImpl value, $Res Function(_$Expr_LiteralImpl) then) =
      __$$Expr_LiteralImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LiteralValue field0});

  $LiteralValueCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_LiteralImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_LiteralImpl>
    implements _$$Expr_LiteralImplCopyWith<$Res> {
  __$$Expr_LiteralImplCopyWithImpl(
      _$Expr_LiteralImpl _value, $Res Function(_$Expr_LiteralImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_LiteralImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as LiteralValue,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LiteralValueCopyWith<$Res> get field0 {
    return $LiteralValueCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_LiteralImpl implements Expr_Literal {
  const _$Expr_LiteralImpl(this.field0);

  @override
  final LiteralValue field0;

  @override
  String toString() {
    return 'Expr.literal(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_LiteralImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_LiteralImplCopyWith<_$Expr_LiteralImpl> get copyWith =>
      __$$Expr_LiteralImplCopyWithImpl<_$Expr_LiteralImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return literal(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return literal?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (literal != null) {
      return literal(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return literal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return literal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (literal != null) {
      return literal(this);
    }
    return orElse();
  }
}

abstract class Expr_Literal implements Expr {
  const factory Expr_Literal(final LiteralValue field0) = _$Expr_LiteralImpl;

  LiteralValue get field0;
  @JsonKey(ignore: true)
  _$$Expr_LiteralImplCopyWith<_$Expr_LiteralImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_BinaryExprImplCopyWith<$Res> {
  factory _$$Expr_BinaryExprImplCopyWith(_$Expr_BinaryExprImpl value,
          $Res Function(_$Expr_BinaryExprImpl) then) =
      __$$Expr_BinaryExprImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr left, Operator op, Expr right});

  $ExprCopyWith<$Res> get left;
  $ExprCopyWith<$Res> get right;
}

/// @nodoc
class __$$Expr_BinaryExprImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_BinaryExprImpl>
    implements _$$Expr_BinaryExprImplCopyWith<$Res> {
  __$$Expr_BinaryExprImplCopyWithImpl(
      _$Expr_BinaryExprImpl _value, $Res Function(_$Expr_BinaryExprImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? left = null,
    Object? op = null,
    Object? right = null,
  }) {
    return _then(_$Expr_BinaryExprImpl(
      left: null == left
          ? _value.left
          : left // ignore: cast_nullable_to_non_nullable
              as Expr,
      op: null == op
          ? _value.op
          : op // ignore: cast_nullable_to_non_nullable
              as Operator,
      right: null == right
          ? _value.right
          : right // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get left {
    return $ExprCopyWith<$Res>(_value.left, (value) {
      return _then(_value.copyWith(left: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get right {
    return $ExprCopyWith<$Res>(_value.right, (value) {
      return _then(_value.copyWith(right: value));
    });
  }
}

/// @nodoc

class _$Expr_BinaryExprImpl implements Expr_BinaryExpr {
  const _$Expr_BinaryExprImpl(
      {required this.left, required this.op, required this.right});

  /// The left-hand side column.
  @override
  final Expr left;

  /// The operator, e.g. ==, >, <.
  @override
  final Operator op;

  /// The right-hand side column.
  @override
  final Expr right;

  @override
  String toString() {
    return 'Expr.binaryExpr(left: $left, op: $op, right: $right)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_BinaryExprImpl &&
            (identical(other.left, left) || other.left == left) &&
            (identical(other.op, op) || other.op == op) &&
            (identical(other.right, right) || other.right == right));
  }

  @override
  int get hashCode => Object.hash(runtimeType, left, op, right);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_BinaryExprImplCopyWith<_$Expr_BinaryExprImpl> get copyWith =>
      __$$Expr_BinaryExprImplCopyWithImpl<_$Expr_BinaryExprImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return binaryExpr(left, op, right);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return binaryExpr?.call(left, op, right);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (binaryExpr != null) {
      return binaryExpr(left, op, right);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return binaryExpr(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return binaryExpr?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (binaryExpr != null) {
      return binaryExpr(this);
    }
    return orElse();
  }
}

abstract class Expr_BinaryExpr implements Expr {
  const factory Expr_BinaryExpr(
      {required final Expr left,
      required final Operator op,
      required final Expr right}) = _$Expr_BinaryExprImpl;

  /// The left-hand side column.
  Expr get left;

  /// The operator, e.g. ==, >, <.
  Operator get op;

  /// The right-hand side column.
  Expr get right;
  @JsonKey(ignore: true)
  _$$Expr_BinaryExprImplCopyWith<_$Expr_BinaryExprImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_CastImplCopyWith<$Res> {
  factory _$$Expr_CastImplCopyWith(
          _$Expr_CastImpl value, $Res Function(_$Expr_CastImpl) then) =
      __$$Expr_CastImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr expr, DataType dataType, bool strict});

  $ExprCopyWith<$Res> get expr;
  $DataTypeCopyWith<$Res> get dataType;
}

/// @nodoc
class __$$Expr_CastImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_CastImpl>
    implements _$$Expr_CastImplCopyWith<$Res> {
  __$$Expr_CastImplCopyWithImpl(
      _$Expr_CastImpl _value, $Res Function(_$Expr_CastImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expr = null,
    Object? dataType = null,
    Object? strict = null,
  }) {
    return _then(_$Expr_CastImpl(
      expr: null == expr
          ? _value.expr
          : expr // ignore: cast_nullable_to_non_nullable
              as Expr,
      dataType: null == dataType
          ? _value.dataType
          : dataType // ignore: cast_nullable_to_non_nullable
              as DataType,
      strict: null == strict
          ? _value.strict
          : strict // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get expr {
    return $ExprCopyWith<$Res>(_value.expr, (value) {
      return _then(_value.copyWith(expr: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get dataType {
    return $DataTypeCopyWith<$Res>(_value.dataType, (value) {
      return _then(_value.copyWith(dataType: value));
    });
  }
}

/// @nodoc

class _$Expr_CastImpl implements Expr_Cast {
  const _$Expr_CastImpl(
      {required this.expr, required this.dataType, required this.strict});

  /// The column to be cast.
  @override
  final Expr expr;

  /// The new desired datatype.
  @override
  final DataType dataType;

  /// Whether incompatible values should be coerced.
  @override
  final bool strict;

  @override
  String toString() {
    return 'Expr.cast(expr: $expr, dataType: $dataType, strict: $strict)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_CastImpl &&
            (identical(other.expr, expr) || other.expr == expr) &&
            (identical(other.dataType, dataType) ||
                other.dataType == dataType) &&
            (identical(other.strict, strict) || other.strict == strict));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expr, dataType, strict);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_CastImplCopyWith<_$Expr_CastImpl> get copyWith =>
      __$$Expr_CastImplCopyWithImpl<_$Expr_CastImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return cast(expr, dataType, strict);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return cast?.call(expr, dataType, strict);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (cast != null) {
      return cast(expr, dataType, strict);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return cast(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return cast?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (cast != null) {
      return cast(this);
    }
    return orElse();
  }
}

abstract class Expr_Cast implements Expr {
  const factory Expr_Cast(
      {required final Expr expr,
      required final DataType dataType,
      required final bool strict}) = _$Expr_CastImpl;

  /// The column to be cast.
  Expr get expr;

  /// The new desired datatype.
  DataType get dataType;

  /// Whether incompatible values should be coerced.
  bool get strict;
  @JsonKey(ignore: true)
  _$$Expr_CastImplCopyWith<_$Expr_CastImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_SortImplCopyWith<$Res> {
  factory _$$Expr_SortImplCopyWith(
          _$Expr_SortImpl value, $Res Function(_$Expr_SortImpl) then) =
      __$$Expr_SortImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr expr, SortOptions options});

  $ExprCopyWith<$Res> get expr;
}

/// @nodoc
class __$$Expr_SortImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_SortImpl>
    implements _$$Expr_SortImplCopyWith<$Res> {
  __$$Expr_SortImplCopyWithImpl(
      _$Expr_SortImpl _value, $Res Function(_$Expr_SortImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expr = null,
    Object? options = null,
  }) {
    return _then(_$Expr_SortImpl(
      expr: null == expr
          ? _value.expr
          : expr // ignore: cast_nullable_to_non_nullable
              as Expr,
      options: null == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as SortOptions,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get expr {
    return $ExprCopyWith<$Res>(_value.expr, (value) {
      return _then(_value.copyWith(expr: value));
    });
  }
}

/// @nodoc

class _$Expr_SortImpl implements Expr_Sort {
  const _$Expr_SortImpl({required this.expr, required this.options});

  /// The column to be sorted.
  @override
  final Expr expr;

  /// Options for sorting.
  @override
  final SortOptions options;

  @override
  String toString() {
    return 'Expr.sort(expr: $expr, options: $options)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_SortImpl &&
            (identical(other.expr, expr) || other.expr == expr) &&
            (identical(other.options, options) || other.options == options));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expr, options);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_SortImplCopyWith<_$Expr_SortImpl> get copyWith =>
      __$$Expr_SortImplCopyWithImpl<_$Expr_SortImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return sort(expr, options);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return sort?.call(expr, options);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (sort != null) {
      return sort(expr, options);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return sort(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return sort?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (sort != null) {
      return sort(this);
    }
    return orElse();
  }
}

abstract class Expr_Sort implements Expr {
  const factory Expr_Sort(
      {required final Expr expr,
      required final SortOptions options}) = _$Expr_SortImpl;

  /// The column to be sorted.
  Expr get expr;

  /// Options for sorting.
  SortOptions get options;
  @JsonKey(ignore: true)
  _$$Expr_SortImplCopyWith<_$Expr_SortImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_GatherImplCopyWith<$Res> {
  factory _$$Expr_GatherImplCopyWith(
          _$Expr_GatherImpl value, $Res Function(_$Expr_GatherImpl) then) =
      __$$Expr_GatherImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr expr, Expr idx, bool returnsScalar});

  $ExprCopyWith<$Res> get expr;
  $ExprCopyWith<$Res> get idx;
}

/// @nodoc
class __$$Expr_GatherImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_GatherImpl>
    implements _$$Expr_GatherImplCopyWith<$Res> {
  __$$Expr_GatherImplCopyWithImpl(
      _$Expr_GatherImpl _value, $Res Function(_$Expr_GatherImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expr = null,
    Object? idx = null,
    Object? returnsScalar = null,
  }) {
    return _then(_$Expr_GatherImpl(
      expr: null == expr
          ? _value.expr
          : expr // ignore: cast_nullable_to_non_nullable
              as Expr,
      idx: null == idx
          ? _value.idx
          : idx // ignore: cast_nullable_to_non_nullable
              as Expr,
      returnsScalar: null == returnsScalar
          ? _value.returnsScalar
          : returnsScalar // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get expr {
    return $ExprCopyWith<$Res>(_value.expr, (value) {
      return _then(_value.copyWith(expr: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get idx {
    return $ExprCopyWith<$Res>(_value.idx, (value) {
      return _then(_value.copyWith(idx: value));
    });
  }
}

/// @nodoc

class _$Expr_GatherImpl implements Expr_Gather {
  const _$Expr_GatherImpl(
      {required this.expr, required this.idx, required this.returnsScalar});

  /// The column from which to take.
  @override
  final Expr expr;

  /// The index to take at.
  @override
  final Expr idx;
  @override
  final bool returnsScalar;

  @override
  String toString() {
    return 'Expr.gather(expr: $expr, idx: $idx, returnsScalar: $returnsScalar)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_GatherImpl &&
            (identical(other.expr, expr) || other.expr == expr) &&
            (identical(other.idx, idx) || other.idx == idx) &&
            (identical(other.returnsScalar, returnsScalar) ||
                other.returnsScalar == returnsScalar));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expr, idx, returnsScalar);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_GatherImplCopyWith<_$Expr_GatherImpl> get copyWith =>
      __$$Expr_GatherImplCopyWithImpl<_$Expr_GatherImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return gather(expr, idx, returnsScalar);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return gather?.call(expr, idx, returnsScalar);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (gather != null) {
      return gather(expr, idx, returnsScalar);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return gather(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return gather?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (gather != null) {
      return gather(this);
    }
    return orElse();
  }
}

abstract class Expr_Gather implements Expr {
  const factory Expr_Gather(
      {required final Expr expr,
      required final Expr idx,
      required final bool returnsScalar}) = _$Expr_GatherImpl;

  /// The column from which to take.
  Expr get expr;

  /// The index to take at.
  Expr get idx;
  bool get returnsScalar;
  @JsonKey(ignore: true)
  _$$Expr_GatherImplCopyWith<_$Expr_GatherImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_SortByImplCopyWith<$Res> {
  factory _$$Expr_SortByImplCopyWith(
          _$Expr_SortByImpl value, $Res Function(_$Expr_SortByImpl) then) =
      __$$Expr_SortByImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr expr, List<Expr> by, List<bool> descending});

  $ExprCopyWith<$Res> get expr;
}

/// @nodoc
class __$$Expr_SortByImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_SortByImpl>
    implements _$$Expr_SortByImplCopyWith<$Res> {
  __$$Expr_SortByImplCopyWithImpl(
      _$Expr_SortByImpl _value, $Res Function(_$Expr_SortByImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expr = null,
    Object? by = null,
    Object? descending = null,
  }) {
    return _then(_$Expr_SortByImpl(
      expr: null == expr
          ? _value.expr
          : expr // ignore: cast_nullable_to_non_nullable
              as Expr,
      by: null == by
          ? _value._by
          : by // ignore: cast_nullable_to_non_nullable
              as List<Expr>,
      descending: null == descending
          ? _value._descending
          : descending // ignore: cast_nullable_to_non_nullable
              as List<bool>,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get expr {
    return $ExprCopyWith<$Res>(_value.expr, (value) {
      return _then(_value.copyWith(expr: value));
    });
  }
}

/// @nodoc

class _$Expr_SortByImpl implements Expr_SortBy {
  const _$Expr_SortByImpl(
      {required this.expr,
      required final List<Expr> by,
      required final List<bool> descending})
      : _by = by,
        _descending = descending;

  @override
  final Expr expr;
  final List<Expr> _by;
  @override
  List<Expr> get by {
    if (_by is EqualUnmodifiableListView) return _by;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_by);
  }

  final List<bool> _descending;
  @override
  List<bool> get descending {
    if (_descending is EqualUnmodifiableListView) return _descending;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_descending);
  }

  @override
  String toString() {
    return 'Expr.sortBy(expr: $expr, by: $by, descending: $descending)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_SortByImpl &&
            (identical(other.expr, expr) || other.expr == expr) &&
            const DeepCollectionEquality().equals(other._by, _by) &&
            const DeepCollectionEquality()
                .equals(other._descending, _descending));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      expr,
      const DeepCollectionEquality().hash(_by),
      const DeepCollectionEquality().hash(_descending));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_SortByImplCopyWith<_$Expr_SortByImpl> get copyWith =>
      __$$Expr_SortByImplCopyWithImpl<_$Expr_SortByImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return sortBy(expr, by, descending);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return sortBy?.call(expr, by, descending);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (sortBy != null) {
      return sortBy(expr, by, descending);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return sortBy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return sortBy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (sortBy != null) {
      return sortBy(this);
    }
    return orElse();
  }
}

abstract class Expr_SortBy implements Expr {
  const factory Expr_SortBy(
      {required final Expr expr,
      required final List<Expr> by,
      required final List<bool> descending}) = _$Expr_SortByImpl;

  Expr get expr;
  List<Expr> get by;
  List<bool> get descending;
  @JsonKey(ignore: true)
  _$$Expr_SortByImplCopyWith<_$Expr_SortByImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_AggImplCopyWith<$Res> {
  factory _$$Expr_AggImplCopyWith(
          _$Expr_AggImpl value, $Res Function(_$Expr_AggImpl) then) =
      __$$Expr_AggImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AggExpr field0});

  $AggExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_AggImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_AggImpl>
    implements _$$Expr_AggImplCopyWith<$Res> {
  __$$Expr_AggImplCopyWithImpl(
      _$Expr_AggImpl _value, $Res Function(_$Expr_AggImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_AggImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as AggExpr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $AggExprCopyWith<$Res> get field0 {
    return $AggExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_AggImpl implements Expr_Agg {
  const _$Expr_AggImpl(this.field0);

  @override
  final AggExpr field0;

  @override
  String toString() {
    return 'Expr.agg(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_AggImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_AggImplCopyWith<_$Expr_AggImpl> get copyWith =>
      __$$Expr_AggImplCopyWithImpl<_$Expr_AggImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return agg(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return agg?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (agg != null) {
      return agg(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return agg(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return agg?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (agg != null) {
      return agg(this);
    }
    return orElse();
  }
}

abstract class Expr_Agg implements Expr {
  const factory Expr_Agg(final AggExpr field0) = _$Expr_AggImpl;

  AggExpr get field0;
  @JsonKey(ignore: true)
  _$$Expr_AggImplCopyWith<_$Expr_AggImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_TernaryImplCopyWith<$Res> {
  factory _$$Expr_TernaryImplCopyWith(
          _$Expr_TernaryImpl value, $Res Function(_$Expr_TernaryImpl) then) =
      __$$Expr_TernaryImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr predicate, Expr truthy, Expr falsy});

  $ExprCopyWith<$Res> get predicate;
  $ExprCopyWith<$Res> get truthy;
  $ExprCopyWith<$Res> get falsy;
}

/// @nodoc
class __$$Expr_TernaryImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_TernaryImpl>
    implements _$$Expr_TernaryImplCopyWith<$Res> {
  __$$Expr_TernaryImplCopyWithImpl(
      _$Expr_TernaryImpl _value, $Res Function(_$Expr_TernaryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? predicate = null,
    Object? truthy = null,
    Object? falsy = null,
  }) {
    return _then(_$Expr_TernaryImpl(
      predicate: null == predicate
          ? _value.predicate
          : predicate // ignore: cast_nullable_to_non_nullable
              as Expr,
      truthy: null == truthy
          ? _value.truthy
          : truthy // ignore: cast_nullable_to_non_nullable
              as Expr,
      falsy: null == falsy
          ? _value.falsy
          : falsy // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get predicate {
    return $ExprCopyWith<$Res>(_value.predicate, (value) {
      return _then(_value.copyWith(predicate: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get truthy {
    return $ExprCopyWith<$Res>(_value.truthy, (value) {
      return _then(_value.copyWith(truthy: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get falsy {
    return $ExprCopyWith<$Res>(_value.falsy, (value) {
      return _then(_value.copyWith(falsy: value));
    });
  }
}

/// @nodoc

class _$Expr_TernaryImpl implements Expr_Ternary {
  const _$Expr_TernaryImpl(
      {required this.predicate, required this.truthy, required this.falsy});

  /// The condition for this ternary.
  @override
  final Expr predicate;

  /// If `predicate` is true, evaluate to this.
  @override
  final Expr truthy;

  /// If `predicate` is false, evaluate to this.
  @override
  final Expr falsy;

  @override
  String toString() {
    return 'Expr.ternary(predicate: $predicate, truthy: $truthy, falsy: $falsy)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_TernaryImpl &&
            (identical(other.predicate, predicate) ||
                other.predicate == predicate) &&
            (identical(other.truthy, truthy) || other.truthy == truthy) &&
            (identical(other.falsy, falsy) || other.falsy == falsy));
  }

  @override
  int get hashCode => Object.hash(runtimeType, predicate, truthy, falsy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_TernaryImplCopyWith<_$Expr_TernaryImpl> get copyWith =>
      __$$Expr_TernaryImplCopyWithImpl<_$Expr_TernaryImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return ternary(predicate, truthy, falsy);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return ternary?.call(predicate, truthy, falsy);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (ternary != null) {
      return ternary(predicate, truthy, falsy);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return ternary(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return ternary?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (ternary != null) {
      return ternary(this);
    }
    return orElse();
  }
}

abstract class Expr_Ternary implements Expr {
  const factory Expr_Ternary(
      {required final Expr predicate,
      required final Expr truthy,
      required final Expr falsy}) = _$Expr_TernaryImpl;

  /// The condition for this ternary.
  Expr get predicate;

  /// If `predicate` is true, evaluate to this.
  Expr get truthy;

  /// If `predicate` is false, evaluate to this.
  Expr get falsy;
  @JsonKey(ignore: true)
  _$$Expr_TernaryImplCopyWith<_$Expr_TernaryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_ExplodeImplCopyWith<$Res> {
  factory _$$Expr_ExplodeImplCopyWith(
          _$Expr_ExplodeImpl value, $Res Function(_$Expr_ExplodeImpl) then) =
      __$$Expr_ExplodeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_ExplodeImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_ExplodeImpl>
    implements _$$Expr_ExplodeImplCopyWith<$Res> {
  __$$Expr_ExplodeImplCopyWithImpl(
      _$Expr_ExplodeImpl _value, $Res Function(_$Expr_ExplodeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_ExplodeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_ExplodeImpl implements Expr_Explode {
  const _$Expr_ExplodeImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'Expr.explode(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_ExplodeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_ExplodeImplCopyWith<_$Expr_ExplodeImpl> get copyWith =>
      __$$Expr_ExplodeImplCopyWithImpl<_$Expr_ExplodeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return explode(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return explode?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (explode != null) {
      return explode(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return explode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return explode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (explode != null) {
      return explode(this);
    }
    return orElse();
  }
}

abstract class Expr_Explode implements Expr {
  const factory Expr_Explode(final Expr field0) = _$Expr_ExplodeImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$Expr_ExplodeImplCopyWith<_$Expr_ExplodeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_FilterImplCopyWith<$Res> {
  factory _$$Expr_FilterImplCopyWith(
          _$Expr_FilterImpl value, $Res Function(_$Expr_FilterImpl) then) =
      __$$Expr_FilterImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr input, Expr by});

  $ExprCopyWith<$Res> get input;
  $ExprCopyWith<$Res> get by;
}

/// @nodoc
class __$$Expr_FilterImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_FilterImpl>
    implements _$$Expr_FilterImplCopyWith<$Res> {
  __$$Expr_FilterImplCopyWithImpl(
      _$Expr_FilterImpl _value, $Res Function(_$Expr_FilterImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? by = null,
  }) {
    return _then(_$Expr_FilterImpl(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as Expr,
      by: null == by
          ? _value.by
          : by // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get input {
    return $ExprCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get by {
    return $ExprCopyWith<$Res>(_value.by, (value) {
      return _then(_value.copyWith(by: value));
    });
  }
}

/// @nodoc

class _$Expr_FilterImpl implements Expr_Filter {
  const _$Expr_FilterImpl({required this.input, required this.by});

  /// The column to be filtered.
  @override
  final Expr input;

  /// The conditions by which this column should be filtered.
  @override
  final Expr by;

  @override
  String toString() {
    return 'Expr.filter(input: $input, by: $by)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_FilterImpl &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.by, by) || other.by == by));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input, by);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_FilterImplCopyWith<_$Expr_FilterImpl> get copyWith =>
      __$$Expr_FilterImplCopyWithImpl<_$Expr_FilterImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return filter(input, by);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return filter?.call(input, by);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (filter != null) {
      return filter(input, by);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return filter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return filter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (filter != null) {
      return filter(this);
    }
    return orElse();
  }
}

abstract class Expr_Filter implements Expr {
  const factory Expr_Filter(
      {required final Expr input, required final Expr by}) = _$Expr_FilterImpl;

  /// The column to be filtered.
  Expr get input;

  /// The conditions by which this column should be filtered.
  Expr get by;
  @JsonKey(ignore: true)
  _$$Expr_FilterImplCopyWith<_$Expr_FilterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_WindowImplCopyWith<$Res> {
  factory _$$Expr_WindowImplCopyWith(
          _$Expr_WindowImpl value, $Res Function(_$Expr_WindowImpl) then) =
      __$$Expr_WindowImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr function, List<Expr> partitionBy, WindowType options});

  $ExprCopyWith<$Res> get function;
  $WindowTypeCopyWith<$Res> get options;
}

/// @nodoc
class __$$Expr_WindowImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_WindowImpl>
    implements _$$Expr_WindowImplCopyWith<$Res> {
  __$$Expr_WindowImplCopyWithImpl(
      _$Expr_WindowImpl _value, $Res Function(_$Expr_WindowImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? function = null,
    Object? partitionBy = null,
    Object? options = null,
  }) {
    return _then(_$Expr_WindowImpl(
      function: null == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as Expr,
      partitionBy: null == partitionBy
          ? _value._partitionBy
          : partitionBy // ignore: cast_nullable_to_non_nullable
              as List<Expr>,
      options: null == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as WindowType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get function {
    return $ExprCopyWith<$Res>(_value.function, (value) {
      return _then(_value.copyWith(function: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $WindowTypeCopyWith<$Res> get options {
    return $WindowTypeCopyWith<$Res>(_value.options, (value) {
      return _then(_value.copyWith(options: value));
    });
  }
}

/// @nodoc

class _$Expr_WindowImpl implements Expr_Window {
  const _$Expr_WindowImpl(
      {required this.function,
      required final List<Expr> partitionBy,
      required this.options})
      : _partitionBy = partitionBy;

  /// Also has the input. i.e. avg("foo")
  @override
  final Expr function;
  final List<Expr> _partitionBy;
  @override
  List<Expr> get partitionBy {
    if (_partitionBy is EqualUnmodifiableListView) return _partitionBy;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_partitionBy);
  }

  @override
  final WindowType options;

  @override
  String toString() {
    return 'Expr.window(function: $function, partitionBy: $partitionBy, options: $options)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_WindowImpl &&
            (identical(other.function, function) ||
                other.function == function) &&
            const DeepCollectionEquality()
                .equals(other._partitionBy, _partitionBy) &&
            (identical(other.options, options) || other.options == options));
  }

  @override
  int get hashCode => Object.hash(runtimeType, function,
      const DeepCollectionEquality().hash(_partitionBy), options);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_WindowImplCopyWith<_$Expr_WindowImpl> get copyWith =>
      __$$Expr_WindowImplCopyWithImpl<_$Expr_WindowImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return window(function, partitionBy, options);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return window?.call(function, partitionBy, options);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (window != null) {
      return window(function, partitionBy, options);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return window(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return window?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (window != null) {
      return window(this);
    }
    return orElse();
  }
}

abstract class Expr_Window implements Expr {
  const factory Expr_Window(
      {required final Expr function,
      required final List<Expr> partitionBy,
      required final WindowType options}) = _$Expr_WindowImpl;

  /// Also has the input. i.e. avg("foo")
  Expr get function;
  List<Expr> get partitionBy;
  WindowType get options;
  @JsonKey(ignore: true)
  _$$Expr_WindowImplCopyWith<_$Expr_WindowImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_WildcardImplCopyWith<$Res> {
  factory _$$Expr_WildcardImplCopyWith(
          _$Expr_WildcardImpl value, $Res Function(_$Expr_WildcardImpl) then) =
      __$$Expr_WildcardImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Expr_WildcardImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_WildcardImpl>
    implements _$$Expr_WildcardImplCopyWith<$Res> {
  __$$Expr_WildcardImplCopyWithImpl(
      _$Expr_WildcardImpl _value, $Res Function(_$Expr_WildcardImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Expr_WildcardImpl implements Expr_Wildcard {
  const _$Expr_WildcardImpl();

  @override
  String toString() {
    return 'Expr.wildcard()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Expr_WildcardImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return wildcard();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return wildcard?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (wildcard != null) {
      return wildcard();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return wildcard(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return wildcard?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (wildcard != null) {
      return wildcard(this);
    }
    return orElse();
  }
}

abstract class Expr_Wildcard implements Expr {
  const factory Expr_Wildcard() = _$Expr_WildcardImpl;
}

/// @nodoc
abstract class _$$Expr_SliceImplCopyWith<$Res> {
  factory _$$Expr_SliceImplCopyWith(
          _$Expr_SliceImpl value, $Res Function(_$Expr_SliceImpl) then) =
      __$$Expr_SliceImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr input, Expr offset, Expr length});

  $ExprCopyWith<$Res> get input;
  $ExprCopyWith<$Res> get offset;
  $ExprCopyWith<$Res> get length;
}

/// @nodoc
class __$$Expr_SliceImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_SliceImpl>
    implements _$$Expr_SliceImplCopyWith<$Res> {
  __$$Expr_SliceImplCopyWithImpl(
      _$Expr_SliceImpl _value, $Res Function(_$Expr_SliceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
    Object? offset = null,
    Object? length = null,
  }) {
    return _then(_$Expr_SliceImpl(
      input: null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as Expr,
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as Expr,
      length: null == length
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get input {
    return $ExprCopyWith<$Res>(_value.input, (value) {
      return _then(_value.copyWith(input: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get offset {
    return $ExprCopyWith<$Res>(_value.offset, (value) {
      return _then(_value.copyWith(offset: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get length {
    return $ExprCopyWith<$Res>(_value.length, (value) {
      return _then(_value.copyWith(length: value));
    });
  }
}

/// @nodoc

class _$Expr_SliceImpl implements Expr_Slice {
  const _$Expr_SliceImpl(
      {required this.input, required this.offset, required this.length});

  /// The column to take slices of.
  @override
  final Expr input;

  /// Length is not yet known so we accept negative offsets
  @override
  final Expr offset;

  /// How long the slice should be.
  @override
  final Expr length;

  @override
  String toString() {
    return 'Expr.slice(input: $input, offset: $offset, length: $length)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_SliceImpl &&
            (identical(other.input, input) || other.input == input) &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.length, length) || other.length == length));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input, offset, length);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_SliceImplCopyWith<_$Expr_SliceImpl> get copyWith =>
      __$$Expr_SliceImplCopyWithImpl<_$Expr_SliceImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return slice(input, offset, length);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return slice?.call(input, offset, length);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (slice != null) {
      return slice(input, offset, length);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return slice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return slice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (slice != null) {
      return slice(this);
    }
    return orElse();
  }
}

abstract class Expr_Slice implements Expr {
  const factory Expr_Slice(
      {required final Expr input,
      required final Expr offset,
      required final Expr length}) = _$Expr_SliceImpl;

  /// The column to take slices of.
  Expr get input;

  /// Length is not yet known so we accept negative offsets
  Expr get offset;

  /// How long the slice should be.
  Expr get length;
  @JsonKey(ignore: true)
  _$$Expr_SliceImplCopyWith<_$Expr_SliceImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_ExcludeImplCopyWith<$Res> {
  factory _$$Expr_ExcludeImplCopyWith(
          _$Expr_ExcludeImpl value, $Res Function(_$Expr_ExcludeImpl) then) =
      __$$Expr_ExcludeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0, List<Excluded> field1});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_ExcludeImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_ExcludeImpl>
    implements _$$Expr_ExcludeImplCopyWith<$Res> {
  __$$Expr_ExcludeImplCopyWithImpl(
      _$Expr_ExcludeImpl _value, $Res Function(_$Expr_ExcludeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$Expr_ExcludeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
      null == field1
          ? _value._field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as List<Excluded>,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_ExcludeImpl implements Expr_Exclude {
  const _$Expr_ExcludeImpl(this.field0, final List<Excluded> field1)
      : _field1 = field1;

  @override
  final Expr field0;
  final List<Excluded> _field1;
  @override
  List<Excluded> get field1 {
    if (_field1 is EqualUnmodifiableListView) return _field1;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field1);
  }

  @override
  String toString() {
    return 'Expr.exclude(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_ExcludeImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            const DeepCollectionEquality().equals(other._field1, _field1));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, field0, const DeepCollectionEquality().hash(_field1));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_ExcludeImplCopyWith<_$Expr_ExcludeImpl> get copyWith =>
      __$$Expr_ExcludeImplCopyWithImpl<_$Expr_ExcludeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return exclude(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return exclude?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (exclude != null) {
      return exclude(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return exclude(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return exclude?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (exclude != null) {
      return exclude(this);
    }
    return orElse();
  }
}

abstract class Expr_Exclude implements Expr {
  const factory Expr_Exclude(final Expr field0, final List<Excluded> field1) =
      _$Expr_ExcludeImpl;

  Expr get field0;
  List<Excluded> get field1;
  @JsonKey(ignore: true)
  _$$Expr_ExcludeImplCopyWith<_$Expr_ExcludeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_KeepNameImplCopyWith<$Res> {
  factory _$$Expr_KeepNameImplCopyWith(
          _$Expr_KeepNameImpl value, $Res Function(_$Expr_KeepNameImpl) then) =
      __$$Expr_KeepNameImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Expr field0});

  $ExprCopyWith<$Res> get field0;
}

/// @nodoc
class __$$Expr_KeepNameImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_KeepNameImpl>
    implements _$$Expr_KeepNameImplCopyWith<$Res> {
  __$$Expr_KeepNameImplCopyWithImpl(
      _$Expr_KeepNameImpl _value, $Res Function(_$Expr_KeepNameImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_KeepNameImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Expr,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $ExprCopyWith<$Res> get field0 {
    return $ExprCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$Expr_KeepNameImpl implements Expr_KeepName {
  const _$Expr_KeepNameImpl(this.field0);

  @override
  final Expr field0;

  @override
  String toString() {
    return 'Expr.keepName(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_KeepNameImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_KeepNameImplCopyWith<_$Expr_KeepNameImpl> get copyWith =>
      __$$Expr_KeepNameImplCopyWithImpl<_$Expr_KeepNameImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return keepName(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return keepName?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (keepName != null) {
      return keepName(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return keepName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return keepName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (keepName != null) {
      return keepName(this);
    }
    return orElse();
  }
}

abstract class Expr_KeepName implements Expr {
  const factory Expr_KeepName(final Expr field0) = _$Expr_KeepNameImpl;

  Expr get field0;
  @JsonKey(ignore: true)
  _$$Expr_KeepNameImplCopyWith<_$Expr_KeepNameImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Expr_CountImplCopyWith<$Res> {
  factory _$$Expr_CountImplCopyWith(
          _$Expr_CountImpl value, $Res Function(_$Expr_CountImpl) then) =
      __$$Expr_CountImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$Expr_CountImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_CountImpl>
    implements _$$Expr_CountImplCopyWith<$Res> {
  __$$Expr_CountImplCopyWithImpl(
      _$Expr_CountImpl _value, $Res Function(_$Expr_CountImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$Expr_CountImpl implements Expr_Count {
  const _$Expr_CountImpl();

  @override
  String toString() {
    return 'Expr.count()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$Expr_CountImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return count();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return count?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (count != null) {
      return count();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return count(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return count?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (count != null) {
      return count(this);
    }
    return orElse();
  }
}

abstract class Expr_Count implements Expr {
  const factory Expr_Count() = _$Expr_CountImpl;
}

/// @nodoc
abstract class _$$Expr_NthImplCopyWith<$Res> {
  factory _$$Expr_NthImplCopyWith(
          _$Expr_NthImpl value, $Res Function(_$Expr_NthImpl) then) =
      __$$Expr_NthImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$Expr_NthImplCopyWithImpl<$Res>
    extends _$ExprCopyWithImpl<$Res, _$Expr_NthImpl>
    implements _$$Expr_NthImplCopyWith<$Res> {
  __$$Expr_NthImplCopyWithImpl(
      _$Expr_NthImpl _value, $Res Function(_$Expr_NthImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Expr_NthImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$Expr_NthImpl implements Expr_Nth {
  const _$Expr_NthImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'Expr.nth(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Expr_NthImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Expr_NthImplCopyWith<_$Expr_NthImpl> get copyWith =>
      __$$Expr_NthImplCopyWithImpl<_$Expr_NthImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Expr field0, String field1) alias,
    required TResult Function(String field0) column,
    required TResult Function(List<String> field0) columns,
    required TResult Function(List<DataType> field0) dtypeColumn,
    required TResult Function(LiteralValue field0) literal,
    required TResult Function(Expr left, Operator op, Expr right) binaryExpr,
    required TResult Function(Expr expr, DataType dataType, bool strict) cast,
    required TResult Function(Expr expr, SortOptions options) sort,
    required TResult Function(Expr expr, Expr idx, bool returnsScalar) gather,
    required TResult Function(Expr expr, List<Expr> by, List<bool> descending)
        sortBy,
    required TResult Function(AggExpr field0) agg,
    required TResult Function(Expr predicate, Expr truthy, Expr falsy) ternary,
    required TResult Function(Expr field0) explode,
    required TResult Function(Expr input, Expr by) filter,
    required TResult Function(
            Expr function, List<Expr> partitionBy, WindowType options)
        window,
    required TResult Function() wildcard,
    required TResult Function(Expr input, Expr offset, Expr length) slice,
    required TResult Function(Expr field0, List<Excluded> field1) exclude,
    required TResult Function(Expr field0) keepName,
    required TResult Function() count,
    required TResult Function(int field0) nth,
  }) {
    return nth(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Expr field0, String field1)? alias,
    TResult? Function(String field0)? column,
    TResult? Function(List<String> field0)? columns,
    TResult? Function(List<DataType> field0)? dtypeColumn,
    TResult? Function(LiteralValue field0)? literal,
    TResult? Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult? Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult? Function(Expr expr, SortOptions options)? sort,
    TResult? Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult? Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult? Function(AggExpr field0)? agg,
    TResult? Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult? Function(Expr field0)? explode,
    TResult? Function(Expr input, Expr by)? filter,
    TResult? Function(
            Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult? Function()? wildcard,
    TResult? Function(Expr input, Expr offset, Expr length)? slice,
    TResult? Function(Expr field0, List<Excluded> field1)? exclude,
    TResult? Function(Expr field0)? keepName,
    TResult? Function()? count,
    TResult? Function(int field0)? nth,
  }) {
    return nth?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Expr field0, String field1)? alias,
    TResult Function(String field0)? column,
    TResult Function(List<String> field0)? columns,
    TResult Function(List<DataType> field0)? dtypeColumn,
    TResult Function(LiteralValue field0)? literal,
    TResult Function(Expr left, Operator op, Expr right)? binaryExpr,
    TResult Function(Expr expr, DataType dataType, bool strict)? cast,
    TResult Function(Expr expr, SortOptions options)? sort,
    TResult Function(Expr expr, Expr idx, bool returnsScalar)? gather,
    TResult Function(Expr expr, List<Expr> by, List<bool> descending)? sortBy,
    TResult Function(AggExpr field0)? agg,
    TResult Function(Expr predicate, Expr truthy, Expr falsy)? ternary,
    TResult Function(Expr field0)? explode,
    TResult Function(Expr input, Expr by)? filter,
    TResult Function(Expr function, List<Expr> partitionBy, WindowType options)?
        window,
    TResult Function()? wildcard,
    TResult Function(Expr input, Expr offset, Expr length)? slice,
    TResult Function(Expr field0, List<Excluded> field1)? exclude,
    TResult Function(Expr field0)? keepName,
    TResult Function()? count,
    TResult Function(int field0)? nth,
    required TResult orElse(),
  }) {
    if (nth != null) {
      return nth(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Expr_Alias value) alias,
    required TResult Function(Expr_Column value) column,
    required TResult Function(Expr_Columns value) columns,
    required TResult Function(Expr_DtypeColumn value) dtypeColumn,
    required TResult Function(Expr_Literal value) literal,
    required TResult Function(Expr_BinaryExpr value) binaryExpr,
    required TResult Function(Expr_Cast value) cast,
    required TResult Function(Expr_Sort value) sort,
    required TResult Function(Expr_Gather value) gather,
    required TResult Function(Expr_SortBy value) sortBy,
    required TResult Function(Expr_Agg value) agg,
    required TResult Function(Expr_Ternary value) ternary,
    required TResult Function(Expr_Explode value) explode,
    required TResult Function(Expr_Filter value) filter,
    required TResult Function(Expr_Window value) window,
    required TResult Function(Expr_Wildcard value) wildcard,
    required TResult Function(Expr_Slice value) slice,
    required TResult Function(Expr_Exclude value) exclude,
    required TResult Function(Expr_KeepName value) keepName,
    required TResult Function(Expr_Count value) count,
    required TResult Function(Expr_Nth value) nth,
  }) {
    return nth(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Expr_Alias value)? alias,
    TResult? Function(Expr_Column value)? column,
    TResult? Function(Expr_Columns value)? columns,
    TResult? Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult? Function(Expr_Literal value)? literal,
    TResult? Function(Expr_BinaryExpr value)? binaryExpr,
    TResult? Function(Expr_Cast value)? cast,
    TResult? Function(Expr_Sort value)? sort,
    TResult? Function(Expr_Gather value)? gather,
    TResult? Function(Expr_SortBy value)? sortBy,
    TResult? Function(Expr_Agg value)? agg,
    TResult? Function(Expr_Ternary value)? ternary,
    TResult? Function(Expr_Explode value)? explode,
    TResult? Function(Expr_Filter value)? filter,
    TResult? Function(Expr_Window value)? window,
    TResult? Function(Expr_Wildcard value)? wildcard,
    TResult? Function(Expr_Slice value)? slice,
    TResult? Function(Expr_Exclude value)? exclude,
    TResult? Function(Expr_KeepName value)? keepName,
    TResult? Function(Expr_Count value)? count,
    TResult? Function(Expr_Nth value)? nth,
  }) {
    return nth?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Expr_Alias value)? alias,
    TResult Function(Expr_Column value)? column,
    TResult Function(Expr_Columns value)? columns,
    TResult Function(Expr_DtypeColumn value)? dtypeColumn,
    TResult Function(Expr_Literal value)? literal,
    TResult Function(Expr_BinaryExpr value)? binaryExpr,
    TResult Function(Expr_Cast value)? cast,
    TResult Function(Expr_Sort value)? sort,
    TResult Function(Expr_Gather value)? gather,
    TResult Function(Expr_SortBy value)? sortBy,
    TResult Function(Expr_Agg value)? agg,
    TResult Function(Expr_Ternary value)? ternary,
    TResult Function(Expr_Explode value)? explode,
    TResult Function(Expr_Filter value)? filter,
    TResult Function(Expr_Window value)? window,
    TResult Function(Expr_Wildcard value)? wildcard,
    TResult Function(Expr_Slice value)? slice,
    TResult Function(Expr_Exclude value)? exclude,
    TResult Function(Expr_KeepName value)? keepName,
    TResult Function(Expr_Count value)? count,
    TResult Function(Expr_Nth value)? nth,
    required TResult orElse(),
  }) {
    if (nth != null) {
      return nth(this);
    }
    return orElse();
  }
}

abstract class Expr_Nth implements Expr {
  const factory Expr_Nth(final int field0) = _$Expr_NthImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$Expr_NthImplCopyWith<_$Expr_NthImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LiteralValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LiteralValueCopyWith<$Res> {
  factory $LiteralValueCopyWith(
          LiteralValue value, $Res Function(LiteralValue) then) =
      _$LiteralValueCopyWithImpl<$Res, LiteralValue>;
}

/// @nodoc
class _$LiteralValueCopyWithImpl<$Res, $Val extends LiteralValue>
    implements $LiteralValueCopyWith<$Res> {
  _$LiteralValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$LiteralValue_NullImplCopyWith<$Res> {
  factory _$$LiteralValue_NullImplCopyWith(_$LiteralValue_NullImpl value,
          $Res Function(_$LiteralValue_NullImpl) then) =
      __$$LiteralValue_NullImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LiteralValue_NullImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_NullImpl>
    implements _$$LiteralValue_NullImplCopyWith<$Res> {
  __$$LiteralValue_NullImplCopyWithImpl(_$LiteralValue_NullImpl _value,
      $Res Function(_$LiteralValue_NullImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LiteralValue_NullImpl implements LiteralValue_Null {
  const _$LiteralValue_NullImpl();

  @override
  String toString() {
    return 'LiteralValue.Null()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LiteralValue_NullImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return Null();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return Null?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (Null != null) {
      return Null();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return Null(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return Null?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (Null != null) {
      return Null(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Null implements LiteralValue {
  const factory LiteralValue_Null() = _$LiteralValue_NullImpl;
}

/// @nodoc
abstract class _$$LiteralValue_BooleanImplCopyWith<$Res> {
  factory _$$LiteralValue_BooleanImplCopyWith(_$LiteralValue_BooleanImpl value,
          $Res Function(_$LiteralValue_BooleanImpl) then) =
      __$$LiteralValue_BooleanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool field0});
}

/// @nodoc
class __$$LiteralValue_BooleanImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_BooleanImpl>
    implements _$$LiteralValue_BooleanImplCopyWith<$Res> {
  __$$LiteralValue_BooleanImplCopyWithImpl(_$LiteralValue_BooleanImpl _value,
      $Res Function(_$LiteralValue_BooleanImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_BooleanImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$LiteralValue_BooleanImpl implements LiteralValue_Boolean {
  const _$LiteralValue_BooleanImpl(this.field0);

  @override
  final bool field0;

  @override
  String toString() {
    return 'LiteralValue.boolean(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_BooleanImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_BooleanImplCopyWith<_$LiteralValue_BooleanImpl>
      get copyWith =>
          __$$LiteralValue_BooleanImplCopyWithImpl<_$LiteralValue_BooleanImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return boolean(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return boolean?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Boolean implements LiteralValue {
  const factory LiteralValue_Boolean(final bool field0) =
      _$LiteralValue_BooleanImpl;

  bool get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_BooleanImplCopyWith<_$LiteralValue_BooleanImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Utf8ImplCopyWith<$Res> {
  factory _$$LiteralValue_Utf8ImplCopyWith(_$LiteralValue_Utf8Impl value,
          $Res Function(_$LiteralValue_Utf8Impl) then) =
      __$$LiteralValue_Utf8ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$LiteralValue_Utf8ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Utf8Impl>
    implements _$$LiteralValue_Utf8ImplCopyWith<$Res> {
  __$$LiteralValue_Utf8ImplCopyWithImpl(_$LiteralValue_Utf8Impl _value,
      $Res Function(_$LiteralValue_Utf8Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Utf8Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Utf8Impl implements LiteralValue_Utf8 {
  const _$LiteralValue_Utf8Impl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'LiteralValue.utf8(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Utf8Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Utf8ImplCopyWith<_$LiteralValue_Utf8Impl> get copyWith =>
      __$$LiteralValue_Utf8ImplCopyWithImpl<_$LiteralValue_Utf8Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return utf8(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return utf8?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return utf8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return utf8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (utf8 != null) {
      return utf8(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Utf8 implements LiteralValue {
  const factory LiteralValue_Utf8(final String field0) =
      _$LiteralValue_Utf8Impl;

  String get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Utf8ImplCopyWith<_$LiteralValue_Utf8Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_BinaryImplCopyWith<$Res> {
  factory _$$LiteralValue_BinaryImplCopyWith(_$LiteralValue_BinaryImpl value,
          $Res Function(_$LiteralValue_BinaryImpl) then) =
      __$$LiteralValue_BinaryImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$LiteralValue_BinaryImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_BinaryImpl>
    implements _$$LiteralValue_BinaryImplCopyWith<$Res> {
  __$$LiteralValue_BinaryImplCopyWithImpl(_$LiteralValue_BinaryImpl _value,
      $Res Function(_$LiteralValue_BinaryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_BinaryImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$LiteralValue_BinaryImpl implements LiteralValue_Binary {
  const _$LiteralValue_BinaryImpl(this.field0);

  @override
  final Uint8List field0;

  @override
  String toString() {
    return 'LiteralValue.binary(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_BinaryImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_BinaryImplCopyWith<_$LiteralValue_BinaryImpl> get copyWith =>
      __$$LiteralValue_BinaryImplCopyWithImpl<_$LiteralValue_BinaryImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return binary(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return binary?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return binary(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return binary?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Binary implements LiteralValue {
  const factory LiteralValue_Binary(final Uint8List field0) =
      _$LiteralValue_BinaryImpl;

  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_BinaryImplCopyWith<_$LiteralValue_BinaryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt8ImplCopyWith<$Res> {
  factory _$$LiteralValue_UInt8ImplCopyWith(_$LiteralValue_UInt8Impl value,
          $Res Function(_$LiteralValue_UInt8Impl) then) =
      __$$LiteralValue_UInt8ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt8ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt8Impl>
    implements _$$LiteralValue_UInt8ImplCopyWith<$Res> {
  __$$LiteralValue_UInt8ImplCopyWithImpl(_$LiteralValue_UInt8Impl _value,
      $Res Function(_$LiteralValue_UInt8Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt8Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt8Impl implements LiteralValue_UInt8 {
  const _$LiteralValue_UInt8Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt8(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt8Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt8ImplCopyWith<_$LiteralValue_UInt8Impl> get copyWith =>
      __$$LiteralValue_UInt8ImplCopyWithImpl<_$LiteralValue_UInt8Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return uInt8(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return uInt8?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return uInt8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return uInt8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (uInt8 != null) {
      return uInt8(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt8 implements LiteralValue {
  const factory LiteralValue_UInt8(final int field0) = _$LiteralValue_UInt8Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt8ImplCopyWith<_$LiteralValue_UInt8Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt16ImplCopyWith<$Res> {
  factory _$$LiteralValue_UInt16ImplCopyWith(_$LiteralValue_UInt16Impl value,
          $Res Function(_$LiteralValue_UInt16Impl) then) =
      __$$LiteralValue_UInt16ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt16ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt16Impl>
    implements _$$LiteralValue_UInt16ImplCopyWith<$Res> {
  __$$LiteralValue_UInt16ImplCopyWithImpl(_$LiteralValue_UInt16Impl _value,
      $Res Function(_$LiteralValue_UInt16Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt16Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt16Impl implements LiteralValue_UInt16 {
  const _$LiteralValue_UInt16Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt16(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt16Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt16ImplCopyWith<_$LiteralValue_UInt16Impl> get copyWith =>
      __$$LiteralValue_UInt16ImplCopyWithImpl<_$LiteralValue_UInt16Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return uInt16(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return uInt16?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return uInt16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return uInt16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (uInt16 != null) {
      return uInt16(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt16 implements LiteralValue {
  const factory LiteralValue_UInt16(final int field0) =
      _$LiteralValue_UInt16Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt16ImplCopyWith<_$LiteralValue_UInt16Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt32ImplCopyWith<$Res> {
  factory _$$LiteralValue_UInt32ImplCopyWith(_$LiteralValue_UInt32Impl value,
          $Res Function(_$LiteralValue_UInt32Impl) then) =
      __$$LiteralValue_UInt32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt32ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt32Impl>
    implements _$$LiteralValue_UInt32ImplCopyWith<$Res> {
  __$$LiteralValue_UInt32ImplCopyWithImpl(_$LiteralValue_UInt32Impl _value,
      $Res Function(_$LiteralValue_UInt32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt32Impl implements LiteralValue_UInt32 {
  const _$LiteralValue_UInt32Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt32ImplCopyWith<_$LiteralValue_UInt32Impl> get copyWith =>
      __$$LiteralValue_UInt32ImplCopyWithImpl<_$LiteralValue_UInt32Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return uInt32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return uInt32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return uInt32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return uInt32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (uInt32 != null) {
      return uInt32(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt32 implements LiteralValue {
  const factory LiteralValue_UInt32(final int field0) =
      _$LiteralValue_UInt32Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt32ImplCopyWith<_$LiteralValue_UInt32Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_UInt64ImplCopyWith<$Res> {
  factory _$$LiteralValue_UInt64ImplCopyWith(_$LiteralValue_UInt64Impl value,
          $Res Function(_$LiteralValue_UInt64Impl) then) =
      __$$LiteralValue_UInt64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_UInt64ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_UInt64Impl>
    implements _$$LiteralValue_UInt64ImplCopyWith<$Res> {
  __$$LiteralValue_UInt64ImplCopyWithImpl(_$LiteralValue_UInt64Impl _value,
      $Res Function(_$LiteralValue_UInt64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_UInt64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_UInt64Impl implements LiteralValue_UInt64 {
  const _$LiteralValue_UInt64Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.uInt64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_UInt64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_UInt64ImplCopyWith<_$LiteralValue_UInt64Impl> get copyWith =>
      __$$LiteralValue_UInt64ImplCopyWithImpl<_$LiteralValue_UInt64Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return uInt64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return uInt64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return uInt64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return uInt64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (uInt64 != null) {
      return uInt64(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_UInt64 implements LiteralValue {
  const factory LiteralValue_UInt64(final int field0) =
      _$LiteralValue_UInt64Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_UInt64ImplCopyWith<_$LiteralValue_UInt64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int8ImplCopyWith<$Res> {
  factory _$$LiteralValue_Int8ImplCopyWith(_$LiteralValue_Int8Impl value,
          $Res Function(_$LiteralValue_Int8Impl) then) =
      __$$LiteralValue_Int8ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int8ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int8Impl>
    implements _$$LiteralValue_Int8ImplCopyWith<$Res> {
  __$$LiteralValue_Int8ImplCopyWithImpl(_$LiteralValue_Int8Impl _value,
      $Res Function(_$LiteralValue_Int8Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int8Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int8Impl implements LiteralValue_Int8 {
  const _$LiteralValue_Int8Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int8(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int8Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int8ImplCopyWith<_$LiteralValue_Int8Impl> get copyWith =>
      __$$LiteralValue_Int8ImplCopyWithImpl<_$LiteralValue_Int8Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return int8(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return int8?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return int8(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return int8?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (int8 != null) {
      return int8(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int8 implements LiteralValue {
  const factory LiteralValue_Int8(final int field0) = _$LiteralValue_Int8Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int8ImplCopyWith<_$LiteralValue_Int8Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int16ImplCopyWith<$Res> {
  factory _$$LiteralValue_Int16ImplCopyWith(_$LiteralValue_Int16Impl value,
          $Res Function(_$LiteralValue_Int16Impl) then) =
      __$$LiteralValue_Int16ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int16ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int16Impl>
    implements _$$LiteralValue_Int16ImplCopyWith<$Res> {
  __$$LiteralValue_Int16ImplCopyWithImpl(_$LiteralValue_Int16Impl _value,
      $Res Function(_$LiteralValue_Int16Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int16Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int16Impl implements LiteralValue_Int16 {
  const _$LiteralValue_Int16Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int16(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int16Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int16ImplCopyWith<_$LiteralValue_Int16Impl> get copyWith =>
      __$$LiteralValue_Int16ImplCopyWithImpl<_$LiteralValue_Int16Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return int16(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return int16?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return int16(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return int16?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (int16 != null) {
      return int16(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int16 implements LiteralValue {
  const factory LiteralValue_Int16(final int field0) = _$LiteralValue_Int16Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int16ImplCopyWith<_$LiteralValue_Int16Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int32ImplCopyWith<$Res> {
  factory _$$LiteralValue_Int32ImplCopyWith(_$LiteralValue_Int32Impl value,
          $Res Function(_$LiteralValue_Int32Impl) then) =
      __$$LiteralValue_Int32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int32ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int32Impl>
    implements _$$LiteralValue_Int32ImplCopyWith<$Res> {
  __$$LiteralValue_Int32ImplCopyWithImpl(_$LiteralValue_Int32Impl _value,
      $Res Function(_$LiteralValue_Int32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int32Impl implements LiteralValue_Int32 {
  const _$LiteralValue_Int32Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int32ImplCopyWith<_$LiteralValue_Int32Impl> get copyWith =>
      __$$LiteralValue_Int32ImplCopyWithImpl<_$LiteralValue_Int32Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return int32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return int32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return int32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return int32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (int32 != null) {
      return int32(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int32 implements LiteralValue {
  const factory LiteralValue_Int32(final int field0) = _$LiteralValue_Int32Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int32ImplCopyWith<_$LiteralValue_Int32Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Int64ImplCopyWith<$Res> {
  factory _$$LiteralValue_Int64ImplCopyWith(_$LiteralValue_Int64Impl value,
          $Res Function(_$LiteralValue_Int64Impl) then) =
      __$$LiteralValue_Int64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_Int64ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Int64Impl>
    implements _$$LiteralValue_Int64ImplCopyWith<$Res> {
  __$$LiteralValue_Int64ImplCopyWithImpl(_$LiteralValue_Int64Impl _value,
      $Res Function(_$LiteralValue_Int64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Int64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Int64Impl implements LiteralValue_Int64 {
  const _$LiteralValue_Int64Impl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.int64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Int64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Int64ImplCopyWith<_$LiteralValue_Int64Impl> get copyWith =>
      __$$LiteralValue_Int64ImplCopyWithImpl<_$LiteralValue_Int64Impl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return int64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return int64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return int64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return int64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Int64 implements LiteralValue {
  const factory LiteralValue_Int64(final int field0) = _$LiteralValue_Int64Impl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Int64ImplCopyWith<_$LiteralValue_Int64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Float32ImplCopyWith<$Res> {
  factory _$$LiteralValue_Float32ImplCopyWith(_$LiteralValue_Float32Impl value,
          $Res Function(_$LiteralValue_Float32Impl) then) =
      __$$LiteralValue_Float32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$LiteralValue_Float32ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Float32Impl>
    implements _$$LiteralValue_Float32ImplCopyWith<$Res> {
  __$$LiteralValue_Float32ImplCopyWithImpl(_$LiteralValue_Float32Impl _value,
      $Res Function(_$LiteralValue_Float32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Float32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Float32Impl implements LiteralValue_Float32 {
  const _$LiteralValue_Float32Impl(this.field0);

  @override
  final double field0;

  @override
  String toString() {
    return 'LiteralValue.float32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Float32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Float32ImplCopyWith<_$LiteralValue_Float32Impl>
      get copyWith =>
          __$$LiteralValue_Float32ImplCopyWithImpl<_$LiteralValue_Float32Impl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return float32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return float32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return float32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return float32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (float32 != null) {
      return float32(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Float32 implements LiteralValue {
  const factory LiteralValue_Float32(final double field0) =
      _$LiteralValue_Float32Impl;

  double get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Float32ImplCopyWith<_$LiteralValue_Float32Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_Float64ImplCopyWith<$Res> {
  factory _$$LiteralValue_Float64ImplCopyWith(_$LiteralValue_Float64Impl value,
          $Res Function(_$LiteralValue_Float64Impl) then) =
      __$$LiteralValue_Float64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$LiteralValue_Float64ImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_Float64Impl>
    implements _$$LiteralValue_Float64ImplCopyWith<$Res> {
  __$$LiteralValue_Float64ImplCopyWithImpl(_$LiteralValue_Float64Impl _value,
      $Res Function(_$LiteralValue_Float64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_Float64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$LiteralValue_Float64Impl implements LiteralValue_Float64 {
  const _$LiteralValue_Float64Impl(this.field0);

  @override
  final double field0;

  @override
  String toString() {
    return 'LiteralValue.float64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_Float64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_Float64ImplCopyWith<_$LiteralValue_Float64Impl>
      get copyWith =>
          __$$LiteralValue_Float64ImplCopyWithImpl<_$LiteralValue_Float64Impl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return float64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return float64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return float64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return float64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Float64 implements LiteralValue {
  const factory LiteralValue_Float64(final double field0) =
      _$LiteralValue_Float64Impl;

  double get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_Float64ImplCopyWith<_$LiteralValue_Float64Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_RangeImplCopyWith<$Res> {
  factory _$$LiteralValue_RangeImplCopyWith(_$LiteralValue_RangeImpl value,
          $Res Function(_$LiteralValue_RangeImpl) then) =
      __$$LiteralValue_RangeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int low, int high, DataType dataType});

  $DataTypeCopyWith<$Res> get dataType;
}

/// @nodoc
class __$$LiteralValue_RangeImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_RangeImpl>
    implements _$$LiteralValue_RangeImplCopyWith<$Res> {
  __$$LiteralValue_RangeImplCopyWithImpl(_$LiteralValue_RangeImpl _value,
      $Res Function(_$LiteralValue_RangeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? low = null,
    Object? high = null,
    Object? dataType = null,
  }) {
    return _then(_$LiteralValue_RangeImpl(
      low: null == low
          ? _value.low
          : low // ignore: cast_nullable_to_non_nullable
              as int,
      high: null == high
          ? _value.high
          : high // ignore: cast_nullable_to_non_nullable
              as int,
      dataType: null == dataType
          ? _value.dataType
          : dataType // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get dataType {
    return $DataTypeCopyWith<$Res>(_value.dataType, (value) {
      return _then(_value.copyWith(dataType: value));
    });
  }
}

/// @nodoc

class _$LiteralValue_RangeImpl implements LiteralValue_Range {
  const _$LiteralValue_RangeImpl(
      {required this.low, required this.high, required this.dataType});

  /// The starting value of the range.
  @override
  final int low;

  /// The ending value of the range.
  @override
  final int high;

  /// The datatype of this range's ends.
  @override
  final DataType dataType;

  @override
  String toString() {
    return 'LiteralValue.range(low: $low, high: $high, dataType: $dataType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_RangeImpl &&
            (identical(other.low, low) || other.low == low) &&
            (identical(other.high, high) || other.high == high) &&
            (identical(other.dataType, dataType) ||
                other.dataType == dataType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, low, high, dataType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_RangeImplCopyWith<_$LiteralValue_RangeImpl> get copyWith =>
      __$$LiteralValue_RangeImplCopyWithImpl<_$LiteralValue_RangeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return range(low, high, dataType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return range?.call(low, high, dataType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (range != null) {
      return range(low, high, dataType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return range(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return range?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (range != null) {
      return range(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Range implements LiteralValue {
  const factory LiteralValue_Range(
      {required final int low,
      required final int high,
      required final DataType dataType}) = _$LiteralValue_RangeImpl;

  /// The starting value of the range.
  int get low;

  /// The ending value of the range.
  int get high;

  /// The datatype of this range's ends.
  DataType get dataType;
  @JsonKey(ignore: true)
  _$$LiteralValue_RangeImplCopyWith<_$LiteralValue_RangeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_DateTimeImplCopyWith<$Res> {
  factory _$$LiteralValue_DateTimeImplCopyWith(
          _$LiteralValue_DateTimeImpl value,
          $Res Function(_$LiteralValue_DateTimeImpl) then) =
      __$$LiteralValue_DateTimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0, TimeUnit field1, String? field2});
}

/// @nodoc
class __$$LiteralValue_DateTimeImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_DateTimeImpl>
    implements _$$LiteralValue_DateTimeImplCopyWith<$Res> {
  __$$LiteralValue_DateTimeImplCopyWithImpl(_$LiteralValue_DateTimeImpl _value,
      $Res Function(_$LiteralValue_DateTimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
    Object? field2 = freezed,
  }) {
    return _then(_$LiteralValue_DateTimeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
      freezed == field2
          ? _value.field2
          : field2 // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$LiteralValue_DateTimeImpl implements LiteralValue_DateTime {
  const _$LiteralValue_DateTimeImpl(this.field0, this.field1, [this.field2]);

  @override
  final int field0;
  @override
  final TimeUnit field1;
  @override
  final String? field2;

  @override
  String toString() {
    return 'LiteralValue.dateTime(field0: $field0, field1: $field1, field2: $field2)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_DateTimeImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1) &&
            (identical(other.field2, field2) || other.field2 == field2));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1, field2);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_DateTimeImplCopyWith<_$LiteralValue_DateTimeImpl>
      get copyWith => __$$LiteralValue_DateTimeImplCopyWithImpl<
          _$LiteralValue_DateTimeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return dateTime(field0, field1, field2);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return dateTime?.call(field0, field1, field2);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(field0, field1, field2);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return dateTime(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return dateTime?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (dateTime != null) {
      return dateTime(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_DateTime implements LiteralValue {
  const factory LiteralValue_DateTime(final int field0, final TimeUnit field1,
      [final String? field2]) = _$LiteralValue_DateTimeImpl;

  int get field0;
  TimeUnit get field1;
  String? get field2;
  @JsonKey(ignore: true)
  _$$LiteralValue_DateTimeImplCopyWith<_$LiteralValue_DateTimeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_DurationImplCopyWith<$Res> {
  factory _$$LiteralValue_DurationImplCopyWith(
          _$LiteralValue_DurationImpl value,
          $Res Function(_$LiteralValue_DurationImpl) then) =
      __$$LiteralValue_DurationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0, TimeUnit field1});
}

/// @nodoc
class __$$LiteralValue_DurationImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_DurationImpl>
    implements _$$LiteralValue_DurationImplCopyWith<$Res> {
  __$$LiteralValue_DurationImplCopyWithImpl(_$LiteralValue_DurationImpl _value,
      $Res Function(_$LiteralValue_DurationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$LiteralValue_DurationImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as TimeUnit,
    ));
  }
}

/// @nodoc

class _$LiteralValue_DurationImpl implements LiteralValue_Duration {
  const _$LiteralValue_DurationImpl(this.field0, this.field1);

  @override
  final int field0;
  @override
  final TimeUnit field1;

  @override
  String toString() {
    return 'LiteralValue.duration(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_DurationImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_DurationImplCopyWith<_$LiteralValue_DurationImpl>
      get copyWith => __$$LiteralValue_DurationImplCopyWithImpl<
          _$LiteralValue_DurationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return duration(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return duration?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return duration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return duration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (duration != null) {
      return duration(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Duration implements LiteralValue {
  const factory LiteralValue_Duration(final int field0, final TimeUnit field1) =
      _$LiteralValue_DurationImpl;

  int get field0;
  TimeUnit get field1;
  @JsonKey(ignore: true)
  _$$LiteralValue_DurationImplCopyWith<_$LiteralValue_DurationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_DateImplCopyWith<$Res> {
  factory _$$LiteralValue_DateImplCopyWith(_$LiteralValue_DateImpl value,
          $Res Function(_$LiteralValue_DateImpl) then) =
      __$$LiteralValue_DateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_DateImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_DateImpl>
    implements _$$LiteralValue_DateImplCopyWith<$Res> {
  __$$LiteralValue_DateImplCopyWithImpl(_$LiteralValue_DateImpl _value,
      $Res Function(_$LiteralValue_DateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_DateImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_DateImpl implements LiteralValue_Date {
  const _$LiteralValue_DateImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.date(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_DateImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_DateImplCopyWith<_$LiteralValue_DateImpl> get copyWith =>
      __$$LiteralValue_DateImplCopyWithImpl<_$LiteralValue_DateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return date(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return date?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return date(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return date?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (date != null) {
      return date(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Date implements LiteralValue {
  const factory LiteralValue_Date(final int field0) = _$LiteralValue_DateImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_DateImplCopyWith<_$LiteralValue_DateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LiteralValue_TimeImplCopyWith<$Res> {
  factory _$$LiteralValue_TimeImplCopyWith(_$LiteralValue_TimeImpl value,
          $Res Function(_$LiteralValue_TimeImpl) then) =
      __$$LiteralValue_TimeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LiteralValue_TimeImplCopyWithImpl<$Res>
    extends _$LiteralValueCopyWithImpl<$Res, _$LiteralValue_TimeImpl>
    implements _$$LiteralValue_TimeImplCopyWith<$Res> {
  __$$LiteralValue_TimeImplCopyWithImpl(_$LiteralValue_TimeImpl _value,
      $Res Function(_$LiteralValue_TimeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LiteralValue_TimeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LiteralValue_TimeImpl implements LiteralValue_Time {
  const _$LiteralValue_TimeImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'LiteralValue.time(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LiteralValue_TimeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LiteralValue_TimeImplCopyWith<_$LiteralValue_TimeImpl> get copyWith =>
      __$$LiteralValue_TimeImplCopyWithImpl<_$LiteralValue_TimeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() Null,
    required TResult Function(bool field0) boolean,
    required TResult Function(String field0) utf8,
    required TResult Function(Uint8List field0) binary,
    required TResult Function(int field0) uInt8,
    required TResult Function(int field0) uInt16,
    required TResult Function(int field0) uInt32,
    required TResult Function(int field0) uInt64,
    required TResult Function(int field0) int8,
    required TResult Function(int field0) int16,
    required TResult Function(int field0) int32,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float32,
    required TResult Function(double field0) float64,
    required TResult Function(int low, int high, DataType dataType) range,
    required TResult Function(int field0, TimeUnit field1, String? field2)
        dateTime,
    required TResult Function(int field0, TimeUnit field1) duration,
    required TResult Function(int field0) date,
    required TResult Function(int field0) time,
  }) {
    return time(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? Null,
    TResult? Function(bool field0)? boolean,
    TResult? Function(String field0)? utf8,
    TResult? Function(Uint8List field0)? binary,
    TResult? Function(int field0)? uInt8,
    TResult? Function(int field0)? uInt16,
    TResult? Function(int field0)? uInt32,
    TResult? Function(int field0)? uInt64,
    TResult? Function(int field0)? int8,
    TResult? Function(int field0)? int16,
    TResult? Function(int field0)? int32,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float32,
    TResult? Function(double field0)? float64,
    TResult? Function(int low, int high, DataType dataType)? range,
    TResult? Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult? Function(int field0, TimeUnit field1)? duration,
    TResult? Function(int field0)? date,
    TResult? Function(int field0)? time,
  }) {
    return time?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? Null,
    TResult Function(bool field0)? boolean,
    TResult Function(String field0)? utf8,
    TResult Function(Uint8List field0)? binary,
    TResult Function(int field0)? uInt8,
    TResult Function(int field0)? uInt16,
    TResult Function(int field0)? uInt32,
    TResult Function(int field0)? uInt64,
    TResult Function(int field0)? int8,
    TResult Function(int field0)? int16,
    TResult Function(int field0)? int32,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float32,
    TResult Function(double field0)? float64,
    TResult Function(int low, int high, DataType dataType)? range,
    TResult Function(int field0, TimeUnit field1, String? field2)? dateTime,
    TResult Function(int field0, TimeUnit field1)? duration,
    TResult Function(int field0)? date,
    TResult Function(int field0)? time,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LiteralValue_Null value) Null,
    required TResult Function(LiteralValue_Boolean value) boolean,
    required TResult Function(LiteralValue_Utf8 value) utf8,
    required TResult Function(LiteralValue_Binary value) binary,
    required TResult Function(LiteralValue_UInt8 value) uInt8,
    required TResult Function(LiteralValue_UInt16 value) uInt16,
    required TResult Function(LiteralValue_UInt32 value) uInt32,
    required TResult Function(LiteralValue_UInt64 value) uInt64,
    required TResult Function(LiteralValue_Int8 value) int8,
    required TResult Function(LiteralValue_Int16 value) int16,
    required TResult Function(LiteralValue_Int32 value) int32,
    required TResult Function(LiteralValue_Int64 value) int64,
    required TResult Function(LiteralValue_Float32 value) float32,
    required TResult Function(LiteralValue_Float64 value) float64,
    required TResult Function(LiteralValue_Range value) range,
    required TResult Function(LiteralValue_DateTime value) dateTime,
    required TResult Function(LiteralValue_Duration value) duration,
    required TResult Function(LiteralValue_Date value) date,
    required TResult Function(LiteralValue_Time value) time,
  }) {
    return time(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LiteralValue_Null value)? Null,
    TResult? Function(LiteralValue_Boolean value)? boolean,
    TResult? Function(LiteralValue_Utf8 value)? utf8,
    TResult? Function(LiteralValue_Binary value)? binary,
    TResult? Function(LiteralValue_UInt8 value)? uInt8,
    TResult? Function(LiteralValue_UInt16 value)? uInt16,
    TResult? Function(LiteralValue_UInt32 value)? uInt32,
    TResult? Function(LiteralValue_UInt64 value)? uInt64,
    TResult? Function(LiteralValue_Int8 value)? int8,
    TResult? Function(LiteralValue_Int16 value)? int16,
    TResult? Function(LiteralValue_Int32 value)? int32,
    TResult? Function(LiteralValue_Int64 value)? int64,
    TResult? Function(LiteralValue_Float32 value)? float32,
    TResult? Function(LiteralValue_Float64 value)? float64,
    TResult? Function(LiteralValue_Range value)? range,
    TResult? Function(LiteralValue_DateTime value)? dateTime,
    TResult? Function(LiteralValue_Duration value)? duration,
    TResult? Function(LiteralValue_Date value)? date,
    TResult? Function(LiteralValue_Time value)? time,
  }) {
    return time?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LiteralValue_Null value)? Null,
    TResult Function(LiteralValue_Boolean value)? boolean,
    TResult Function(LiteralValue_Utf8 value)? utf8,
    TResult Function(LiteralValue_Binary value)? binary,
    TResult Function(LiteralValue_UInt8 value)? uInt8,
    TResult Function(LiteralValue_UInt16 value)? uInt16,
    TResult Function(LiteralValue_UInt32 value)? uInt32,
    TResult Function(LiteralValue_UInt64 value)? uInt64,
    TResult Function(LiteralValue_Int8 value)? int8,
    TResult Function(LiteralValue_Int16 value)? int16,
    TResult Function(LiteralValue_Int32 value)? int32,
    TResult Function(LiteralValue_Int64 value)? int64,
    TResult Function(LiteralValue_Float32 value)? float32,
    TResult Function(LiteralValue_Float64 value)? float64,
    TResult Function(LiteralValue_Range value)? range,
    TResult Function(LiteralValue_DateTime value)? dateTime,
    TResult Function(LiteralValue_Duration value)? duration,
    TResult Function(LiteralValue_Date value)? date,
    TResult Function(LiteralValue_Time value)? time,
    required TResult orElse(),
  }) {
    if (time != null) {
      return time(this);
    }
    return orElse();
  }
}

abstract class LiteralValue_Time implements LiteralValue {
  const factory LiteralValue_Time(final int field0) = _$LiteralValue_TimeImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$LiteralValue_TimeImplCopyWith<_$LiteralValue_TimeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NullValues {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) allColumnsSingle,
    required TResult Function(List<String> field0) allColumns,
    required TResult Function(List<(String, String)> field0) named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? allColumnsSingle,
    TResult? Function(List<String> field0)? allColumns,
    TResult? Function(List<(String, String)> field0)? named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? allColumnsSingle,
    TResult Function(List<String> field0)? allColumns,
    TResult Function(List<(String, String)> field0)? named,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullValues_AllColumnsSingle value)
        allColumnsSingle,
    required TResult Function(NullValues_AllColumns value) allColumns,
    required TResult Function(NullValues_Named value) named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult? Function(NullValues_AllColumns value)? allColumns,
    TResult? Function(NullValues_Named value)? named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult Function(NullValues_AllColumns value)? allColumns,
    TResult Function(NullValues_Named value)? named,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NullValuesCopyWith<$Res> {
  factory $NullValuesCopyWith(
          NullValues value, $Res Function(NullValues) then) =
      _$NullValuesCopyWithImpl<$Res, NullValues>;
}

/// @nodoc
class _$NullValuesCopyWithImpl<$Res, $Val extends NullValues>
    implements $NullValuesCopyWith<$Res> {
  _$NullValuesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NullValues_AllColumnsSingleImplCopyWith<$Res> {
  factory _$$NullValues_AllColumnsSingleImplCopyWith(
          _$NullValues_AllColumnsSingleImpl value,
          $Res Function(_$NullValues_AllColumnsSingleImpl) then) =
      __$$NullValues_AllColumnsSingleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$NullValues_AllColumnsSingleImplCopyWithImpl<$Res>
    extends _$NullValuesCopyWithImpl<$Res, _$NullValues_AllColumnsSingleImpl>
    implements _$$NullValues_AllColumnsSingleImplCopyWith<$Res> {
  __$$NullValues_AllColumnsSingleImplCopyWithImpl(
      _$NullValues_AllColumnsSingleImpl _value,
      $Res Function(_$NullValues_AllColumnsSingleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$NullValues_AllColumnsSingleImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$NullValues_AllColumnsSingleImpl implements NullValues_AllColumnsSingle {
  const _$NullValues_AllColumnsSingleImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'NullValues.allColumnsSingle(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NullValues_AllColumnsSingleImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NullValues_AllColumnsSingleImplCopyWith<_$NullValues_AllColumnsSingleImpl>
      get copyWith => __$$NullValues_AllColumnsSingleImplCopyWithImpl<
          _$NullValues_AllColumnsSingleImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) allColumnsSingle,
    required TResult Function(List<String> field0) allColumns,
    required TResult Function(List<(String, String)> field0) named,
  }) {
    return allColumnsSingle(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? allColumnsSingle,
    TResult? Function(List<String> field0)? allColumns,
    TResult? Function(List<(String, String)> field0)? named,
  }) {
    return allColumnsSingle?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? allColumnsSingle,
    TResult Function(List<String> field0)? allColumns,
    TResult Function(List<(String, String)> field0)? named,
    required TResult orElse(),
  }) {
    if (allColumnsSingle != null) {
      return allColumnsSingle(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullValues_AllColumnsSingle value)
        allColumnsSingle,
    required TResult Function(NullValues_AllColumns value) allColumns,
    required TResult Function(NullValues_Named value) named,
  }) {
    return allColumnsSingle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult? Function(NullValues_AllColumns value)? allColumns,
    TResult? Function(NullValues_Named value)? named,
  }) {
    return allColumnsSingle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult Function(NullValues_AllColumns value)? allColumns,
    TResult Function(NullValues_Named value)? named,
    required TResult orElse(),
  }) {
    if (allColumnsSingle != null) {
      return allColumnsSingle(this);
    }
    return orElse();
  }
}

abstract class NullValues_AllColumnsSingle implements NullValues {
  const factory NullValues_AllColumnsSingle(final String field0) =
      _$NullValues_AllColumnsSingleImpl;

  @override
  String get field0;
  @JsonKey(ignore: true)
  _$$NullValues_AllColumnsSingleImplCopyWith<_$NullValues_AllColumnsSingleImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NullValues_AllColumnsImplCopyWith<$Res> {
  factory _$$NullValues_AllColumnsImplCopyWith(
          _$NullValues_AllColumnsImpl value,
          $Res Function(_$NullValues_AllColumnsImpl) then) =
      __$$NullValues_AllColumnsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> field0});
}

/// @nodoc
class __$$NullValues_AllColumnsImplCopyWithImpl<$Res>
    extends _$NullValuesCopyWithImpl<$Res, _$NullValues_AllColumnsImpl>
    implements _$$NullValues_AllColumnsImplCopyWith<$Res> {
  __$$NullValues_AllColumnsImplCopyWithImpl(_$NullValues_AllColumnsImpl _value,
      $Res Function(_$NullValues_AllColumnsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$NullValues_AllColumnsImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$NullValues_AllColumnsImpl implements NullValues_AllColumns {
  const _$NullValues_AllColumnsImpl(final List<String> field0)
      : _field0 = field0;

  final List<String> _field0;
  @override
  List<String> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'NullValues.allColumns(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NullValues_AllColumnsImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NullValues_AllColumnsImplCopyWith<_$NullValues_AllColumnsImpl>
      get copyWith => __$$NullValues_AllColumnsImplCopyWithImpl<
          _$NullValues_AllColumnsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) allColumnsSingle,
    required TResult Function(List<String> field0) allColumns,
    required TResult Function(List<(String, String)> field0) named,
  }) {
    return allColumns(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? allColumnsSingle,
    TResult? Function(List<String> field0)? allColumns,
    TResult? Function(List<(String, String)> field0)? named,
  }) {
    return allColumns?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? allColumnsSingle,
    TResult Function(List<String> field0)? allColumns,
    TResult Function(List<(String, String)> field0)? named,
    required TResult orElse(),
  }) {
    if (allColumns != null) {
      return allColumns(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullValues_AllColumnsSingle value)
        allColumnsSingle,
    required TResult Function(NullValues_AllColumns value) allColumns,
    required TResult Function(NullValues_Named value) named,
  }) {
    return allColumns(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult? Function(NullValues_AllColumns value)? allColumns,
    TResult? Function(NullValues_Named value)? named,
  }) {
    return allColumns?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult Function(NullValues_AllColumns value)? allColumns,
    TResult Function(NullValues_Named value)? named,
    required TResult orElse(),
  }) {
    if (allColumns != null) {
      return allColumns(this);
    }
    return orElse();
  }
}

abstract class NullValues_AllColumns implements NullValues {
  const factory NullValues_AllColumns(final List<String> field0) =
      _$NullValues_AllColumnsImpl;

  @override
  List<String> get field0;
  @JsonKey(ignore: true)
  _$$NullValues_AllColumnsImplCopyWith<_$NullValues_AllColumnsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NullValues_NamedImplCopyWith<$Res> {
  factory _$$NullValues_NamedImplCopyWith(_$NullValues_NamedImpl value,
          $Res Function(_$NullValues_NamedImpl) then) =
      __$$NullValues_NamedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<(String, String)> field0});
}

/// @nodoc
class __$$NullValues_NamedImplCopyWithImpl<$Res>
    extends _$NullValuesCopyWithImpl<$Res, _$NullValues_NamedImpl>
    implements _$$NullValues_NamedImplCopyWith<$Res> {
  __$$NullValues_NamedImplCopyWithImpl(_$NullValues_NamedImpl _value,
      $Res Function(_$NullValues_NamedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$NullValues_NamedImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<(String, String)>,
    ));
  }
}

/// @nodoc

class _$NullValues_NamedImpl implements NullValues_Named {
  const _$NullValues_NamedImpl(final List<(String, String)> field0)
      : _field0 = field0;

  final List<(String, String)> _field0;
  @override
  List<(String, String)> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'NullValues.named(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NullValues_NamedImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NullValues_NamedImplCopyWith<_$NullValues_NamedImpl> get copyWith =>
      __$$NullValues_NamedImplCopyWithImpl<_$NullValues_NamedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) allColumnsSingle,
    required TResult Function(List<String> field0) allColumns,
    required TResult Function(List<(String, String)> field0) named,
  }) {
    return named(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? allColumnsSingle,
    TResult? Function(List<String> field0)? allColumns,
    TResult? Function(List<(String, String)> field0)? named,
  }) {
    return named?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? allColumnsSingle,
    TResult Function(List<String> field0)? allColumns,
    TResult Function(List<(String, String)> field0)? named,
    required TResult orElse(),
  }) {
    if (named != null) {
      return named(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NullValues_AllColumnsSingle value)
        allColumnsSingle,
    required TResult Function(NullValues_AllColumns value) allColumns,
    required TResult Function(NullValues_Named value) named,
  }) {
    return named(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult? Function(NullValues_AllColumns value)? allColumns,
    TResult? Function(NullValues_Named value)? named,
  }) {
    return named?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NullValues_AllColumnsSingle value)? allColumnsSingle,
    TResult Function(NullValues_AllColumns value)? allColumns,
    TResult Function(NullValues_Named value)? named,
    required TResult orElse(),
  }) {
    if (named != null) {
      return named(this);
    }
    return orElse();
  }
}

abstract class NullValues_Named implements NullValues {
  const factory NullValues_Named(final List<(String, String)> field0) =
      _$NullValues_NamedImpl;

  @override
  List<(String, String)> get field0;
  @JsonKey(ignore: true)
  _$$NullValues_NamedImplCopyWith<_$NullValues_NamedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WindowType {
  WindowMapping get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(WindowMapping field0) over,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(WindowMapping field0)? over,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(WindowMapping field0)? over,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WindowType_Over value) over,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WindowType_Over value)? over,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WindowType_Over value)? over,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WindowTypeCopyWith<WindowType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WindowTypeCopyWith<$Res> {
  factory $WindowTypeCopyWith(
          WindowType value, $Res Function(WindowType) then) =
      _$WindowTypeCopyWithImpl<$Res, WindowType>;
  @useResult
  $Res call({WindowMapping field0});
}

/// @nodoc
class _$WindowTypeCopyWithImpl<$Res, $Val extends WindowType>
    implements $WindowTypeCopyWith<$Res> {
  _$WindowTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as WindowMapping,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WindowType_OverImplCopyWith<$Res>
    implements $WindowTypeCopyWith<$Res> {
  factory _$$WindowType_OverImplCopyWith(_$WindowType_OverImpl value,
          $Res Function(_$WindowType_OverImpl) then) =
      __$$WindowType_OverImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({WindowMapping field0});
}

/// @nodoc
class __$$WindowType_OverImplCopyWithImpl<$Res>
    extends _$WindowTypeCopyWithImpl<$Res, _$WindowType_OverImpl>
    implements _$$WindowType_OverImplCopyWith<$Res> {
  __$$WindowType_OverImplCopyWithImpl(
      _$WindowType_OverImpl _value, $Res Function(_$WindowType_OverImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$WindowType_OverImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as WindowMapping,
    ));
  }
}

/// @nodoc

class _$WindowType_OverImpl implements WindowType_Over {
  const _$WindowType_OverImpl(this.field0);

  @override
  final WindowMapping field0;

  @override
  String toString() {
    return 'WindowType.over(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WindowType_OverImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WindowType_OverImplCopyWith<_$WindowType_OverImpl> get copyWith =>
      __$$WindowType_OverImplCopyWithImpl<_$WindowType_OverImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(WindowMapping field0) over,
  }) {
    return over(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(WindowMapping field0)? over,
  }) {
    return over?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(WindowMapping field0)? over,
    required TResult orElse(),
  }) {
    if (over != null) {
      return over(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WindowType_Over value) over,
  }) {
    return over(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WindowType_Over value)? over,
  }) {
    return over?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WindowType_Over value)? over,
    required TResult orElse(),
  }) {
    if (over != null) {
      return over(this);
    }
    return orElse();
  }
}

abstract class WindowType_Over implements WindowType {
  const factory WindowType_Over(final WindowMapping field0) =
      _$WindowType_OverImpl;

  @override
  WindowMapping get field0;
  @override
  @JsonKey(ignore: true)
  _$$WindowType_OverImplCopyWith<_$WindowType_OverImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
