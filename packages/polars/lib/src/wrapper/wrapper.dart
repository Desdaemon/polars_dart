// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.3.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'wrapper.freezed.dart';

/// Reads a [.csv](https://en.wikipedia.org/wiki/Comma-separated_values) file into a [DataFrame].
///
/// - `columns`: Select only columns matching these names
/// - `delimiter`: Specify the delimiter for this file.
/// - `commentChar`: Ignore the rest of a line after encountering this character.
/// - `eolChar`: Stop reading after encountering this character.
/// - `quoteChar`: Specify the quote character, if set to null disables quoting.
/// - `skipRows`: Skip the first few rows, then parse the header and the dataframe.
/// - `skipRowsAfterHeader`: Skip this many rows after the header.
/// - `chunkSize`: Specify the chunk size of the internal parser. Performance knob.
/// - `nRows`: Try to read up to n rows then stop. Might not be honored in multithreading execution.
/// - `nullValues`: Specify values to be interpreted as null.
/// - `projection`: Select only columns at the specified indices.
/// - `rechunk`: Relocate the dataframe into contiguous memory after parsing.
///              Slow, but improves performance for later operations.
Future<DataFrame> readCsv(
        {required String path,
        List<DataType>? dtypesSlice,
        bool? hasHeader,
        List<String>? columns,
        String? commentChar,
        String? eolChar,
        int? chunkSize,
        int? sampleSize,
        RowCount? rowCount,
        CsvEncoding? encoding,
        int? nRows,
        int? nThreads,
        NullValues? nullValues,
        Uint32List? projection,
        String? quoteChar = '"',
        int skipRows = 0,
        int skipRowsAfterHeader = 0,
        bool ignoreErrors = false,
        bool rechunk = false,
        bool tryParseDates = true,
        bool lowMemory = false,
        dynamic hint}) =>
    RustLib.instance.api.readCsv(
        path: path,
        dtypesSlice: dtypesSlice,
        hasHeader: hasHeader,
        columns: columns,
        commentChar: commentChar,
        eolChar: eolChar,
        chunkSize: chunkSize,
        sampleSize: sampleSize,
        rowCount: rowCount,
        encoding: encoding,
        nRows: nRows,
        nThreads: nThreads,
        nullValues: nullValues,
        projection: projection,
        quoteChar: quoteChar,
        skipRows: skipRows,
        skipRowsAfterHeader: skipRowsAfterHeader,
        ignoreErrors: ignoreErrors,
        rechunk: rechunk,
        tryParseDates: tryParseDates,
        lowMemory: lowMemory,
        hint: hint);

/// Prepares a [.csv](https://en.wikipedia.org/wiki/Comma-separated_values) file for reading into a [LazyFrame].
///
/// - `delimiter`: Specify the delimiter for this file.
/// - `commentChar`: Ignore the rest of a line after encountering this character.
/// - `eolChar`: Stop reading after encountering this character.
/// - `quoteChar`: Specify the quote character, if set to null disables quoting.
/// - `skipRows`: Skip the first few rows, then parse the header and the dataframe.
/// - `skipRowsAfterHeader`: Skip this many rows after the header.
/// - `nRows`: Try to read up to n rows then stop. Might not be honored in multithreading execution.
/// - `nullValues`: Specify values to be interpreted as null.
/// - `rechunk`: Relocate the dataframe into contiguous memory after parsing.
///              Slow, but improves performance for later operations.
/// - `inferSchemaLength`: Specify how many rows to read to infer the schema, if null the entire table is scanned.
/// - `cache`: Cache the dataframe after reading.
Future<LazyFrame> scanCsv(
        {required String path,
        required Schema dtypeOverwrite,
        bool? hasHeader,
        String? commentChar,
        String? eolChar,
        String? quoteChar = '"',
        int skipRows = 0,
        int skipRowsAfterHeader = 0,
        RowCount? rowCount,
        CsvEncoding? encoding,
        int? nRows,
        NullValues? nullValues,
        bool ignoreErrors = false,
        bool rechunk = false,
        bool tryParseDates = true,
        int? inferSchemaLength = 100,
        bool cache = false,
        dynamic hint}) =>
    RustLib.instance.api.scanCsv(
        path: path,
        dtypeOverwrite: dtypeOverwrite,
        hasHeader: hasHeader,
        commentChar: commentChar,
        eolChar: eolChar,
        quoteChar: quoteChar,
        skipRows: skipRows,
        skipRowsAfterHeader: skipRowsAfterHeader,
        rowCount: rowCount,
        encoding: encoding,
        nRows: nRows,
        nullValues: nullValues,
        ignoreErrors: ignoreErrors,
        rechunk: rechunk,
        tryParseDates: tryParseDates,
        inferSchemaLength: inferSchemaLength,
        cache: cache,
        hint: hint);

/// Reads a [.json](https://en.wikipedia.org/wiki/JSON) file into a [DataFrame].
Future<DataFrame> readJson(
        {required String path,
        int? batchSize,
        List<String>? projection,
        dynamic hint}) =>
    RustLib.instance.api.readJson(
        path: path, batchSize: batchSize, projection: projection, hint: hint);

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<Vec<crate::wrapper::Series>>>>
@sealed
class Series extends RustOpaque {
  Series.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  Series.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Series,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Series,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SeriesPtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<crate::wrapper::Schema>>>
@sealed
class Schema extends RustOpaque {
  Schema.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  Schema.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Schema,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Schema,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SchemaPtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Vec<crate::wrapper::Series>>>
@sealed
class Series extends RustOpaque {
  Series.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  Series.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Series,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Series,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SeriesPtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>
@sealed
class DataFrame extends RustOpaque {
  DataFrame.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  DataFrame.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_DataFrame,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_DataFrame,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_DataFramePtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>
@sealed
class LazyFrame extends RustOpaque {
  LazyFrame.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  LazyFrame.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_LazyFrame,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_LazyFrame,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_LazyFramePtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyGroupBy>>
@sealed
class LazyGroupBy extends RustOpaque {
  LazyGroupBy.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  LazyGroupBy.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_LazyGroupBy,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_LazyGroupBy,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_LazyGroupByPtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Schema>>
@sealed
class Schema extends RustOpaque {
  Schema.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  Schema.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Schema,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Schema,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SchemaPtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>
@sealed
class Series extends RustOpaque {
  Series.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  Series.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Series,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Series,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SeriesPtr,
  );
}

@freezed
sealed class AggExpr with _$AggExpr {
  const factory AggExpr.min({
    required Expr input,
    required bool propagateNans,
  }) = AggExpr_Min;
  const factory AggExpr.max({
    required Expr input,
    required bool propagateNans,
  }) = AggExpr_Max;
  const factory AggExpr.median(
    Expr field0,
  ) = AggExpr_Median;
  const factory AggExpr.nUnique(
    Expr field0,
  ) = AggExpr_NUnique;
  const factory AggExpr.first(
    Expr field0,
  ) = AggExpr_First;
  const factory AggExpr.last(
    Expr field0,
  ) = AggExpr_Last;
  const factory AggExpr.mean(
    Expr field0,
  ) = AggExpr_Mean;
  const factory AggExpr.count(
    Expr field0,
  ) = AggExpr_Count;
  const factory AggExpr.quantile({
    required Expr expr,
    required Expr quantile,
    required QuantileInterpolOptions interpol,
  }) = AggExpr_Quantile;
  const factory AggExpr.sum(
    Expr field0,
  ) = AggExpr_Sum;
  const factory AggExpr.aggGroups(
    Expr field0,
  ) = AggExpr_AggGroups;
  const factory AggExpr.std(
    Expr field0,
    int field1,
  ) = AggExpr_Std;
  const factory AggExpr.Var(
    Expr field0,
    int field1,
  ) = AggExpr_Var;
}

/// Options for CSV encoding.
enum CsvEncoding {
  /// Utf8 encoding
  utf8,

  /// Utf8 encoding and unknown bytes are replaced with �
  lossyUtf8,
}

@freezed
sealed class DataType with _$DataType {
  /// Boolean
  const factory DataType.boolean() = DataType_Boolean;

  /// Unsigned 8-bit integer
  const factory DataType.uInt8() = DataType_UInt8;

  /// Unsigned 16-bit integer
  const factory DataType.uInt16() = DataType_UInt16;

  /// Unsigned 32-bit integer
  const factory DataType.uInt32() = DataType_UInt32;

  /// Unsigned 64-bit integer
  const factory DataType.uInt64() = DataType_UInt64;

  /// Signed 8-bit integer
  const factory DataType.int8() = DataType_Int8;

  /// Signed 16-bit integer
  const factory DataType.int16() = DataType_Int16;

  /// Signed 32-bit integer
  const factory DataType.int32() = DataType_Int32;

  /// Signed 64-bit integer, the default [int] on native platforms.
  const factory DataType.int64() = DataType_Int64;

  /// Single-precision floating point number
  const factory DataType.float32() = DataType_Float32;

  /// Double-precision floating point number, aka a [double].
  const factory DataType.float64() = DataType_Float64;

  /// String data
  const factory DataType.utf8() = DataType_Utf8;

  /// Raw bytes.
  const factory DataType.binary() = DataType_Binary;

  /// A 32-bit date representing the elapsed time since UNIX epoch (1970-01-01)
  /// in days (32 bits).
  const factory DataType.date() = DataType_Date;

  /// A 64-bit date representing the elapsed time since UNIX epoch (1970-01-01)
  /// in the given timeunit (64 bits).
  const factory DataType.datetime(
    TimeUnit field0, [
    String? field1,
  ]) = DataType_Datetime;

  /// 64-bit integer representing difference between times in milliseconds or nanoseconds
  const factory DataType.duration(
    TimeUnit field0,
  ) = DataType_Duration;

  /// A 64-bit time representing the elapsed time since midnight in nanoseconds
  const factory DataType.time() = DataType_Time;

  /// A typed list.
  const factory DataType.list(
    DataType field0,
  ) = DataType_List;
  const factory DataType.Null() = DataType_Null;

  /// Structured data.
  const factory DataType.struct(
    List<Field> field0,
  ) = DataType_Struct;

  /// Some logical types we cannot know statically, e.g. Datetime
  const factory DataType.unknown() = DataType_Unknown;
}

@freezed
sealed class Excluded with _$Excluded {
  /// By name
  const factory Excluded.name(
    String field0,
  ) = Excluded_Name;

  /// By type
  const factory Excluded.dtype(
    DataType field0,
  ) = Excluded_Dtype;
}

@freezed
sealed class Expr with _$Expr {
  /// Give this expression a new name.
  const factory Expr.alias(
    Expr field0,
    String field1,
  ) = Expr_Alias;

  /// Get the column matching this name.
  const factory Expr.column(
    String field0,
  ) = Expr_Column;

  /// Get all columns matching these names.
  const factory Expr.columns(
    List<String> field0,
  ) = Expr_Columns;

  /// Get columns of these datatypes.
  const factory Expr.dtypeColumn(
    List<DataType> field0,
  ) = Expr_DtypeColumn;

  /// Represents a literal value, i.e. strings, numebrs and so on.
  const factory Expr.literal(
    LiteralValue field0,
  ) = Expr_Literal;

  /// A binary expression.
  const factory Expr.binaryExpr({
    /// The left-hand side column.
    required Expr left,

    /// The operator, e.g. ==, >, <.
    required Operator op,

    /// The right-hand side column.
    required Expr right,
  }) = Expr_BinaryExpr;

  /// Cast a column into one of another type.
  const factory Expr.cast({
    /// The column to be cast.
    required Expr expr,

    /// The new desired datatype.
    required DataType dataType,

    /// Whether incompatible values should be coerced.
    required bool strict,
  }) = Expr_Cast;

  /// Sort the column.
  const factory Expr.sort({
    /// The column to be sorted.
    required Expr expr,

    /// Options for sorting.
    required SortOptions options,
  }) = Expr_Sort;

  /// Take a column.
  const factory Expr.gather({
    /// The column from which to take.
    required Expr expr,

    /// The index to take at.
    required Expr idx,
    required bool returnsScalar,
  }) = Expr_Gather;
  const factory Expr.sortBy({
    required Expr expr,
    required List<Expr> by,
    required List<bool> descending,
  }) = Expr_SortBy;

  /// Aggregating options.
  const factory Expr.agg(
    AggExpr field0,
  ) = Expr_Agg;

  /// A ternary operation.
  const factory Expr.ternary({
    /// The condition for this ternary.
    required Expr predicate,

    /// If `predicate` is true, evaluate to this.
    required Expr truthy,

    /// If `predicate` is false, evaluate to this.
    required Expr falsy,
  }) = Expr_Ternary;

  /// Expand columns of strings or lists.
  const factory Expr.explode(
    Expr field0,
  ) = Expr_Explode;

  /// Filter columns' values.
  const factory Expr.filter({
    /// The column to be filtered.
    required Expr input,

    /// The conditions by which this column should be filtered.
    required Expr by,
  }) = Expr_Filter;

  /// See postgres window functions
  const factory Expr.window({
    /// Also has the input. i.e. avg("foo")
    required Expr function,
    required List<Expr> partitionBy,
    required WindowType options,
  }) = Expr_Window;

  /// Matches any value.
  const factory Expr.wildcard() = Expr_Wildcard;

  /// Take slices of series.
  const factory Expr.slice({
    /// The column to take slices of.
    required Expr input,

    /// Length is not yet known so we accept negative offsets
    required Expr offset,

    /// How long the slice should be.
    required Expr length,
  }) = Expr_Slice;

  /// Can be used in a select statement to exclude a column from selection
  const factory Expr.exclude(
    Expr field0,
    List<Excluded> field1,
  ) = Expr_Exclude;

  /// Set root name as Alias
  const factory Expr.keepName(
    Expr field0,
  ) = Expr_KeepName;

  /// Special case that does not need columns
  const factory Expr.count() = Expr_Count;

  /// Take the nth column in the `DataFrame`
  const factory Expr.nth(
    int field0,
  ) = Expr_Nth;
}

/// Fields in a struct.
class Field {
  /// The field's name.
  final String name;

  /// The field's data type.
  final DataType dtype;

  const Field({
    required this.name,
    required this.dtype,
  });

  @override
  int get hashCode => name.hashCode ^ dtype.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Field &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          dtype == other.dtype;
}

/// Options for joining.
enum JoinType {
  /// Left outer join.
  left,

  /// Inner join.
  inner,

  /// Full outer join.
  outer,

  /// Cartesian (cross-product) join.
  cross,

  /// [Semijoin](https://en.wikipedia.org/wiki/Relational_algebra#Semijoin_(%E2%8B%89_and_%E2%8B%8A)).
  semi,

  /// [Antijoin](https://en.wikipedia.org/wiki/Relational_algebra#Antijoin_(%E2%96%B7)).
  anti,
}

@freezed
sealed class LiteralValue with _$LiteralValue {
  const factory LiteralValue.Null() = LiteralValue_Null;

  /// A binary true or false.
  const factory LiteralValue.boolean(
    bool field0,
  ) = LiteralValue_Boolean;

  /// A UTF8 encoded string type.
  const factory LiteralValue.utf8(
    String field0,
  ) = LiteralValue_Utf8;

  /// A raw binary array
  const factory LiteralValue.binary(
    Uint8List field0,
  ) = LiteralValue_Binary;

  /// An unsigned 8-bit integer number.
  const factory LiteralValue.uInt8(
    int field0,
  ) = LiteralValue_UInt8;

  /// An unsigned 16-bit integer number.
  const factory LiteralValue.uInt16(
    int field0,
  ) = LiteralValue_UInt16;

  /// An unsigned 32-bit integer number.
  const factory LiteralValue.uInt32(
    int field0,
  ) = LiteralValue_UInt32;

  /// An unsigned 64-bit integer number.
  const factory LiteralValue.uInt64(
    int field0,
  ) = LiteralValue_UInt64;

  /// An 8-bit integer number.
  const factory LiteralValue.int8(
    int field0,
  ) = LiteralValue_Int8;

  /// A 16-bit integer number.
  const factory LiteralValue.int16(
    int field0,
  ) = LiteralValue_Int16;

  /// A 32-bit integer number.
  const factory LiteralValue.int32(
    int field0,
  ) = LiteralValue_Int32;

  /// A 64-bit integer number.
  const factory LiteralValue.int64(
    int field0,
  ) = LiteralValue_Int64;

  /// A 32-bit floating point number.
  const factory LiteralValue.float32(
    double field0,
  ) = LiteralValue_Float32;

  /// A 64-bit floating point number.
  const factory LiteralValue.float64(
    double field0,
  ) = LiteralValue_Float64;

  /// A range between integers.
  const factory LiteralValue.range({
    /// The starting value of the range.
    required int low,

    /// The ending value of the range.
    required int high,

    /// The datatype of this range's ends.
    required DataType dataType,
  }) = LiteralValue_Range;

  /// Datetimes.
  const factory LiteralValue.dateTime(
    int field0,
    TimeUnit field1, [
    String? field2,
  ]) = LiteralValue_DateTime;

  /// Durations.
  const factory LiteralValue.duration(
    int field0,
    TimeUnit field1,
  ) = LiteralValue_Duration;
  const factory LiteralValue.date(
    int field0,
  ) = LiteralValue_Date;
  const factory LiteralValue.time(
    int field0,
  ) = LiteralValue_Time;
}

@freezed
sealed class NullValues with _$NullValues {
  /// A single value that's used for all columns
  const factory NullValues.allColumnsSingle(
    String field0,
  ) = NullValues_AllColumnsSingle;

  /// Multiple values that are used for all columns
  const factory NullValues.allColumns(
    List<String> field0,
  ) = NullValues_AllColumns;

  /// Tuples that map column names to null value of that column
  const factory NullValues.named(
    List<(String, String)> field0,
  ) = NullValues_Named;
}

/// Operators for binary operations between [Expr]essions.
enum Operator {
  /// ==
  eq,
  eqValidity,

  /// !=
  notEq,
  notEqValidity,

  /// <
  lt,

  /// <=
  ltEq,

  /// >
  gt,

  /// >=
  gtEq,

  /// +
  plus,

  /// -
  minus,

  /// *
  multiply,

  /// /
  divide,

  /// ~/
  trueDivide,

  /// Divides and floors to the nearest integer.
  floorDivide,

  /// %
  modulus,

  /// &&
  and,

  /// ||
  or,

  /// ^
  xor,
}

enum QuantileInterpolOptions {
  nearest,
  lower,
  higher,
  midpoint,
  linear,
}

/// Options for including a row count column.
class RowCount {
  /// Name of the new column.
  final String name;

  /// The value from which to start counting.
  final int offset;

  const RowCount({
    required this.name,
    required this.offset,
  });

  @override
  int get hashCode => name.hashCode ^ offset.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RowCount &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          offset == other.offset;
}

/// Describes the shape of a [DataFrame].
class Shape {
  /// The number of rows.
  final int height;

  /// The number of columns.
  final int width;

  const Shape({
    required this.height,
    required this.width,
  });

  @override
  int get hashCode => height.hashCode ^ width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Shape &&
          runtimeType == other.runtimeType &&
          height == other.height &&
          width == other.width;
}

/// Options for sorting
class SortOptions {
  /// Whether it should be sorted from smallest or largest.
  final bool descending;

  /// Whether nulls get pushed to the top or bottom.
  final bool nullsLast;
  final bool multithreaded;
  final bool maintainOrder;

  const SortOptions({
    required this.descending,
    required this.nullsLast,
    required this.multithreaded,
    required this.maintainOrder,
  });

  @override
  int get hashCode =>
      descending.hashCode ^
      nullsLast.hashCode ^
      multithreaded.hashCode ^
      maintainOrder.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SortOptions &&
          runtimeType == other.runtimeType &&
          descending == other.descending &&
          nullsLast == other.nullsLast &&
          multithreaded == other.multithreaded &&
          maintainOrder == other.maintainOrder;
}

/// Possible units of time for dataframe values.
enum TimeUnit {
  /// One-billionth of a second.
  nanoseconds,

  /// One-millionth of a second.
  microseconds,

  /// One-thousandth of a second.
  milliseconds,
}

/// Options for keeping unique values.
enum UniqueKeepStrategy {
  /// TODO: Doc
  first,

  /// TODO: Doc
  last,
}

enum WindowMapping {
  groupsToRows,
  explode,
  join,
}

@freezed
sealed class WindowType with _$WindowType {
  const factory WindowType.over(
    WindowMapping field0,
  ) = WindowType_Over;
}
