// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.4.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'wrapper.freezed.dart';

/// Reads a [.csv](https://en.wikipedia.org/wiki/Comma-separated_values) file into a [DataFrame].
///
/// - `columns`: Select only columns matching these names
/// - `delimiter`: Specify the delimiter for this file.
/// - `commentChar`: Ignore the rest of a line after encountering this character.
/// - `eolChar`: Stop reading after encountering this character.
/// - `quoteChar`: Specify the quote character, if set to null disables quoting.
/// - `skipRows`: Skip the first few rows, then parse the header and the dataframe.
/// - `skipRowsAfterHeader`: Skip this many rows after the header.
/// - `chunkSize`: Specify the chunk size of the internal parser. Performance knob.
/// - `nRows`: Try to read up to n rows then stop. Might not be honored in multithreading execution.
/// - `nullValues`: Specify values to be interpreted as null.
/// - `projection`: Select only columns at the specified indices.
/// - `rechunk`: Relocate the dataframe into contiguous memory after parsing.
///              Slow, but improves performance for later operations.
Future<DataFrame> readCsv(
        {required String path,
        List<DataType>? dtypesSlice,
        bool? hasHeader,
        List<String>? columns,
        String? commentChar,
        String? eolChar,
        int? chunkSize,
        int? sampleSize,
        RowCount? rowCount,
        CsvEncoding? encoding,
        int? nRows,
        int? nThreads,
        NullValues? nullValues,
        Uint32List? projection,
        String? quoteChar = '"',
        int skipRows = 0,
        int skipRowsAfterHeader = 0,
        bool ignoreErrors = false,
        bool rechunk = false,
        bool tryParseDates = true,
        bool lowMemory = false,
        dynamic hint}) =>
    RustLib.instance.api.readCsv(
        path: path,
        dtypesSlice: dtypesSlice,
        hasHeader: hasHeader,
        columns: columns,
        commentChar: commentChar,
        eolChar: eolChar,
        chunkSize: chunkSize,
        sampleSize: sampleSize,
        rowCount: rowCount,
        encoding: encoding,
        nRows: nRows,
        nThreads: nThreads,
        nullValues: nullValues,
        projection: projection,
        quoteChar: quoteChar,
        skipRows: skipRows,
        skipRowsAfterHeader: skipRowsAfterHeader,
        ignoreErrors: ignoreErrors,
        rechunk: rechunk,
        tryParseDates: tryParseDates,
        lowMemory: lowMemory,
        hint: hint);

/// Prepares a [.csv](https://en.wikipedia.org/wiki/Comma-separated_values) file for reading into a [LazyFrame].
///
/// - `delimiter`: Specify the delimiter for this file.
/// - `commentChar`: Ignore the rest of a line after encountering this character.
/// - `eolChar`: Stop reading after encountering this character.
/// - `quoteChar`: Specify the quote character, if set to null disables quoting.
/// - `skipRows`: Skip the first few rows, then parse the header and the dataframe.
/// - `skipRowsAfterHeader`: Skip this many rows after the header.
/// - `nRows`: Try to read up to n rows then stop. Might not be honored in multithreading execution.
/// - `nullValues`: Specify values to be interpreted as null.
/// - `rechunk`: Relocate the dataframe into contiguous memory after parsing.
///              Slow, but improves performance for later operations.
/// - `inferSchemaLength`: Specify how many rows to read to infer the schema, if null the entire table is scanned.
/// - `cache`: Cache the dataframe after reading.
Future<LazyFrame> scanCsv(
        {required String path,
        required OptionSchema dtypeOverwrite,
        bool? hasHeader,
        String? commentChar,
        String? eolChar,
        String? quoteChar = '"',
        int skipRows = 0,
        int skipRowsAfterHeader = 0,
        RowCount? rowCount,
        CsvEncoding? encoding,
        int? nRows,
        NullValues? nullValues,
        bool ignoreErrors = false,
        bool rechunk = false,
        bool tryParseDates = true,
        int? inferSchemaLength = 100,
        bool cache = false,
        dynamic hint}) =>
    RustLib.instance.api.scanCsv(
        path: path,
        dtypeOverwrite: dtypeOverwrite,
        hasHeader: hasHeader,
        commentChar: commentChar,
        eolChar: eolChar,
        quoteChar: quoteChar,
        skipRows: skipRows,
        skipRowsAfterHeader: skipRowsAfterHeader,
        rowCount: rowCount,
        encoding: encoding,
        nRows: nRows,
        nullValues: nullValues,
        ignoreErrors: ignoreErrors,
        rechunk: rechunk,
        tryParseDates: tryParseDates,
        inferSchemaLength: inferSchemaLength,
        cache: cache,
        hint: hint);

/// Reads a [.json](https://en.wikipedia.org/wiki/JSON) file into a [DataFrame].
Future<DataFrame> readJson(
        {required String path,
        int? batchSize,
        List<String>? projection,
        dynamic hint}) =>
    RustLib.instance.api.readJson(
        path: path, batchSize: batchSize, projection: projection, hint: hint);

Expr col({required String name, dynamic hint}) =>
    RustLib.instance.api.col(name: name, hint: hint);

Expr cols({required List<String> names, dynamic hint}) =>
    RustLib.instance.api.cols(names: names, hint: hint);

Expr dtypes({required List<DataType> types, dynamic hint}) =>
    RustLib.instance.api.dtypes(types: types, hint: hint);

Expr nth({required int idx, dynamic hint}) =>
    RustLib.instance.api.nth(idx: idx, hint: hint);

Expr count({dynamic hint}) => RustLib.instance.api.count(hint: hint);

Expr lit({required LiteralValue value, dynamic hint}) =>
    RustLib.instance.api.lit(value: value, hint: hint);

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<DataFrame>>
@sealed
class DataFrame extends RustOpaque {
  DataFrame.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  DataFrame.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_DataFrame,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_DataFrame,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_DataFramePtr,
  );

  /// Select a single column by name.
  Series column({required String column, dynamic hint}) =>
      RustLib.instance.api.dataFrameColumn(
        that: this,
        column: column,
      );

  /// Select the column at the given index.
  Series columnAt({required int index, dynamic hint}) =>
      RustLib.instance.api.dataFrameColumnAt(
        that: this,
        index: index,
      );

  /// Select multiple columns by name.
  VecSeries columns({required List<String> columns, dynamic hint}) =>
      RustLib.instance.api.dataFrameColumns(
        that: this,
        columns: columns,
      );

  /// Output statistics about this dataframe.
  Future<DataFrame> describe({Float64List? percentiles, dynamic hint}) =>
      RustLib.instance.api.dataFrameDescribe(
        that: this,
        percentiles: percentiles,
      );

  /// Drops a column by name, producing a new dataframe.
  DataFrame drop({required String column, dynamic hint}) =>
      RustLib.instance.api.dataFrameDrop(
        that: this,
        column: column,
      );

  /// Drops a column in-place and returns it.
  Series dropInPlace({required String column, dynamic hint}) =>
      RustLib.instance.api.dataFrameDropInPlace(
        that: this,
        column: column,
      );

  /// Returns the datatypes of this dataframe's columns.
  List<DataType> dtypes({dynamic hint}) => RustLib.instance.api.dataFrameDtypes(
        that: this,
      );

  /// Dump the contents of this entire dataframe.
  String dump({dynamic hint}) => RustLib.instance.api.dataFrameDump(
        that: this,
      );

  /// Returns the amount of bytes occupied by this series.
  int estimatedSize({dynamic hint}) =>
      RustLib.instance.api.dataFrameEstimatedSize(
        that: this,
      );

  /// Get the names of this dataframe's columns.
  List<String> getColumnNames({dynamic hint}) =>
      RustLib.instance.api.dataFrameGetColumnNames(
        that: this,
      );

  /// Get all columns of this dataframe.
  VecSeries getColumns({dynamic hint}) =>
      RustLib.instance.api.dataFrameGetColumns(
        that: this,
      );

  /// Get a row of data from this dataframe.
  ///
  /// Prefer other functions to this inside a hot loop, as this function performs
  /// data copies and conversions to and from the native representation.
  List<dynamic> getRow({required int index, dynamic hint}) =>
      RustLib.instance.api.dataFrameGetRow(
        that: this,
        index: index,
      );

  /// Returns the first few rows of this dataframe.
  DataFrame head({int? length, dynamic hint}) =>
      RustLib.instance.api.dataFrameHead(
        that: this,
        length: length,
      );

  /// Returns the height of this dataframe, aka the number of rows.
  int height({dynamic hint}) => RustLib.instance.api.dataFrameHeight(
        that: this,
      );

  /// Returns whether this dataframe has no rows.
  bool isEmpty({dynamic hint}) => RustLib.instance.api.dataFrameIsEmpty(
        that: this,
      );

  /// Iterate through this dataframe's rows.
  ///
  /// Use [parseRow] to retrieve the canonical values for these rows.
  Stream<List<dynamic>> iter({dynamic hint}) =>
      RustLib.instance.api.dataFrameIter(
        that: this,
      );

  /// Returns a [LazyFrame] to which operations can be applied lazily.
  /// As opposed to [LazyFrame], [DataFrame] by default applies its operations eagerly.
  LazyFrame lazy(
          {bool? projectionPushdown,
          bool? predicatePushdown,
          bool? typeCoercion,
          bool? simplifyExpressions,
          bool? slicePushdown,
          bool? streaming,
          dynamic hint}) =>
      RustLib.instance.api.dataFrameLazy(
        that: this,
        projectionPushdown: projectionPushdown,
        predicatePushdown: predicatePushdown,
        typeCoercion: typeCoercion,
        simplifyExpressions: simplifyExpressions,
        slicePushdown: slicePushdown,
        streaming: streaming,
      );

  /// Aggregate the columns to their maximum values.
  Future<DataFrame> max({dynamic hint}) => RustLib.instance.api.dataFrameMax(
        that: this,
      );

  /// Returns a new, empty dataframe.
  static DataFrame of({required OptionVecSeries series, dynamic hint}) =>
      RustLib.instance.api.dataFrameOf(series: series, hint: hint);

  /// Returns a dataframe with columns from this dataframe in reverse order.
  DataFrame reverse({dynamic hint}) => RustLib.instance.api.dataFrameReverse(
        that: this,
      );

  /// Sample [n] datapoints from this dataframe.
  Future<DataFrame> sample(
          {required Series n,
          bool withReplacement = false,
          bool shuffle = false,
          int? seed,
          dynamic hint}) =>
      RustLib.instance.api.dataFrameSample(
        that: this,
        n: n,
        withReplacement: withReplacement,
        shuffle: shuffle,
        seed: seed,
      );

  /// Returns the [Schema] of this dataframe.
  Schema schema({dynamic hint}) => RustLib.instance.api.dataFrameSchema(
        that: this,
      );

  /// Makes a new dataframe with the specified columns from this dataframe.
  DataFrame select({required List<String> columns, dynamic hint}) =>
      RustLib.instance.api.dataFrameSelect(
        that: this,
        columns: columns,
      );

  /// Returns the height and width of this dataframe.
  Shape shape({dynamic hint}) => RustLib.instance.api.dataFrameShape(
        that: this,
      );

  void sortInPlace(
          {List<String> byColumn = const [],
          List<bool> descending = const [],
          bool maintainOrder = false,
          dynamic hint}) =>
      RustLib.instance.api.dataFrameSortInPlace(
        that: this,
        byColumn: byColumn,
        descending: descending,
        maintainOrder: maintainOrder,
      );

  /// Returns the last few rows of this dataframe.
  DataFrame tail({int? length, dynamic hint}) =>
      RustLib.instance.api.dataFrameTail(
        that: this,
        length: length,
      );

  /// Returns the width of this dataframe, aka the number of columns.
  int width({dynamic hint}) => RustLib.instance.api.dataFrameWidth(
        that: this,
      );

  /// Add a new column at index 0 denoting the row number.
  DataFrame withRowCount({required String name, int? offset, dynamic hint}) =>
      RustLib.instance.api.dataFrameWithRowCount(
        that: this,
        name: name,
        offset: offset,
      );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Expr>>
@sealed
class Expr extends RustOpaque {
  Expr.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  Expr.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Expr,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Expr,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ExprPtr,
  );

  Expr abs({dynamic hint}) => RustLib.instance.api.exprAbs(
        that: this,
      );

  Expr add({required Expr other, dynamic hint}) => RustLib.instance.api.exprAdd(
        that: this,
        other: other,
      );

  Expr aggGroups({dynamic hint}) => RustLib.instance.api.exprAggGroups(
        that: this,
      );

  Expr alias({required String name, dynamic hint}) =>
      RustLib.instance.api.exprAlias(
        that: this,
        name: name,
      );

  Expr all({bool ignoreNulls = false, dynamic hint}) =>
      RustLib.instance.api.exprAll(
        that: this,
        ignoreNulls: ignoreNulls,
      );

  Expr and({required Expr expr, dynamic hint}) => RustLib.instance.api.exprAnd(
        that: this,
        expr: expr,
      );

  Expr any({bool ignoreNulls = false, dynamic hint}) =>
      RustLib.instance.api.exprAny(
        that: this,
        ignoreNulls: ignoreNulls,
      );

  Expr append({required Expr other, bool upcast = true, dynamic hint}) =>
      RustLib.instance.api.exprAppend(
        that: this,
        other: other,
        upcast: upcast,
      );

  Expr arccos({dynamic hint}) => RustLib.instance.api.exprArccos(
        that: this,
      );

  Expr arccosh({dynamic hint}) => RustLib.instance.api.exprArccosh(
        that: this,
      );

  Expr arcsin({dynamic hint}) => RustLib.instance.api.exprArcsin(
        that: this,
      );

  Expr arcsinh({dynamic hint}) => RustLib.instance.api.exprArcsinh(
        that: this,
      );

  Expr arctan({dynamic hint}) => RustLib.instance.api.exprArctan(
        that: this,
      );

  Expr arctan2({required Expr x, dynamic hint}) =>
      RustLib.instance.api.exprArctan2(
        that: this,
        x: x,
      );

  Expr arctanh({dynamic hint}) => RustLib.instance.api.exprArctanh(
        that: this,
      );

  Expr argMax({dynamic hint}) => RustLib.instance.api.exprArgMax(
        that: this,
      );

  Expr argMin({dynamic hint}) => RustLib.instance.api.exprArgMin(
        that: this,
      );

  Expr argSort(
          {bool descending = false,
          bool nullsLast = false,
          bool multithreaded = true,
          bool maintainOrder = false,
          dynamic hint}) =>
      RustLib.instance.api.exprArgSort(
        that: this,
        descending: descending,
        nullsLast: nullsLast,
        multithreaded: multithreaded,
        maintainOrder: maintainOrder,
      );

  Expr argUnique({dynamic hint}) => RustLib.instance.api.exprArgUnique(
        that: this,
      );

  Expr backwardFill({int? limit, dynamic hint}) =>
      RustLib.instance.api.exprBackwardFill(
        that: this,
        limit: limit,
      );

  Expr cast({required DataType dataType, dynamic hint}) =>
      RustLib.instance.api.exprCast(
        that: this,
        dataType: dataType,
      );

  Expr cbrt({dynamic hint}) => RustLib.instance.api.exprCbrt(
        that: this,
      );

  Expr ceil({dynamic hint}) => RustLib.instance.api.exprCeil(
        that: this,
      );

  Expr clip({required Expr min, required Expr max, dynamic hint}) =>
      RustLib.instance.api.exprClip(
        that: this,
        min: min,
        max: max,
      );

  Expr clipMax({required Expr max, dynamic hint}) =>
      RustLib.instance.api.exprClipMax(
        that: this,
        max: max,
      );

  Expr clipMin({required Expr min, dynamic hint}) =>
      RustLib.instance.api.exprClipMin(
        that: this,
        min: min,
      );

  Expr cos({dynamic hint}) => RustLib.instance.api.exprCos(
        that: this,
      );

  Expr cosh({dynamic hint}) => RustLib.instance.api.exprCosh(
        that: this,
      );

  /// Calculate the cotangent of this expression.
  Expr cot({dynamic hint}) => RustLib.instance.api.exprCot(
        that: this,
      );

  Expr count({dynamic hint}) => RustLib.instance.api.exprCount(
        that: this,
      );

  Expr cumCount({bool reverse = false, dynamic hint}) =>
      RustLib.instance.api.exprCumCount(
        that: this,
        reverse: reverse,
      );

  Expr cumMax({bool reverse = false, dynamic hint}) =>
      RustLib.instance.api.exprCumMax(
        that: this,
        reverse: reverse,
      );

  Expr cumMin({bool reverse = false, dynamic hint}) =>
      RustLib.instance.api.exprCumMin(
        that: this,
        reverse: reverse,
      );

  Expr cumProd({bool reverse = false, dynamic hint}) =>
      RustLib.instance.api.exprCumProd(
        that: this,
        reverse: reverse,
      );

  Expr cumSum({bool reverse = false, dynamic hint}) =>
      RustLib.instance.api.exprCumSum(
        that: this,
        reverse: reverse,
      );

  Expr degrees({dynamic hint}) => RustLib.instance.api.exprDegrees(
        that: this,
      );

  Expr div({required Expr other, dynamic hint}) => RustLib.instance.api.exprDiv(
        that: this,
        other: other,
      );

  Expr dot({required Expr other, dynamic hint}) => RustLib.instance.api.exprDot(
        that: this,
        other: other,
      );

  Expr dropNans({dynamic hint}) => RustLib.instance.api.exprDropNans(
        that: this,
      );

  Expr dropNulls({dynamic hint}) => RustLib.instance.api.exprDropNulls(
        that: this,
      );

  Expr entropy({required double base, bool normalize = false, dynamic hint}) =>
      RustLib.instance.api.exprEntropy(
        that: this,
        base: base,
        normalize: normalize,
      );

  Expr eq({required Expr other, dynamic hint}) => RustLib.instance.api.exprEq(
        that: this,
        other: other,
      );

  Expr eqMissing({required Expr other, dynamic hint}) =>
      RustLib.instance.api.exprEqMissing(
        that: this,
        other: other,
      );

  Expr exclude({required List<String> columns, dynamic hint}) =>
      RustLib.instance.api.exprExclude(
        that: this,
        columns: columns,
      );

  Expr excludeDtype({required List<DataType> dtypes, dynamic hint}) =>
      RustLib.instance.api.exprExcludeDtype(
        that: this,
        dtypes: dtypes,
      );

  Expr exp({dynamic hint}) => RustLib.instance.api.exprExp(
        that: this,
      );

  Expr explode({dynamic hint}) => RustLib.instance.api.exprExplode(
        that: this,
      );

  Expr fillNan({required Expr value, dynamic hint}) =>
      RustLib.instance.api.exprFillNan(
        that: this,
        value: value,
      );

  Expr fillNull({required Expr value, dynamic hint}) =>
      RustLib.instance.api.exprFillNull(
        that: this,
        value: value,
      );

  Expr filter({required Expr cond, dynamic hint}) =>
      RustLib.instance.api.exprFilter(
        that: this,
        cond: cond,
      );

  Expr first({dynamic hint}) => RustLib.instance.api.exprFirst(
        that: this,
      );

  Expr flatten({dynamic hint}) => RustLib.instance.api.exprFlatten(
        that: this,
      );

  Expr floor({dynamic hint}) => RustLib.instance.api.exprFloor(
        that: this,
      );

  Expr floorDiv({required Expr rhs, dynamic hint}) =>
      RustLib.instance.api.exprFloorDiv(
        that: this,
        rhs: rhs,
      );

  Expr forwardFill({int? limit, dynamic hint}) =>
      RustLib.instance.api.exprForwardFill(
        that: this,
        limit: limit,
      );

  Expr gather({required Expr idx, dynamic hint}) =>
      RustLib.instance.api.exprGather(
        that: this,
        idx: idx,
      );

  /// Similar to [gather] but allows for scalars.
  Expr get({required Expr idx, dynamic hint}) => RustLib.instance.api.exprGet(
        that: this,
        idx: idx,
      );

  Expr gt({required Expr other, dynamic hint}) => RustLib.instance.api.exprGt(
        that: this,
        other: other,
      );

  Expr gtEq({required Expr other, dynamic hint}) =>
      RustLib.instance.api.exprGtEq(
        that: this,
        other: other,
      );

  Expr head({int? length, dynamic hint}) => RustLib.instance.api.exprHead(
        that: this,
        length: length,
      );

  Expr implode({dynamic hint}) => RustLib.instance.api.exprImplode(
        that: this,
      );

  Expr isFinite({dynamic hint}) => RustLib.instance.api.exprIsFinite(
        that: this,
      );

  Expr isIn({required Expr other, dynamic hint}) =>
      RustLib.instance.api.exprIsIn(
        that: this,
        other: other,
      );

  Expr isNan({dynamic hint}) => RustLib.instance.api.exprIsNan(
        that: this,
      );

  Expr isNotNan({dynamic hint}) => RustLib.instance.api.exprIsNotNan(
        that: this,
      );

  Expr isNotNull({dynamic hint}) => RustLib.instance.api.exprIsNotNull(
        that: this,
      );

  Expr isNull({dynamic hint}) => RustLib.instance.api.exprIsNull(
        that: this,
      );

  Expr last({dynamic hint}) => RustLib.instance.api.exprLast(
        that: this,
      );

  Expr log({required double base, dynamic hint}) =>
      RustLib.instance.api.exprLog(
        that: this,
        base: base,
      );

  Expr log1P({dynamic hint}) => RustLib.instance.api.exprLog1P(
        that: this,
      );

  Expr lowerBound({dynamic hint}) => RustLib.instance.api.exprLowerBound(
        that: this,
      );

  Expr lt({required Expr other, dynamic hint}) => RustLib.instance.api.exprLt(
        that: this,
        other: other,
      );

  Expr ltEq({required Expr other, dynamic hint}) =>
      RustLib.instance.api.exprLtEq(
        that: this,
        other: other,
      );

  Expr mul({required Expr other, dynamic hint}) => RustLib.instance.api.exprMul(
        that: this,
        other: other,
      );

  Expr nUnique({dynamic hint}) => RustLib.instance.api.exprNUnique(
        that: this,
      );

  Expr nanMax({dynamic hint}) => RustLib.instance.api.exprNanMax(
        that: this,
      );

  Expr nanMin({dynamic hint}) => RustLib.instance.api.exprNanMin(
        that: this,
      );

  Expr neq({required Expr other, dynamic hint}) => RustLib.instance.api.exprNeq(
        that: this,
        other: other,
      );

  Expr neqMissing({required Expr other, dynamic hint}) =>
      RustLib.instance.api.exprNeqMissing(
        that: this,
        other: other,
      );

  Expr not({dynamic hint}) => RustLib.instance.api.exprNot(
        that: this,
      );

  Expr nullCount({dynamic hint}) => RustLib.instance.api.exprNullCount(
        that: this,
      );

  Expr or({required Expr expr, dynamic hint}) => RustLib.instance.api.exprOr(
        that: this,
        expr: expr,
      );

  Expr over({required VecExpr partiionBy, WindowMapping? kind, dynamic hint}) =>
      RustLib.instance.api.exprOver(
        that: this,
        partiionBy: partiionBy,
        kind: kind,
      );

  Expr pow({required double exponent, dynamic hint}) =>
      RustLib.instance.api.exprPow(
        that: this,
        exponent: exponent,
      );

  Expr product({dynamic hint}) => RustLib.instance.api.exprProduct(
        that: this,
      );

  Expr quantile(
          {required Expr quantile,
          QuantileInterpolOptions? interpol,
          dynamic hint}) =>
      RustLib.instance.api.exprQuantile(
        that: this,
        quantile: quantile,
        interpol: interpol,
      );

  Expr radians({dynamic hint}) => RustLib.instance.api.exprRadians(
        that: this,
      );

  Expr rem({required Expr other, dynamic hint}) => RustLib.instance.api.exprRem(
        that: this,
        other: other,
      );

  Expr reshape({required Int64List dims, dynamic hint}) =>
      RustLib.instance.api.exprReshape(
        that: this,
        dims: dims,
      );

  Expr reverse({dynamic hint}) => RustLib.instance.api.exprReverse(
        that: this,
      );

  Expr rollingMax(
          {Duration? windowSize,
          int? minPeriods,
          Float64List? weights,
          bool center = false,
          String? by,
          ClosedWindow? closedWindow,
          dynamic hint}) =>
      RustLib.instance.api.exprRollingMax(
        that: this,
        windowSize: windowSize,
        minPeriods: minPeriods,
        weights: weights,
        center: center,
        by: by,
        closedWindow: closedWindow,
      );

  Expr rollingMean(
          {Duration? windowSize,
          int? minPeriods,
          Float64List? weights,
          bool center = false,
          String? by,
          ClosedWindow? closedWindow,
          dynamic hint}) =>
      RustLib.instance.api.exprRollingMean(
        that: this,
        windowSize: windowSize,
        minPeriods: minPeriods,
        weights: weights,
        center: center,
        by: by,
        closedWindow: closedWindow,
      );

  Expr rollingMedian(
          {Duration? windowSize,
          int? minPeriods,
          Float64List? weights,
          bool center = false,
          String? by,
          ClosedWindow? closedWindow,
          dynamic hint}) =>
      RustLib.instance.api.exprRollingMedian(
        that: this,
        windowSize: windowSize,
        minPeriods: minPeriods,
        weights: weights,
        center: center,
        by: by,
        closedWindow: closedWindow,
      );

  Expr rollingMin(
          {Duration? windowSize,
          int? minPeriods,
          Float64List? weights,
          bool center = false,
          String? by,
          ClosedWindow? closedWindow,
          dynamic hint}) =>
      RustLib.instance.api.exprRollingMin(
        that: this,
        windowSize: windowSize,
        minPeriods: minPeriods,
        weights: weights,
        center: center,
        by: by,
        closedWindow: closedWindow,
      );

  Expr rollingQuantile(
          {Duration? windowSize,
          int? minPeriods,
          Float64List? weights,
          bool center = false,
          String? by,
          ClosedWindow? closedWindow,
          dynamic hint}) =>
      RustLib.instance.api.exprRollingQuantile(
        that: this,
        windowSize: windowSize,
        minPeriods: minPeriods,
        weights: weights,
        center: center,
        by: by,
        closedWindow: closedWindow,
      );

  Expr rollingStd(
          {Duration? windowSize,
          int? minPeriods,
          Float64List? weights,
          bool center = false,
          String? by,
          ClosedWindow? closedWindow,
          dynamic hint}) =>
      RustLib.instance.api.exprRollingStd(
        that: this,
        windowSize: windowSize,
        minPeriods: minPeriods,
        weights: weights,
        center: center,
        by: by,
        closedWindow: closedWindow,
      );

  Expr rollingSum(
          {Duration? windowSize,
          int? minPeriods,
          Float64List? weights,
          bool center = false,
          String? by,
          ClosedWindow? closedWindow,
          dynamic hint}) =>
      RustLib.instance.api.exprRollingSum(
        that: this,
        windowSize: windowSize,
        minPeriods: minPeriods,
        weights: weights,
        center: center,
        by: by,
        closedWindow: closedWindow,
      );

  Expr rollingVar(
          {Duration? windowSize,
          int? minPeriods,
          Float64List? weights,
          bool center = false,
          String? by,
          ClosedWindow? closedWindow,
          dynamic hint}) =>
      RustLib.instance.api.exprRollingVar(
        that: this,
        windowSize: windowSize,
        minPeriods: minPeriods,
        weights: weights,
        center: center,
        by: by,
        closedWindow: closedWindow,
      );

  Expr round({required int decimals, dynamic hint}) =>
      RustLib.instance.api.exprRound(
        that: this,
        decimals: decimals,
      );

  Expr roundSigFigs({required int digits, dynamic hint}) =>
      RustLib.instance.api.exprRoundSigFigs(
        that: this,
        digits: digits,
      );

  Expr setSortedFlag({required IsSorted sorted, dynamic hint}) =>
      RustLib.instance.api.exprSetSortedFlag(
        that: this,
        sorted: sorted,
      );

  Expr shift({required Expr n, dynamic hint}) => RustLib.instance.api.exprShift(
        that: this,
        n: n,
      );

  Expr shiftAndFill({required Expr n, required Expr fillValue, dynamic hint}) =>
      RustLib.instance.api.exprShiftAndFill(
        that: this,
        n: n,
        fillValue: fillValue,
      );

  Expr shrinkDtype({dynamic hint}) => RustLib.instance.api.exprShrinkDtype(
        that: this,
      );

  Expr sin({dynamic hint}) => RustLib.instance.api.exprSin(
        that: this,
      );

  Expr sinh({dynamic hint}) => RustLib.instance.api.exprSinh(
        that: this,
      );

  Expr slice({required Expr offset, required Expr length, dynamic hint}) =>
      RustLib.instance.api.exprSlice(
        that: this,
        offset: offset,
        length: length,
      );

  Expr sort(
          {bool descending = false,
          bool nullsLast = false,
          bool multithreaded = true,
          bool maintainOrder = false,
          dynamic hint}) =>
      RustLib.instance.api.exprSort(
        that: this,
        descending: descending,
        nullsLast: nullsLast,
        multithreaded: multithreaded,
        maintainOrder: maintainOrder,
      );

  Expr sqrt({dynamic hint}) => RustLib.instance.api.exprSqrt(
        that: this,
      );

  Expr std({required int ddof, dynamic hint}) => RustLib.instance.api.exprStd(
        that: this,
        ddof: ddof,
      );

  Expr strictCast({required DataType dataType, dynamic hint}) =>
      RustLib.instance.api.exprStrictCast(
        that: this,
        dataType: dataType,
      );

  Expr sub({required Expr other, dynamic hint}) => RustLib.instance.api.exprSub(
        that: this,
        other: other,
      );

  Expr sum({dynamic hint}) => RustLib.instance.api.exprSum(
        that: this,
      );

  Expr tail({int? length, dynamic hint}) => RustLib.instance.api.exprTail(
        that: this,
        length: length,
      );

  Expr tan({dynamic hint}) => RustLib.instance.api.exprTan(
        that: this,
      );

  Expr tanh({dynamic hint}) => RustLib.instance.api.exprTanh(
        that: this,
      );

  Expr then({required Expr value, required Expr otherwise, dynamic hint}) =>
      RustLib.instance.api.exprThen(
        that: this,
        value: value,
        otherwise: otherwise,
      );

  /// Returns a dot representation of this expression.
  String toDot({dynamic hint}) => RustLib.instance.api.exprToDot(
        that: this,
      );

  Expr toPhysical({dynamic hint}) => RustLib.instance.api.exprToPhysical(
        that: this,
      );

  Expr unique({dynamic hint}) => RustLib.instance.api.exprUnique(
        that: this,
      );

  Expr uniqueStable({dynamic hint}) => RustLib.instance.api.exprUniqueStable(
        that: this,
      );

  Expr upperBound({dynamic hint}) => RustLib.instance.api.exprUpperBound(
        that: this,
      );

  Expr valueCounts({bool sort = false, bool parallel = true, dynamic hint}) =>
      RustLib.instance.api.exprValueCounts(
        that: this,
        sort: sort,
        parallel: parallel,
      );

  Expr variance({required int ddof, dynamic hint}) =>
      RustLib.instance.api.exprVariance(
        that: this,
        ddof: ddof,
      );

  Future<void> what({dynamic hint}) => RustLib.instance.api.exprWhat(
        that: this,
      );

  Expr xor({required Expr expr, dynamic hint}) => RustLib.instance.api.exprXor(
        that: this,
        expr: expr,
      );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<LazyFrame>>
@sealed
class LazyFrame extends RustOpaque {
  LazyFrame.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  LazyFrame.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_LazyFrame,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_LazyFrame,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_LazyFramePtr,
  );

  /// Caches the results into a new [LazyFrame].
  ///
  /// This should be used to prevent computations running multiple times.
  LazyFrame cache({dynamic hint}) => RustLib.instance.api.lazyFrameCache(
        that: this,
      );

  /// Executes all lazy operations and collects results into a [DataFrame].
  Future<DataFrame> collect({dynamic hint}) =>
      RustLib.instance.api.lazyFrameCollect(
        that: this,
      );

  /// Creates the [Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product) from both frames,
  /// preserving the order of this frame's keys.
  LazyFrame crossJoin({required LazyFrame other, dynamic hint}) =>
      RustLib.instance.api.lazyFrameCrossJoin(
        that: this,
        other: other,
      );

  /// Drop null rows.
  ///
  /// Same as `frame.filter(col('*').isNotNull)`.
  LazyFrame dropNulls({required OptionVecExpr subset, dynamic hint}) =>
      RustLib.instance.api.lazyFrameDropNulls(
        that: this,
        subset: subset,
      );

  /// Explode each column.
  LazyFrame explode({required VecExpr columns, dynamic hint}) =>
      RustLib.instance.api.lazyFrameExplode(
        that: this,
        columns: columns,
      );

  /// Similar to [collect], but overrides the number of rows read by each operation.
  ///
  /// The final row count is not guaranteed to be equal [nRows].
  Future<DataFrame> fetch({required int nRows, dynamic hint}) =>
      RustLib.instance.api.lazyFrameFetch(
        that: this,
        nRows: nRows,
      );

  /// Filter by the specified predicate expression.
  LazyFrame filter({required Expr pred, dynamic hint}) =>
      RustLib.instance.api.lazyFrameFilter(
        that: this,
        pred: pred,
      );

  /// Get the first row.
  LazyFrame first({dynamic hint}) => RustLib.instance.api.lazyFrameFirst(
        that: this,
      );

  /// Define conditions by which to group and aggregate rows.
  LazyGroupBy groupBy(
          {required VecExpr exprs, bool maintainOrder = false, dynamic hint}) =>
      RustLib.instance.api.lazyFrameGroupBy(
        that: this,
        exprs: exprs,
        maintainOrder: maintainOrder,
      );

  /// Performs an [inner join](https://en.wikipedia.org/wiki/Join_(SQL)#Inner_join_and_NULL_values) with [other].
  LazyFrame innerJoin(
          {required LazyFrame other,
          required Expr leftOn,
          required Expr rightOn,
          dynamic hint}) =>
      RustLib.instance.api.lazyFrameInnerJoin(
        that: this,
        other: other,
        leftOn: leftOn,
        rightOn: rightOn,
      );

  /// Joins this table to [other].
  ///
  /// Use [on] to specify columns on both frames to join on, or specify separately
  /// using [leftOn] and [rightOn].
  ///
  /// [suffix] specifies the suffix to add to duplicate columns of [other].
  ///
  /// Example:
  /// ```dart
  /// final joined = left
  ///   .join(
  ///     other: right,
  ///     leftOn: [col('foo'), col('bar')],
  ///     rightOn: [col('foo'), col('bar')],
  ///     how: JoinType.Inner,
  ///   );
  /// ```
  LazyFrame join(
          {required LazyFrame other,
          required OptionVecExpr on,
          required OptionVecExpr leftOn,
          required OptionVecExpr rightOn,
          String suffix = r"_right",
          JoinType how = JoinType.left,
          bool allowParallel = true,
          bool forceParallel = false,
          dynamic hint}) =>
      RustLib.instance.api.lazyFrameJoin(
        that: this,
        other: other,
        on: on,
        leftOn: leftOn,
        rightOn: rightOn,
        suffix: suffix,
        how: how,
        allowParallel: allowParallel,
        forceParallel: forceParallel,
      );

  /// Get the last row.
  LazyFrame last({dynamic hint}) => RustLib.instance.api.lazyFrameLast(
        that: this,
      );

  /// Performs a [left outer join](https://en.wikipedia.org/wiki/Join_(SQL)#Left_outer_join) with [other].
  LazyFrame leftJoin(
          {required LazyFrame other,
          required Expr leftOn,
          required Expr rightOn,
          dynamic hint}) =>
      RustLib.instance.api.lazyFrameLeftJoin(
        that: this,
        other: other,
        leftOn: leftOn,
        rightOn: rightOn,
      );

  /// Limit this dataframe to the first [n] rows.
  ///
  /// To avoid scanning the rows, use [fetch].
  LazyFrame limit({required int n, dynamic hint}) =>
      RustLib.instance.api.lazyFrameLimit(
        that: this,
        n: n,
      );

  /// Aggregate all columns as their max values.
  LazyFrame max({dynamic hint}) => RustLib.instance.api.lazyFrameMax(
        that: this,
      );

  /// Aggregate all columns as their means.
  LazyFrame mean({dynamic hint}) => RustLib.instance.api.lazyFrameMean(
        that: this,
      );

  /// Aggregate all columns as their medians.
  LazyFrame median({dynamic hint}) => RustLib.instance.api.lazyFrameMedian(
        that: this,
      );

  /// Melt this dataframe from the wide format to the long format.
  LazyFrame melt(
          {required List<String> idVars,
          required List<String> valueVars,
          String? variableName,
          String? valueName,
          bool streamable = true,
          dynamic hint}) =>
      RustLib.instance.api.lazyFrameMelt(
        that: this,
        idVars: idVars,
        valueVars: valueVars,
        variableName: variableName,
        valueName: valueName,
        streamable: streamable,
      );

  /// Aggregate all columns as their min values.
  LazyFrame min({dynamic hint}) => RustLib.instance.api.lazyFrameMin(
        that: this,
      );

  /// Performs a [full outer join](https://en.wikipedia.org/wiki/Join_(SQL)#Full_outer_join) with [other].
  LazyFrame outerJoin(
          {required LazyFrame other,
          required Expr leftOn,
          required Expr rightOn,
          dynamic hint}) =>
      RustLib.instance.api.lazyFrameOuterJoin(
        that: this,
        other: other,
        leftOn: leftOn,
        rightOn: rightOn,
      );

  /// Aggregate all columns as their quantiles.
  LazyFrame quantile(
          {required Expr quantile,
          required QuantileInterpolOptions interpol,
          dynamic hint}) =>
      RustLib.instance.api.lazyFrameQuantile(
        that: this,
        quantile: quantile,
        interpol: interpol,
      );

  /// Reverse the order of this dataframe's columns.
  LazyFrame reverse({dynamic hint}) => RustLib.instance.api.lazyFrameReverse(
        that: this,
      );

  /// Select (and rename) columns from the query.
  LazyFrame select({required VecExpr exprs, dynamic hint}) =>
      RustLib.instance.api.lazyFrameSelect(
        that: this,
        exprs: exprs,
      );

  /// Slice the frame.
  LazyFrame slice({required int offset, required int len, dynamic hint}) =>
      RustLib.instance.api.lazyFrameSlice(
        that: this,
        offset: offset,
        len: len,
      );

  /// Aggregate all columns as their standard deviances.
  LazyFrame std({required int ddof, dynamic hint}) =>
      RustLib.instance.api.lazyFrameStd(
        that: this,
        ddof: ddof,
      );

  /// Aggregate all columns as their sums.
  LazyFrame sum({dynamic hint}) => RustLib.instance.api.lazyFrameSum(
        that: this,
      );

  /// Get the last [n] rows.
  LazyFrame tail({required int n, dynamic hint}) =>
      RustLib.instance.api.lazyFrameTail(
        that: this,
        n: n,
      );

  /// Keep unique rows without maintaining order.
  LazyFrame unique(
          {List<String>? subset,
          required UniqueKeepStrategy keepStrategy,
          dynamic hint}) =>
      RustLib.instance.api.lazyFrameUnique(
        that: this,
        subset: subset,
        keepStrategy: keepStrategy,
      );

  /// Aggregate all columns as their variances.
  LazyFrame variance({required int ddof, dynamic hint}) =>
      RustLib.instance.api.lazyFrameVariance(
        that: this,
        ddof: ddof,
      );

  /// Add a column to this dataframe.
  LazyFrame withColumn({required Expr expr, dynamic hint}) =>
      RustLib.instance.api.lazyFrameWithColumn(
        that: this,
        expr: expr,
      );

  /// Add columns to this dataframe.
  LazyFrame withColumns({required VecExpr exprs, dynamic hint}) =>
      RustLib.instance.api.lazyFrameWithColumns(
        that: this,
        exprs: exprs,
      );

  /// Add a new column at index 0 denoting the row number.
  LazyFrame withRowCount({required String name, int? offset, dynamic hint}) =>
      RustLib.instance.api.lazyFrameWithRowCount(
        that: this,
        name: name,
        offset: offset,
      );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<LazyGroupBy>>
@sealed
class LazyGroupBy extends RustOpaque {
  LazyGroupBy.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  LazyGroupBy.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_LazyGroupBy,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_LazyGroupBy,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_LazyGroupByPtr,
  );

  /// Group by and aggregate.
  ///
  /// Select a column with [col] and choose an aggregation. If you want to aggregate all columns
  /// use <code>[col]\("*")</code>.
  LazyFrame agg({required VecExpr exprs, dynamic hint}) =>
      RustLib.instance.api.lazyGroupByAgg(
        that: this,
        exprs: exprs,
      );

  /// Return the first [n] rows of each group.
  LazyFrame head({int? n, dynamic hint}) =>
      RustLib.instance.api.lazyGroupByHead(
        that: this,
        n: n,
      );

  /// Return the last [n] rows of each group.
  LazyFrame tail({int? n, dynamic hint}) =>
      RustLib.instance.api.lazyGroupByTail(
        that: this,
        n: n,
      );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<Schema>>>
@sealed
class OptionSchema extends RustOpaque {
  OptionSchema.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  OptionSchema.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_OptionSchema,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_OptionSchema,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OptionSchemaPtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<Vec<Expr>>>>
@sealed
class OptionVecExpr extends RustOpaque {
  OptionVecExpr.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  OptionVecExpr.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_OptionVecExpr,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_OptionVecExpr,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OptionVecExprPtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<Vec<Series>>>>
@sealed
class OptionVecSeries extends RustOpaque {
  OptionVecSeries.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  OptionVecSeries.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_OptionVecSeries,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_OptionVecSeries,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OptionVecSeriesPtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Schema>>
@sealed
class Schema extends RustOpaque {
  Schema.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  Schema.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Schema,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Schema,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SchemaPtr,
  );

  /// Create a schema from a list of [Field]s.
  static Schema of({required List<Field> fields, dynamic hint}) =>
      RustLib.instance.api.schemaOf(fields: fields, hint: hint);
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Series>>
@sealed
class Series extends RustOpaque {
  Series.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  Series.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Series,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Series,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SeriesPtr,
  );

  /// Returns a new series with elements from this series added to [other]'s element-wise.
  Series addTo({required Series other, dynamic hint}) =>
      RustLib.instance.api.seriesAddTo(
        that: this,
        other: other,
      );

  /// Adds the contents of [other] onto this series.
  ///
  /// Throws if [other] is self.
  void append({required Series other, dynamic hint}) =>
      RustLib.instance.api.seriesAppend(
        that: this,
        other: other,
      );

  /// Applies a binary operation onto this series with a scalar value.
  ///
  /// For logic operators, the new series is a boolean mask. Otherwise,
  /// it will be a series of numeric values.
  Series applyScalar(
          {required Operator op, required double value, dynamic hint}) =>
      RustLib.instance.api.seriesApplyScalar(
        that: this,
        op: op,
        value: value,
      );

  /// If compatible, returns a representation of this series as integers.
  Future<List<double?>> asDoubles({bool strict = true, dynamic hint}) =>
      RustLib.instance.api.seriesAsDoubles(
        that: this,
        strict: strict,
      );

  /// If this series contains [Duration]s, returns its Dart representation.
  List<Duration?> asDurations({dynamic hint}) =>
      RustLib.instance.api.seriesAsDurations(
        that: this,
      );

  /// If compatible, returns a representation of this series as integers.
  List<int?> asInts({bool strict = true, dynamic hint}) =>
      RustLib.instance.api.seriesAsInts(
        that: this,
        strict: strict,
      );

  /// If this series contains [DateTime]s, returns its Dart representation.
  ///
  /// If a timezone is defined by this series, the datetimes will be converted to the local timezone.
  /// Otherwise, the datetimes are assumed to be in the local timezone.
  List<DateTime?> asLocalDatetime({dynamic hint}) =>
      RustLib.instance.api.seriesAsLocalDatetime(
        that: this,
      );

  /// If this series contains [DateTime]s, returns its Dart representation.
  ///
  /// Datetimes are parsed as-is, without any timezone correction.
  List<DateTime?> asNaiveDatetime({dynamic hint}) =>
      RustLib.instance.api.seriesAsNaiveDatetime(
        that: this,
      );

  /// If this series is a UTF-8 series, returns its Dart representation.
  List<String?> asStrings({dynamic hint}) =>
      RustLib.instance.api.seriesAsStrings(
        that: this,
      );

  /// If this series contains [DateTime]s, returns its Dart representation.
  ///
  /// If a timezone is defined by this series, the datetimes will be converted to UTC.
  /// Otherwise, the datetimes are assumed to be in UTC.
  List<DateTime?> asUtcDatetime({dynamic hint}) =>
      RustLib.instance.api.seriesAsUtcDatetime(
        that: this,
      );

  /// Casts this series into one with the specified datatype.
  Series cast({required DataType dtype, bool strict = true, dynamic hint}) =>
      RustLib.instance.api.seriesCast(
        that: this,
        dtype: dtype,
        strict: strict,
      );

  /// Returns a new series with elements from this series divided by [other]'s element-wise.
  Series divide({required Series other, dynamic hint}) =>
      RustLib.instance.api.seriesDivide(
        that: this,
        other: other,
      );

  /// Dump the contents of this entire series.
  String dump({dynamic hint}) => RustLib.instance.api.seriesDump(
        that: this,
      );

  /// Returns whether this series is identical to [other].
  ///
  /// if `ignoreNull` is true, null values are considered to be equal.
  bool equal({required Series other, bool ignoreNull = false, dynamic hint}) =>
      RustLib.instance.api.seriesEqual(
        that: this,
        other: other,
        ignoreNull: ignoreNull,
      );

  /// Returns the amount of bytes occupied by this series.
  int estimatedSize({dynamic hint}) => RustLib.instance.api.seriesEstimatedSize(
        that: this,
      );

  /// Expands a series of lists into rows of values, or strings into rows of characters.
  Series explode({dynamic hint}) => RustLib.instance.api.seriesExplode(
        that: this,
      );

  /// TODO: docs
  Series explodeByOffsets({required Int64List offsets, dynamic hint}) =>
      RustLib.instance.api.seriesExplodeByOffsets(
        that: this,
        offsets: offsets,
      );

  /// Get the value at [index] as a double.
  double? get({required int index, dynamic hint}) =>
      RustLib.instance.api.seriesGet(
        that: this,
        index: index,
      );

  /// Get the value at [index] as a string.
  String? getString({required int index, dynamic hint}) =>
      RustLib.instance.api.seriesGetString(
        that: this,
        index: index,
      );

  /// Get the first few values of this series.
  Series head({int? length, dynamic hint}) => RustLib.instance.api.seriesHead(
        that: this,
        length: length,
      );

  /// Casts this series into a [DataFrame]. May create a copy.
  DataFrame intoFrame({dynamic hint}) => RustLib.instance.api.seriesIntoFrame(
        that: this,
      );

  /// Returns whether this is a series of booleans.
  bool isBool({dynamic hint}) => RustLib.instance.api.seriesIsBool(
        that: this,
      );

  /// Returns whether this is a series of numeric values.
  bool isNumeric({dynamic hint}) => RustLib.instance.api.seriesIsNumeric(
        that: this,
      );

  /// Returns whether this is a series of [DateTime] or [Duration]s.
  bool isTemporal({dynamic hint}) => RustLib.instance.api.seriesIsTemporal(
        that: this,
      );

  /// Returns whether this is a series of UTF-8 strings.
  bool isUtf8({dynamic hint}) => RustLib.instance.api.seriesIsUtf8(
        that: this,
      );

  /// Iterate over this series' values.
  Stream<dynamic> iter({dynamic hint}) => RustLib.instance.api.seriesIter(
        that: this,
      );

  /// Returns the maximum value of this series' values.
  ///
  /// Returns null if one of the values are also null.
  double? max({dynamic hint}) => RustLib.instance.api.seriesMax(
        that: this,
      );

  /// Calculates the mean (average) of this series.
  double? mean({dynamic hint}) => RustLib.instance.api.seriesMean(
        that: this,
      );

  /// Calculates and wraps this series' mean as a single-element series.
  Series meanAsSeries({dynamic hint}) =>
      RustLib.instance.api.seriesMeanAsSeries(
        that: this,
      );

  /// Calculates the [median](https://en.wikipedia.org/wiki/Median) of this series.
  double? median({dynamic hint}) => RustLib.instance.api.seriesMedian(
        that: this,
      );

  /// Calculates and wraps this series' median as a single-element series.
  Series medianAsSeries({dynamic hint}) =>
      RustLib.instance.api.seriesMedianAsSeries(
        that: this,
      );

  /// Returns the minimum value of this series' values.
  ///
  /// Returns null if one of the values are also null.
  double? min({dynamic hint}) => RustLib.instance.api.seriesMin(
        that: this,
      );

  /// Returns a new series with elements from this series multiplied with [other]'s element-wise.
  Series multiply({required Series other, dynamic hint}) =>
      RustLib.instance.api.seriesMultiply(
        that: this,
        other: other,
      );

  static Series ofBools(
          {required String name, List<bool>? values, dynamic hint}) =>
      RustLib.instance.api
          .seriesOfBools(name: name, values: values, hint: hint);

  /// Create a new series of doubles.
  static Series ofDoubles(
          {required String name, List<double?>? values, dynamic hint}) =>
      RustLib.instance.api
          .seriesOfDoubles(name: name, values: values, hint: hint);

  /// Create a new series of [Duration]s.
  static Series ofDurations(
          {required String name,
          List<Duration?>? values,
          TimeUnit unit = TimeUnit.milliseconds,
          dynamic hint}) =>
      RustLib.instance.api.seriesOfDurations(
          name: name, values: values, unit: unit, hint: hint);

  /// Create a new series of 32-bit wide integers.
  static Series ofI32(
          {required String name, List<int?>? values, dynamic hint}) =>
      RustLib.instance.api.seriesOfI32(name: name, values: values, hint: hint);

  /// Create a new series of 64-bit wide integers.
  static Series ofInts(
          {required String name, List<int?>? values, dynamic hint}) =>
      RustLib.instance.api.seriesOfInts(name: name, values: values, hint: hint);

  /// Create a new series of strings.
  static Series ofStrings(
          {required String name, List<String?>? values, dynamic hint}) =>
      RustLib.instance.api
          .seriesOfStrings(name: name, values: values, hint: hint);

  /// Calculates the product of each element in the series and returns it in a single-element series.
  Series product({dynamic hint}) => RustLib.instance.api.seriesProduct(
        that: this,
      );

  /// Returns a new series with the [remainder](https://en.wikipedia.org/wiki/Remainder)
  /// between this series' and [other]'s elements.
  Series remainder({required Series other, dynamic hint}) =>
      RustLib.instance.api.seriesRemainder(
        that: this,
        other: other,
      );

  /// Rename this series to [name] in-place.
  void rename({required String name, dynamic hint}) =>
      RustLib.instance.api.seriesRename(
        that: this,
        name: name,
      );

  /// Creates a new series with the specified dimensions.
  Series reshape({required Int64List dims, dynamic hint}) =>
      RustLib.instance.api.seriesReshape(
        that: this,
        dims: dims,
      );

  /// Returns a new shuffled series.
  Series shuffle({int? seed, dynamic hint}) =>
      RustLib.instance.api.seriesShuffle(
        that: this,
        seed: seed,
      );

  /// Returns a new sorted series.
  Series sort({bool reverse = false, dynamic hint}) =>
      RustLib.instance.api.seriesSort(
        that: this,
        reverse: reverse,
      );

  /// Calculates the standard deviation of this series with the specified degree of freedom.
  Series stdAsSeries({required int ddof, dynamic hint}) =>
      RustLib.instance.api.seriesStdAsSeries(
        that: this,
        ddof: ddof,
      );

  /// Returns a new series with elements from this series subtracted from [other]'s element-wise.
  Series subtract({required Series other, dynamic hint}) =>
      RustLib.instance.api.seriesSubtract(
        that: this,
        other: other,
      );

  /// Sums all non-null rows in this series to produce a result.
  ///
  /// Returns null if the series only contains null values.
  double? sum({dynamic hint}) => RustLib.instance.api.seriesSum(
        that: this,
      );

  /// Returns the sum of this series' values as a single-element series.
  Series sumAsSeries({dynamic hint}) => RustLib.instance.api.seriesSumAsSeries(
        that: this,
      );

  /// Get the last few values of this series.
  Series tail({int? length, dynamic hint}) => RustLib.instance.api.seriesTail(
        that: this,
        length: length,
      );

  /// Returns an untyped list.
  List<dynamic> toList({dynamic hint}) => RustLib.instance.api.seriesToList(
        that: this,
      );

  /// Returns the unique values of this series.
  ///
  /// If `stable` is true, extra work is done to maintain the original order of elements.
  Future<Series> unique({bool maintainOrder = false, dynamic hint}) =>
      RustLib.instance.api.seriesUnique(
        that: this,
        maintainOrder: maintainOrder,
      );

  /// Calculates the variance of this series with the specified degree of freedom.
  Series varAsSeries({required int ddof, dynamic hint}) =>
      RustLib.instance.api.seriesVarAsSeries(
        that: this,
        ddof: ddof,
      );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Vec<Expr>>>
@sealed
class VecExpr extends RustOpaque {
  VecExpr.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  VecExpr.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VecExpr,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VecExpr,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_VecExprPtr,
  );
}

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Vec<Series>>>
@sealed
class VecSeries extends RustOpaque {
  VecSeries.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  VecSeries.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VecSeries,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VecSeries,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_VecSeriesPtr,
  );
}

enum ClosedWindow {
  left,
  right,
  both,
  none,
}

/// Options for CSV encoding.
enum CsvEncoding {
  /// Utf8 encoding
  utf8,

  /// Utf8 encoding and unknown bytes are replaced with 
  lossyUtf8,
}

@freezed
sealed class DataType with _$DataType {
  /// Boolean
  const factory DataType.boolean() = DataType_Boolean;

  /// Unsigned 8-bit integer
  const factory DataType.uInt8() = DataType_UInt8;

  /// Unsigned 16-bit integer
  const factory DataType.uInt16() = DataType_UInt16;

  /// Unsigned 32-bit integer
  const factory DataType.uInt32() = DataType_UInt32;

  /// Unsigned 64-bit integer
  const factory DataType.uInt64() = DataType_UInt64;

  /// Signed 8-bit integer
  const factory DataType.int8() = DataType_Int8;

  /// Signed 16-bit integer
  const factory DataType.int16() = DataType_Int16;

  /// Signed 32-bit integer
  const factory DataType.int32() = DataType_Int32;

  /// Signed 64-bit integer, the default [int] on native platforms.
  const factory DataType.int64() = DataType_Int64;

  /// Single-precision floating point number
  const factory DataType.float32() = DataType_Float32;

  /// Double-precision floating point number, aka a [double].
  const factory DataType.float64() = DataType_Float64;

  /// String data
  const factory DataType.utf8() = DataType_Utf8;

  /// Raw bytes.
  const factory DataType.binary() = DataType_Binary;

  /// A 32-bit date representing the elapsed time since UNIX epoch (1970-01-01)
  /// in days (32 bits).
  const factory DataType.date() = DataType_Date;

  /// A 64-bit date representing the elapsed time since UNIX epoch (1970-01-01)
  /// in the given timeunit (64 bits).
  const factory DataType.datetime(
    TimeUnit field0, [
    String? field1,
  ]) = DataType_Datetime;

  /// 64-bit integer representing difference between times in milliseconds or nanoseconds
  const factory DataType.duration(
    TimeUnit field0,
  ) = DataType_Duration;

  /// A 64-bit time representing the elapsed time since midnight in nanoseconds
  const factory DataType.time() = DataType_Time;

  /// A typed list.
  const factory DataType.list(
    DataType field0,
  ) = DataType_List;

  /// Null value.
  const factory DataType.Null() = DataType_Null;

  /// Structured data.
  const factory DataType.struct(
    List<Field> field0,
  ) = DataType_Struct;

  /// Some logical types we cannot know statically, e.g. Datetime
  const factory DataType.unknown() = DataType_Unknown;
}

/// Fields in a struct.
class Field {
  /// The field's name.
  final String name;

  /// The field's data type.
  final DataType dtype;

  const Field({
    required this.name,
    required this.dtype,
  });

  @override
  int get hashCode => name.hashCode ^ dtype.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Field &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          dtype == other.dtype;
}

enum IsSorted {
  ascending,
  descending,
  not,
}

/// Options for joining.
enum JoinType {
  /// Left outer join.
  left,

  /// Inner join.
  inner,

  /// Full outer join.
  outer,

  /// Cartesian (cross-product) join.
  cross,

  /// [Semijoin](https://en.wikipedia.org/wiki/Relational_algebra#Semijoin_(%E2%8B%89_and_%E2%8B%8A)).
  semi,

  /// [Antijoin](https://en.wikipedia.org/wiki/Relational_algebra#Antijoin_(%E2%96%B7)).
  anti,
}

@freezed
sealed class LiteralValue with _$LiteralValue {
  /// Null value.
  const factory LiteralValue.Null() = LiteralValue_Null;

  /// A binary true or false.
  const factory LiteralValue.boolean(
    bool field0,
  ) = LiteralValue_Boolean;

  /// A UTF8 encoded string type.
  const factory LiteralValue.utf8(
    String field0,
  ) = LiteralValue_Utf8;

  /// A raw binary array
  const factory LiteralValue.binary(
    Uint8List field0,
  ) = LiteralValue_Binary;

  /// An unsigned 8-bit integer number.
  const factory LiteralValue.uInt8(
    int field0,
  ) = LiteralValue_UInt8;

  /// An unsigned 16-bit integer number.
  const factory LiteralValue.uInt16(
    int field0,
  ) = LiteralValue_UInt16;

  /// An unsigned 32-bit integer number.
  const factory LiteralValue.uInt32(
    int field0,
  ) = LiteralValue_UInt32;

  /// An unsigned 64-bit integer number.
  const factory LiteralValue.uInt64(
    int field0,
  ) = LiteralValue_UInt64;

  /// An 8-bit integer number.
  const factory LiteralValue.int8(
    int field0,
  ) = LiteralValue_Int8;

  /// A 16-bit integer number.
  const factory LiteralValue.int16(
    int field0,
  ) = LiteralValue_Int16;

  /// A 32-bit integer number.
  const factory LiteralValue.int32(
    int field0,
  ) = LiteralValue_Int32;

  /// A 64-bit integer number.
  const factory LiteralValue.int64(
    int field0,
  ) = LiteralValue_Int64;

  /// A 32-bit floating point number.
  const factory LiteralValue.float32(
    double field0,
  ) = LiteralValue_Float32;

  /// A 64-bit floating point number.
  const factory LiteralValue.float64(
    double field0,
  ) = LiteralValue_Float64;

  /// A range between integers.
  const factory LiteralValue.range({
    /// The starting value of the range.
    required int low,

    /// The ending value of the range.
    required int high,

    /// The datatype of this range's ends.
    required DataType dataType,
  }) = LiteralValue_Range;

  /// Datetimes.
  const factory LiteralValue.dateTime(
    int field0,
    TimeUnit field1, [
    String? field2,
  ]) = LiteralValue_DateTime;

  /// Durations.
  const factory LiteralValue.duration(
    int field0,
    TimeUnit field1,
  ) = LiteralValue_Duration;
  const factory LiteralValue.date(
    int field0,
  ) = LiteralValue_Date;
  const factory LiteralValue.time(
    int field0,
  ) = LiteralValue_Time;
}

@freezed
sealed class NullValues with _$NullValues {
  /// A single value that's used for all columns
  const factory NullValues.allColumnsSingle(
    String field0,
  ) = NullValues_AllColumnsSingle;

  /// Multiple values that are used for all columns
  const factory NullValues.allColumns(
    List<String> field0,
  ) = NullValues_AllColumns;

  /// Tuples that map column names to null value of that column
  const factory NullValues.named(
    List<(String, String)> field0,
  ) = NullValues_Named;
}

/// Operators for binary operations between [Expr]essions.
enum Operator {
  /// ==
  eq,
  eqValidity,

  /// !=
  notEq,
  notEqValidity,

  /// <
  lt,

  /// <=
  ltEq,

  /// >
  gt,

  /// >=
  gtEq,

  /// +
  plus,

  /// -
  minus,

  /// *
  multiply,

  /// /
  divide,

  /// ~/
  trueDivide,

  /// Divides and floors to the nearest integer.
  floorDivide,

  /// %
  modulus,

  /// &&
  and,

  /// ||
  or,

  /// ^
  xor,
}

enum QuantileInterpolOptions {
  nearest,
  lower,
  higher,
  midpoint,
  linear,
}

/// Options for including a row count column.
class RowCount {
  /// Name of the new column.
  final String name;

  /// The value from which to start counting.
  final int offset;

  const RowCount({
    required this.name,
    required this.offset,
  });

  @override
  int get hashCode => name.hashCode ^ offset.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RowCount &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          offset == other.offset;
}

/// Describes the shape of a [DataFrame].
class Shape {
  /// The number of rows.
  final int height;

  /// The number of columns.
  final int width;

  const Shape({
    required this.height,
    required this.width,
  });

  @override
  int get hashCode => height.hashCode ^ width.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Shape &&
          runtimeType == other.runtimeType &&
          height == other.height &&
          width == other.width;
}

/// Possible units of time for dataframe values.
enum TimeUnit {
  /// One-billionth of a second.
  nanoseconds,

  /// One-millionth of a second.
  microseconds,

  /// One-thousandth of a second.
  milliseconds,
}

/// Options for keeping unique values.
enum UniqueKeepStrategy {
  /// TODO: Doc
  first,

  /// TODO: Doc
  last,
  none,
  any,
}

enum WindowMapping {
  /// Map the group vlues to the position
  groupsToRows,

  /// Explode the aggregated list and just do a hstack instead of a join
  /// this requires the groups to be sorted to make any sense
  explode,

  /// Join the groups as 'List<group_dtype>' to the row positions.
  /// warning: this can be memory intensive
  join,
}
