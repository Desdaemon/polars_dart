// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.6.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'df.dart';
import 'expr.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'entry.freezed.dart';

/// Reads a [.csv](https://en.wikipedia.org/wiki/Comma-separated_values) file into a [DataFrame].
///
/// - `columns`: Select only columns matching these names
/// - `delimiter`: Specify the delimiter for this file.
/// - `commentChar`: Ignore the rest of a line after encountering this character.
/// - `eolChar`: Stop reading after encountering this character.
/// - `quoteChar`: Specify the quote character, if set to null disables quoting.
/// - `skipRows`: Skip the first few rows, then parse the header and the dataframe.
/// - `skipRowsAfterHeader`: Skip this many rows after the header.
/// - `chunkSize`: Specify the chunk size of the internal parser. Performance knob.
/// - `nRows`: Try to read up to n rows then stop. Might not be honored in multithreading execution.
/// - `nullValues`: Specify values to be interpreted as null.
/// - `projection`: Select only columns at the specified indices.
/// - `rechunk`: Relocate the dataframe into contiguous memory after parsing.
///              Slow, but improves performance for later operations.
Future<DataFrame> readCsv(
        {required String path,
        List<DataType>? dtypesSlice,
        bool? hasHeader,
        List<String>? columns,
        String? commentChar,
        String? eolChar,
        int? chunkSize,
        int? sampleSize,
        RowCount? rowCount,
        CsvEncoding? encoding,
        int? nRows,
        int? nThreads,
        NullValues? nullValues,
        Uint32List? projection,
        String? quoteChar = '"',
        int skipRows = 0,
        int skipRowsAfterHeader = 0,
        bool ignoreErrors = false,
        bool rechunk = false,
        bool tryParseDates = true,
        bool lowMemory = false,
        dynamic hint}) =>
    RustLib.instance.api.readCsv(
        path: path,
        dtypesSlice: dtypesSlice,
        hasHeader: hasHeader,
        columns: columns,
        commentChar: commentChar,
        eolChar: eolChar,
        chunkSize: chunkSize,
        sampleSize: sampleSize,
        rowCount: rowCount,
        encoding: encoding,
        nRows: nRows,
        nThreads: nThreads,
        nullValues: nullValues,
        projection: projection,
        quoteChar: quoteChar,
        skipRows: skipRows,
        skipRowsAfterHeader: skipRowsAfterHeader,
        ignoreErrors: ignoreErrors,
        rechunk: rechunk,
        tryParseDates: tryParseDates,
        lowMemory: lowMemory,
        hint: hint);

/// Prepares a [.csv](https://en.wikipedia.org/wiki/Comma-separated_values) file for reading into a [LazyFrame].
///
/// - `delimiter`: Specify the delimiter for this file.
/// - `commentChar`: Ignore the rest of a line after encountering this character.
/// - `eolChar`: Stop reading after encountering this character.
/// - `quoteChar`: Specify the quote character, if set to null disables quoting.
/// - `skipRows`: Skip the first few rows, then parse the header and the dataframe.
/// - `skipRowsAfterHeader`: Skip this many rows after the header.
/// - `nRows`: Try to read up to n rows then stop. Might not be honored in multithreading execution.
/// - `nullValues`: Specify values to be interpreted as null.
/// - `rechunk`: Relocate the dataframe into contiguous memory after parsing.
///              Slow, but improves performance for later operations.
/// - `inferSchemaLength`: Specify how many rows to read to infer the schema, if null the entire table is scanned.
/// - `cache`: Cache the dataframe after reading.
Future<LazyFrame> scanCsv(
        {required String path,
        required OptionSchema dtypeOverwrite,
        bool? hasHeader,
        String? commentChar,
        String? eolChar,
        String? quoteChar = '"',
        int skipRows = 0,
        int skipRowsAfterHeader = 0,
        RowCount? rowCount,
        CsvEncoding? encoding,
        int? nRows,
        NullValues? nullValues,
        bool ignoreErrors = false,
        bool rechunk = false,
        bool tryParseDates = true,
        int? inferSchemaLength = 100,
        bool cache = false,
        dynamic hint}) =>
    RustLib.instance.api.scanCsv(
        path: path,
        dtypeOverwrite: dtypeOverwrite,
        hasHeader: hasHeader,
        commentChar: commentChar,
        eolChar: eolChar,
        quoteChar: quoteChar,
        skipRows: skipRows,
        skipRowsAfterHeader: skipRowsAfterHeader,
        rowCount: rowCount,
        encoding: encoding,
        nRows: nRows,
        nullValues: nullValues,
        ignoreErrors: ignoreErrors,
        rechunk: rechunk,
        tryParseDates: tryParseDates,
        inferSchemaLength: inferSchemaLength,
        cache: cache,
        hint: hint);

/// Reads a [.json](https://en.wikipedia.org/wiki/JSON) file into a [DataFrame].
Future<DataFrame> readJson(
        {required String path,
        int? batchSize,
        List<String>? projection,
        dynamic hint}) =>
    RustLib.instance.api.readJson(
        path: path, batchSize: batchSize, projection: projection, hint: hint);

// Rust type: flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<Schema>>>
@sealed
class OptionSchema extends RustOpaque {
  OptionSchema.dcoDecode(dynamic wire) : super.dcoDecode(wire, _kStaticData);

  OptionSchema.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_OptionSchema,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_OptionSchema,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_OptionSchemaPtr,
  );
}

/// Options for CSV encoding.
enum CsvEncoding {
  /// Utf8 encoding
  utf8,

  /// Utf8 encoding and unknown bytes are replaced with ï¿½
  lossyUtf8,
}

/// Options for joining.
enum JoinType {
  /// Left outer join.
  left,

  /// Inner join.
  inner,

  /// Full outer join.
  outer,

  /// Cartesian (cross-product) join.
  cross,

  /// [Semijoin](https://en.wikipedia.org/wiki/Relational_algebra#Semijoin_(%E2%8B%89_and_%E2%8B%8A)).
  semi,

  /// [Antijoin](https://en.wikipedia.org/wiki/Relational_algebra#Antijoin_(%E2%96%B7)).
  anti,
}

@freezed
sealed class NullValues with _$NullValues {
  /// A single value that's used for all columns
  const factory NullValues.allColumnsSingle(
    String field0,
  ) = NullValues_AllColumnsSingle;

  /// Multiple values that are used for all columns
  const factory NullValues.allColumns(
    List<String> field0,
  ) = NullValues_AllColumns;

  /// Tuples that map column names to null value of that column
  const factory NullValues.named(
    List<(String, String)> field0,
  ) = NullValues_Named;
}

enum QuantileInterpolOptions {
  nearest,
  lower,
  higher,
  midpoint,
  linear,
}

/// Options for including a row count column.
class RowCount {
  /// Name of the new column.
  final String name;

  /// The value from which to start counting.
  final int offset;

  const RowCount({
    required this.name,
    required this.offset,
  });

  @override
  int get hashCode => name.hashCode ^ offset.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RowCount &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          offset == other.offset;
}

/// Possible units of time for dataframe values.
enum TimeUnit {
  /// One-billionth of a second.
  nanoseconds,

  /// One-millionth of a second.
  microseconds,

  /// One-thousandth of a second.
  milliseconds,
}
