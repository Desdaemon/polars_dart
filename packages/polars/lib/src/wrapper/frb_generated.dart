// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.3.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables

import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'wrapper.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'polars-wrapper',
    ioDirectory: '../../polars-wrapper/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Series dataFrameColumn(
      {required DataFrame that, required String column, dynamic hint});

  Series dataFrameColumnAt(
      {required DataFrame that, required int index, dynamic hint});

  Series dataFrameColumns(
      {required DataFrame that, required List<String> columns, dynamic hint});

  Future<DataFrame> dataFrameDescribe(
      {required DataFrame that, Float64List? percentiles, dynamic hint});

  DataFrame dataFrameDrop(
      {required DataFrame that, required String column, dynamic hint});

  Series dataFrameDropInPlace(
      {required DataFrame that, required String column, dynamic hint});

  List<DataType> dataFrameDtypes({required DataFrame that, dynamic hint});

  String dataFrameDump({required DataFrame that, dynamic hint});

  int dataFrameEstimatedSize({required DataFrame that, dynamic hint});

  List<String> dataFrameGetColumnNames({required DataFrame that, dynamic hint});

  Series dataFrameGetColumns({required DataFrame that, dynamic hint});

  Future<List<dynamic>> dataFrameGetRow(
      {required DataFrame that, required int index, dynamic hint});

  DataFrame dataFrameHead({required DataFrame that, int? length, dynamic hint});

  int dataFrameHeight({required DataFrame that, dynamic hint});

  bool dataFrameIsEmpty({required DataFrame that, dynamic hint});

  Future<LazyFrame> dataFrameLazy(
      {required DataFrame that,
      bool? projectionPushdown,
      bool? predicatePushdown,
      bool? typeCoercion,
      bool? simplifyExpressions,
      bool? slicePushdown,
      bool? streaming,
      dynamic hint});

  Future<DataFrame> dataFrameMax({required DataFrame that, dynamic hint});

  DataFrame dataFrameOf({required Series series, dynamic hint});

  DataFrame dataFrameReverse({required DataFrame that, dynamic hint});

  Future<DataFrame> dataFrameSample(
      {required DataFrame that,
      required Series n,
      bool withReplacement = false,
      bool shuffle = false,
      int? seed,
      dynamic hint});

  Schema dataFrameSchema({required DataFrame that, dynamic hint});

  DataFrame dataFrameSelect(
      {required DataFrame that, required List<String> columns, dynamic hint});

  Shape dataFrameShape({required DataFrame that, dynamic hint});

  Future<void> dataFrameSortInPlace(
      {required DataFrame that,
      List<String> byColumn = const [],
      List<bool> descending = const [],
      bool maintainOrder = true,
      dynamic hint});

  DataFrame dataFrameTail({required DataFrame that, int? length, dynamic hint});

  int dataFrameWidth({required DataFrame that, dynamic hint});

  DataFrame dataFrameWithRowCount(
      {required DataFrame that,
      required String name,
      int? offset,
      dynamic hint});

  LazyFrame lazyFrameCache({required LazyFrame that, dynamic hint});

  Future<DataFrame> lazyFrameCollect({required LazyFrame that, dynamic hint});

  LazyFrame lazyFrameCrossJoin(
      {required LazyFrame that, required LazyFrame other, dynamic hint});

  LazyFrame lazyFrameDropNulls(
      {required LazyFrame that, List<Expr>? subset, dynamic hint});

  LazyFrame lazyFrameExplode(
      {required LazyFrame that, required List<Expr> columns, dynamic hint});

  Future<DataFrame> lazyFrameFetch(
      {required LazyFrame that, required int nRows, dynamic hint});

  LazyFrame lazyFrameFilter(
      {required LazyFrame that, required Expr pred, dynamic hint});

  LazyFrame lazyFrameFirst({required LazyFrame that, dynamic hint});

  LazyGroupBy lazyFrameGroupBy(
      {required LazyFrame that,
      required List<Expr> exprs,
      bool maintainOrder = false,
      dynamic hint});

  LazyFrame lazyFrameInnerJoin(
      {required LazyFrame that,
      required LazyFrame other,
      required Expr leftOn,
      required Expr rightOn,
      dynamic hint});

  Future<LazyFrame> lazyFrameJoin(
      {required LazyFrame that,
      required LazyFrame other,
      List<Expr>? on,
      List<Expr>? leftOn,
      List<Expr>? rightOn,
      String suffix = r"_right",
      JoinType how = JoinType.left,
      bool allowParallel = true,
      bool forceParallel = false,
      dynamic hint});

  LazyFrame lazyFrameLast({required LazyFrame that, dynamic hint});

  LazyFrame lazyFrameLeftJoin(
      {required LazyFrame that,
      required LazyFrame other,
      required Expr leftOn,
      required Expr rightOn,
      dynamic hint});

  LazyFrame lazyFrameLimit(
      {required LazyFrame that, required int n, dynamic hint});

  LazyFrame lazyFrameMax({required LazyFrame that, dynamic hint});

  LazyFrame lazyFrameMean({required LazyFrame that, dynamic hint});

  LazyFrame lazyFrameMedian({required LazyFrame that, dynamic hint});

  LazyFrame lazyFrameMelt(
      {required LazyFrame that,
      required List<String> idVars,
      required List<String> valueVars,
      String? variableName,
      String? valueName,
      bool streamable = true,
      dynamic hint});

  Future<LazyFrame> lazyFrameMin({required LazyFrame that, dynamic hint});

  LazyFrame lazyFrameOuterJoin(
      {required LazyFrame that,
      required LazyFrame other,
      required Expr leftOn,
      required Expr rightOn,
      dynamic hint});

  LazyFrame lazyFrameQuantile(
      {required LazyFrame that,
      required Expr quantile,
      required QuantileInterpolOptions interpol,
      dynamic hint});

  LazyFrame lazyFrameReverse({required LazyFrame that, dynamic hint});

  LazyFrame lazyFrameSlice(
      {required LazyFrame that,
      required int offset,
      required int len,
      dynamic hint});

  LazyFrame lazyFrameStd(
      {required LazyFrame that, required int ddof, dynamic hint});

  LazyFrame lazyFrameSum({required LazyFrame that, dynamic hint});

  LazyFrame lazyFrameTail(
      {required LazyFrame that, required int n, dynamic hint});

  LazyFrame lazyFrameUnique(
      {required LazyFrame that,
      List<String>? subset,
      required UniqueKeepStrategy keepStrategy,
      dynamic hint});

  LazyFrame lazyFrameVariance(
      {required LazyFrame that, required int ddof, dynamic hint});

  LazyFrame lazyFrameWithColumn(
      {required LazyFrame that, required Expr expr, dynamic hint});

  LazyFrame lazyFrameWithRowCount(
      {required LazyFrame that,
      required String name,
      int? offset,
      dynamic hint});

  LazyFrame lazyGroupByHead({required LazyGroupBy that, int? n, dynamic hint});

  LazyFrame lazyGroupByTail({required LazyGroupBy that, int? n, dynamic hint});

  Schema schemaOf({required List<Field> fields, dynamic hint});

  Series seriesAddTo(
      {required Series that, required Series other, dynamic hint});

  Future<void> seriesAppend(
      {required Series that, required Series other, dynamic hint});

  Future<Series> seriesApplyScalar(
      {required Series that,
      required Operator op,
      required double value,
      dynamic hint});

  Future<List<double?>> seriesAsDoubles(
      {required Series that, bool strict = true, dynamic hint});

  Future<List<Duration?>> seriesAsDurations(
      {required Series that, dynamic hint});

  Future<List<int?>> seriesAsInts(
      {required Series that, bool strict = true, dynamic hint});

  Future<List<DateTime?>> seriesAsLocalDatetime(
      {required Series that, dynamic hint});

  Future<List<DateTime?>> seriesAsNaiveDatetime(
      {required Series that, dynamic hint});

  Future<List<String?>> seriesAsStrings({required Series that, dynamic hint});

  Future<List<DateTime?>> seriesAsUtcDatetime(
      {required Series that, dynamic hint});

  Future<Series> seriesCast(
      {required Series that,
      required DataType dtype,
      bool strict = true,
      dynamic hint});

  Series seriesDivide(
      {required Series that, required Series other, dynamic hint});

  Future<String> seriesDump({required Series that, dynamic hint});

  Future<bool> seriesEqual(
      {required Series that,
      required Series other,
      bool ignoreNull = false,
      dynamic hint});

  int seriesEstimatedSize({required Series that, dynamic hint});

  Future<Series> seriesExplode({required Series that, dynamic hint});

  Future<Series> seriesExplodeByOffsets(
      {required Series that, required Int64List offsets, dynamic hint});

  double? seriesGet({required Series that, required int index, dynamic hint});

  String? seriesGetString(
      {required Series that, required int index, dynamic hint});

  Series seriesHead({required Series that, int? length, dynamic hint});

  DataFrame seriesIntoFrame({required Series that, dynamic hint});

  bool seriesIsBool({required Series that, dynamic hint});

  bool seriesIsNumeric({required Series that, dynamic hint});

  bool seriesIsTemporal({required Series that, dynamic hint});

  bool seriesIsUtf8({required Series that, dynamic hint});

  Future<double?> seriesMax({required Series that, dynamic hint});

  Future<double?> seriesMean({required Series that, dynamic hint});

  Future<Series> seriesMeanAsSeries({required Series that, dynamic hint});

  Future<double?> seriesMedian({required Series that, dynamic hint});

  Future<Series> seriesMedianAsSeries({required Series that, dynamic hint});

  Future<double?> seriesMin({required Series that, dynamic hint});

  Series seriesMultiply(
      {required Series that, required Series other, dynamic hint});

  Series seriesOfBools(
      {required String name, List<bool>? values, dynamic hint});

  Series seriesOfDoubles(
      {required String name, List<double?>? values, dynamic hint});

  Series seriesOfDurations(
      {required String name,
      List<Duration?>? values,
      TimeUnit unit = TimeUnit.milliseconds,
      dynamic hint});

  Series seriesOfI32({required String name, List<int?>? values, dynamic hint});

  Series seriesOfInts({required String name, List<int?>? values, dynamic hint});

  Series seriesOfStrings(
      {required String name, List<String?>? values, dynamic hint});

  Future<Series> seriesProduct({required Series that, dynamic hint});

  Series seriesRemainder(
      {required Series that, required Series other, dynamic hint});

  void seriesRename({required Series that, required String name, dynamic hint});

  Future<Series> seriesReshape(
      {required Series that, required Int64List dims, dynamic hint});

  Future<Series> seriesShuffle({required Series that, int? seed, dynamic hint});

  Future<Series> seriesSort(
      {required Series that, bool reverse = false, dynamic hint});

  Future<Series> seriesStdAsSeries(
      {required Series that, required int ddof, dynamic hint});

  Series seriesSubtract(
      {required Series that, required Series other, dynamic hint});

  Future<double?> seriesSum({required Series that, dynamic hint});

  Future<Series> seriesSumAsSeries({required Series that, dynamic hint});

  Series seriesTail({required Series that, int? length, dynamic hint});

  Future<dynamic> seriesToList({required Series that, dynamic hint});

  Future<Series> seriesUnique(
      {required Series that, bool stable = false, dynamic hint});

  Future<Series> seriesVarAsSeries(
      {required Series that, required int ddof, dynamic hint});

  Future<DataFrame> readCsv(
      {required String path,
      List<DataType>? dtypesSlice,
      bool? hasHeader,
      List<String>? columns,
      String? commentChar,
      String? eolChar,
      int? chunkSize,
      int? sampleSize,
      RowCount? rowCount,
      CsvEncoding? encoding,
      int? nRows,
      int? nThreads,
      NullValues? nullValues,
      Uint32List? projection,
      String? quoteChar = '"',
      int skipRows = 0,
      int skipRowsAfterHeader = 0,
      bool ignoreErrors = false,
      bool rechunk = false,
      bool tryParseDates = true,
      bool lowMemory = false,
      dynamic hint});

  Future<DataFrame> readJson(
      {required String path,
      int? batchSize,
      List<String>? projection,
      dynamic hint});

  Future<LazyFrame> scanCsv(
      {required String path,
      required Schema dtypeOverwrite,
      bool? hasHeader,
      String? commentChar,
      String? eolChar,
      String? quoteChar = '"',
      int skipRows = 0,
      int skipRowsAfterHeader = 0,
      RowCount? rowCount,
      CsvEncoding? encoding,
      int? nRows,
      NullValues? nullValues,
      bool ignoreErrors = false,
      bool rechunk = false,
      bool tryParseDates = true,
      int? inferSchemaLength = 100,
      bool cache = false,
      dynamic hint});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Series;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Series;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SeriesPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Schema;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Schema;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SchemaPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Series;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Series;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SeriesPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DataFrame;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DataFrame;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_DataFramePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LazyFrame;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LazyFrame;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_LazyFramePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LazyGroupBy;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LazyGroupBy;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_LazyGroupByPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Schema;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Schema;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SchemaPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Series;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Series;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SeriesPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Series dataFrameColumn(
      {required DataFrame that, required String column, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_String(column);
        return wire.wire_DataFrame_column(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameColumnConstMeta,
      argValues: [that, column],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameColumnConstMeta => const TaskConstMeta(
        debugName: "DataFrame_column",
        argNames: ["that", "column"],
      );

  @override
  Series dataFrameColumnAt(
      {required DataFrame that, required int index, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_usize(index);
        return wire.wire_DataFrame_column_at(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameColumnAtConstMeta,
      argValues: [that, index],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameColumnAtConstMeta => const TaskConstMeta(
        debugName: "DataFrame_column_at",
        argNames: ["that", "index"],
      );

  @override
  Series dataFrameColumns(
      {required DataFrame that, required List<String> columns, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_list_String(columns);
        return wire.wire_DataFrame_columns(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockVeccratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameColumnsConstMeta,
      argValues: [that, columns],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameColumnsConstMeta => const TaskConstMeta(
        debugName: "DataFrame_columns",
        argNames: ["that", "columns"],
      );

  @override
  Future<DataFrame> dataFrameDescribe(
      {required DataFrame that, Float64List? percentiles, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_opt_list_prim_f_64(percentiles);
        return wire.wire_DataFrame_describe(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameDescribeConstMeta,
      argValues: [that, percentiles],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameDescribeConstMeta => const TaskConstMeta(
        debugName: "DataFrame_describe",
        argNames: ["that", "percentiles"],
      );

  @override
  DataFrame dataFrameDrop(
      {required DataFrame that, required String column, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_String(column);
        return wire.wire_DataFrame_drop(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameDropConstMeta,
      argValues: [that, column],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameDropConstMeta => const TaskConstMeta(
        debugName: "DataFrame_drop",
        argNames: ["that", "column"],
      );

  @override
  Series dataFrameDropInPlace(
      {required DataFrame that, required String column, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_String(column);
        return wire.wire_DataFrame_drop_in_place(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameDropInPlaceConstMeta,
      argValues: [that, column],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameDropInPlaceConstMeta => const TaskConstMeta(
        debugName: "DataFrame_drop_in_place",
        argNames: ["that", "column"],
      );

  @override
  List<DataType> dataFrameDtypes({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_dtypes(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_data_type,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameDtypesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameDtypesConstMeta => const TaskConstMeta(
        debugName: "DataFrame_dtypes",
        argNames: ["that"],
      );

  @override
  String dataFrameDump({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_dump(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameDumpConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameDumpConstMeta => const TaskConstMeta(
        debugName: "DataFrame_dump",
        argNames: ["that"],
      );

  @override
  int dataFrameEstimatedSize({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_estimated_size(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameEstimatedSizeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameEstimatedSizeConstMeta => const TaskConstMeta(
        debugName: "DataFrame_estimated_size",
        argNames: ["that"],
      );

  @override
  List<String> dataFrameGetColumnNames(
      {required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_get_column_names(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameGetColumnNamesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameGetColumnNamesConstMeta => const TaskConstMeta(
        debugName: "DataFrame_get_column_names",
        argNames: ["that"],
      );

  @override
  Series dataFrameGetColumns({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_get_columns(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockVeccratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameGetColumnsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameGetColumnsConstMeta => const TaskConstMeta(
        debugName: "DataFrame_get_columns",
        argNames: ["that"],
      );

  @override
  Future<List<dynamic>> dataFrameGetRow(
      {required DataFrame that, required int index, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_usize(index);
        return wire.wire_DataFrame_get_row(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_dartabi,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameGetRowConstMeta,
      argValues: [that, index],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameGetRowConstMeta => const TaskConstMeta(
        debugName: "DataFrame_get_row",
        argNames: ["that", "index"],
      );

  @override
  DataFrame dataFrameHead(
      {required DataFrame that, int? length, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_opt_box_autoadd_usize(length);
        return wire.wire_DataFrame_head(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameHeadConstMeta,
      argValues: [that, length],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameHeadConstMeta => const TaskConstMeta(
        debugName: "DataFrame_head",
        argNames: ["that", "length"],
      );

  @override
  int dataFrameHeight({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_height(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameHeightConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameHeightConstMeta => const TaskConstMeta(
        debugName: "DataFrame_height",
        argNames: ["that"],
      );

  @override
  bool dataFrameIsEmpty({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_is_empty(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameIsEmptyConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameIsEmptyConstMeta => const TaskConstMeta(
        debugName: "DataFrame_is_empty",
        argNames: ["that"],
      );

  @override
  Future<LazyFrame> dataFrameLazy(
      {required DataFrame that,
      bool? projectionPushdown,
      bool? predicatePushdown,
      bool? typeCoercion,
      bool? simplifyExpressions,
      bool? slicePushdown,
      bool? streaming,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_opt_box_autoadd_bool(projectionPushdown);
        var arg2 = cst_encode_opt_box_autoadd_bool(predicatePushdown);
        var arg3 = cst_encode_opt_box_autoadd_bool(typeCoercion);
        var arg4 = cst_encode_opt_box_autoadd_bool(simplifyExpressions);
        var arg5 = cst_encode_opt_box_autoadd_bool(slicePushdown);
        var arg6 = cst_encode_opt_box_autoadd_bool(streaming);
        return wire.wire_DataFrame_lazy(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameLazyConstMeta,
      argValues: [
        that,
        projectionPushdown,
        predicatePushdown,
        typeCoercion,
        simplifyExpressions,
        slicePushdown,
        streaming
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameLazyConstMeta => const TaskConstMeta(
        debugName: "DataFrame_lazy",
        argNames: [
          "that",
          "projectionPushdown",
          "predicatePushdown",
          "typeCoercion",
          "simplifyExpressions",
          "slicePushdown",
          "streaming"
        ],
      );

  @override
  Future<DataFrame> dataFrameMax({required DataFrame that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_max(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameMaxConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameMaxConstMeta => const TaskConstMeta(
        debugName: "DataFrame_max",
        argNames: ["that"],
      );

  @override
  DataFrame dataFrameOf({required Series series, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries(
                series);
        return wire.wire_DataFrame_of(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameOfConstMeta,
      argValues: [series],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameOfConstMeta => const TaskConstMeta(
        debugName: "DataFrame_of",
        argNames: ["series"],
      );

  @override
  DataFrame dataFrameReverse({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_reverse(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameReverseConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameReverseConstMeta => const TaskConstMeta(
        debugName: "DataFrame_reverse",
        argNames: ["that"],
      );

  @override
  Future<DataFrame> dataFrameSample(
      {required DataFrame that,
      required Series n,
      bool withReplacement = false,
      bool shuffle = false,
      int? seed,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(n);
        var arg2 = cst_encode_bool(withReplacement);
        var arg3 = cst_encode_bool(shuffle);
        var arg4 = cst_encode_opt_box_autoadd_u_64(seed);
        return wire.wire_DataFrame_sample(port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameSampleConstMeta,
      argValues: [that, n, withReplacement, shuffle, seed],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameSampleConstMeta => const TaskConstMeta(
        debugName: "DataFrame_sample",
        argNames: ["that", "n", "withReplacement", "shuffle", "seed"],
      );

  @override
  Schema dataFrameSchema({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_schema(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSchema,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameSchemaConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameSchemaConstMeta => const TaskConstMeta(
        debugName: "DataFrame_schema",
        argNames: ["that"],
      );

  @override
  DataFrame dataFrameSelect(
      {required DataFrame that, required List<String> columns, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_list_String(columns);
        return wire.wire_DataFrame_select(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameSelectConstMeta,
      argValues: [that, columns],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameSelectConstMeta => const TaskConstMeta(
        debugName: "DataFrame_select",
        argNames: ["that", "columns"],
      );

  @override
  Shape dataFrameShape({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_shape(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_shape,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameShapeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameShapeConstMeta => const TaskConstMeta(
        debugName: "DataFrame_shape",
        argNames: ["that"],
      );

  @override
  Future<void> dataFrameSortInPlace(
      {required DataFrame that,
      List<String> byColumn = const [],
      List<bool> descending = const [],
      bool maintainOrder = true,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_RefMut_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_list_String(byColumn);
        var arg2 = cst_encode_list_bool(descending);
        var arg3 = cst_encode_bool(maintainOrder);
        return wire.wire_DataFrame_sort_in_place(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameSortInPlaceConstMeta,
      argValues: [that, byColumn, descending, maintainOrder],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameSortInPlaceConstMeta => const TaskConstMeta(
        debugName: "DataFrame_sort_in_place",
        argNames: ["that", "byColumn", "descending", "maintainOrder"],
      );

  @override
  DataFrame dataFrameTail(
      {required DataFrame that, int? length, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_opt_box_autoadd_usize(length);
        return wire.wire_DataFrame_tail(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameTailConstMeta,
      argValues: [that, length],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameTailConstMeta => const TaskConstMeta(
        debugName: "DataFrame_tail",
        argNames: ["that", "length"],
      );

  @override
  int dataFrameWidth({required DataFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        return wire.wire_DataFrame_width(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameWidthConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameWidthConstMeta => const TaskConstMeta(
        debugName: "DataFrame_width",
        argNames: ["that"],
      );

  @override
  DataFrame dataFrameWithRowCount(
      {required DataFrame that,
      required String name,
      int? offset,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
                that);
        var arg1 = cst_encode_String(name);
        var arg2 = cst_encode_opt_box_autoadd_u_32(offset);
        return wire.wire_DataFrame_with_row_count(arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kDataFrameWithRowCountConstMeta,
      argValues: [that, name, offset],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDataFrameWithRowCountConstMeta => const TaskConstMeta(
        debugName: "DataFrame_with_row_count",
        argNames: ["that", "name", "offset"],
      );

  @override
  LazyFrame lazyFrameCache({required LazyFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_cache(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameCacheConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameCacheConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_cache",
        argNames: ["that"],
      );

  @override
  Future<DataFrame> lazyFrameCollect({required LazyFrame that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_collect(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameCollectConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameCollectConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_collect",
        argNames: ["that"],
      );

  @override
  LazyFrame lazyFrameCrossJoin(
      {required LazyFrame that, required LazyFrame other, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                other);
        return wire.wire_LazyFrame_cross_join(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameCrossJoinConstMeta,
      argValues: [that, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameCrossJoinConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_cross_join",
        argNames: ["that", "other"],
      );

  @override
  LazyFrame lazyFrameDropNulls(
      {required LazyFrame that, List<Expr>? subset, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_opt_list_expr(subset);
        return wire.wire_LazyFrame_drop_nulls(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: null,
      ),
      constMeta: kLazyFrameDropNullsConstMeta,
      argValues: [that, subset],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameDropNullsConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_drop_nulls",
        argNames: ["that", "subset"],
      );

  @override
  LazyFrame lazyFrameExplode(
      {required LazyFrame that, required List<Expr> columns, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_list_expr(columns);
        return wire.wire_LazyFrame_explode(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: null,
      ),
      constMeta: kLazyFrameExplodeConstMeta,
      argValues: [that, columns],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameExplodeConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_explode",
        argNames: ["that", "columns"],
      );

  @override
  Future<DataFrame> lazyFrameFetch(
      {required LazyFrame that, required int nRows, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_usize(nRows);
        return wire.wire_LazyFrame_fetch(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameFetchConstMeta,
      argValues: [that, nRows],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameFetchConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_fetch",
        argNames: ["that", "nRows"],
      );

  @override
  LazyFrame lazyFrameFilter(
      {required LazyFrame that, required Expr pred, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_box_autoadd_expr(pred);
        return wire.wire_LazyFrame_filter(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameFilterConstMeta,
      argValues: [that, pred],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameFilterConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_filter",
        argNames: ["that", "pred"],
      );

  @override
  LazyFrame lazyFrameFirst({required LazyFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_first(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: null,
      ),
      constMeta: kLazyFrameFirstConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameFirstConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_first",
        argNames: ["that"],
      );

  @override
  LazyGroupBy lazyFrameGroupBy(
      {required LazyFrame that,
      required List<Expr> exprs,
      bool maintainOrder = false,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_list_expr(exprs);
        var arg2 = cst_encode_bool(maintainOrder);
        return wire.wire_LazyFrame_group_by(arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy,
        decodeErrorData: null,
      ),
      constMeta: kLazyFrameGroupByConstMeta,
      argValues: [that, exprs, maintainOrder],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameGroupByConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_group_by",
        argNames: ["that", "exprs", "maintainOrder"],
      );

  @override
  LazyFrame lazyFrameInnerJoin(
      {required LazyFrame that,
      required LazyFrame other,
      required Expr leftOn,
      required Expr rightOn,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                other);
        var arg2 = cst_encode_box_autoadd_expr(leftOn);
        var arg3 = cst_encode_box_autoadd_expr(rightOn);
        return wire.wire_LazyFrame_inner_join(arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameInnerJoinConstMeta,
      argValues: [that, other, leftOn, rightOn],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameInnerJoinConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_inner_join",
        argNames: ["that", "other", "leftOn", "rightOn"],
      );

  @override
  Future<LazyFrame> lazyFrameJoin(
      {required LazyFrame that,
      required LazyFrame other,
      List<Expr>? on,
      List<Expr>? leftOn,
      List<Expr>? rightOn,
      String suffix = r"_right",
      JoinType how = JoinType.left,
      bool allowParallel = true,
      bool forceParallel = false,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                other);
        var arg2 = cst_encode_opt_list_expr(on);
        var arg3 = cst_encode_opt_list_expr(leftOn);
        var arg4 = cst_encode_opt_list_expr(rightOn);
        var arg5 = cst_encode_String(suffix);
        var arg6 = cst_encode_join_type(how);
        var arg7 = cst_encode_bool(allowParallel);
        var arg8 = cst_encode_bool(forceParallel);
        return wire.wire_LazyFrame_join(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameJoinConstMeta,
      argValues: [
        that,
        other,
        on,
        leftOn,
        rightOn,
        suffix,
        how,
        allowParallel,
        forceParallel
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameJoinConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_join",
        argNames: [
          "that",
          "other",
          "on",
          "leftOn",
          "rightOn",
          "suffix",
          "how",
          "allowParallel",
          "forceParallel"
        ],
      );

  @override
  LazyFrame lazyFrameLast({required LazyFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_last(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: null,
      ),
      constMeta: kLazyFrameLastConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameLastConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_last",
        argNames: ["that"],
      );

  @override
  LazyFrame lazyFrameLeftJoin(
      {required LazyFrame that,
      required LazyFrame other,
      required Expr leftOn,
      required Expr rightOn,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                other);
        var arg2 = cst_encode_box_autoadd_expr(leftOn);
        var arg3 = cst_encode_box_autoadd_expr(rightOn);
        return wire.wire_LazyFrame_left_join(arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameLeftJoinConstMeta,
      argValues: [that, other, leftOn, rightOn],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameLeftJoinConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_left_join",
        argNames: ["that", "other", "leftOn", "rightOn"],
      );

  @override
  LazyFrame lazyFrameLimit(
      {required LazyFrame that, required int n, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_u_32(n);
        return wire.wire_LazyFrame_limit(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameLimitConstMeta,
      argValues: [that, n],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameLimitConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_limit",
        argNames: ["that", "n"],
      );

  @override
  LazyFrame lazyFrameMax({required LazyFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_max(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameMaxConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameMaxConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_max",
        argNames: ["that"],
      );

  @override
  LazyFrame lazyFrameMean({required LazyFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_mean(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameMeanConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameMeanConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_mean",
        argNames: ["that"],
      );

  @override
  LazyFrame lazyFrameMedian({required LazyFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_median(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameMedianConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameMedianConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_median",
        argNames: ["that"],
      );

  @override
  LazyFrame lazyFrameMelt(
      {required LazyFrame that,
      required List<String> idVars,
      required List<String> valueVars,
      String? variableName,
      String? valueName,
      bool streamable = true,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_list_String(idVars);
        var arg2 = cst_encode_list_String(valueVars);
        var arg3 = cst_encode_opt_String(variableName);
        var arg4 = cst_encode_opt_String(valueName);
        var arg5 = cst_encode_bool(streamable);
        return wire.wire_LazyFrame_melt(arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameMeltConstMeta,
      argValues: [that, idVars, valueVars, variableName, valueName, streamable],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameMeltConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_melt",
        argNames: [
          "that",
          "idVars",
          "valueVars",
          "variableName",
          "valueName",
          "streamable"
        ],
      );

  @override
  Future<LazyFrame> lazyFrameMin({required LazyFrame that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_min(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameMinConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameMinConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_min",
        argNames: ["that"],
      );

  @override
  LazyFrame lazyFrameOuterJoin(
      {required LazyFrame that,
      required LazyFrame other,
      required Expr leftOn,
      required Expr rightOn,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                other);
        var arg2 = cst_encode_box_autoadd_expr(leftOn);
        var arg3 = cst_encode_box_autoadd_expr(rightOn);
        return wire.wire_LazyFrame_outer_join(arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameOuterJoinConstMeta,
      argValues: [that, other, leftOn, rightOn],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameOuterJoinConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_outer_join",
        argNames: ["that", "other", "leftOn", "rightOn"],
      );

  @override
  LazyFrame lazyFrameQuantile(
      {required LazyFrame that,
      required Expr quantile,
      required QuantileInterpolOptions interpol,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_box_autoadd_expr(quantile);
        var arg2 = cst_encode_quantile_interpol_options(interpol);
        return wire.wire_LazyFrame_quantile(arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameQuantileConstMeta,
      argValues: [that, quantile, interpol],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameQuantileConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_quantile",
        argNames: ["that", "quantile", "interpol"],
      );

  @override
  LazyFrame lazyFrameReverse({required LazyFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_reverse(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameReverseConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameReverseConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_reverse",
        argNames: ["that"],
      );

  @override
  LazyFrame lazyFrameSlice(
      {required LazyFrame that,
      required int offset,
      required int len,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_i_64(offset);
        var arg2 = cst_encode_u_32(len);
        return wire.wire_LazyFrame_slice(arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameSliceConstMeta,
      argValues: [that, offset, len],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameSliceConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_slice",
        argNames: ["that", "offset", "len"],
      );

  @override
  LazyFrame lazyFrameStd(
      {required LazyFrame that, required int ddof, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_u_8(ddof);
        return wire.wire_LazyFrame_std(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameStdConstMeta,
      argValues: [that, ddof],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameStdConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_std",
        argNames: ["that", "ddof"],
      );

  @override
  LazyFrame lazyFrameSum({required LazyFrame that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        return wire.wire_LazyFrame_sum(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameSumConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameSumConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_sum",
        argNames: ["that"],
      );

  @override
  LazyFrame lazyFrameTail(
      {required LazyFrame that, required int n, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_u_32(n);
        return wire.wire_LazyFrame_tail(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: null,
      ),
      constMeta: kLazyFrameTailConstMeta,
      argValues: [that, n],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameTailConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_tail",
        argNames: ["that", "n"],
      );

  @override
  LazyFrame lazyFrameUnique(
      {required LazyFrame that,
      List<String>? subset,
      required UniqueKeepStrategy keepStrategy,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_opt_list_String(subset);
        var arg2 = cst_encode_unique_keep_strategy(keepStrategy);
        return wire.wire_LazyFrame_unique(arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameUniqueConstMeta,
      argValues: [that, subset, keepStrategy],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameUniqueConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_unique",
        argNames: ["that", "subset", "keepStrategy"],
      );

  @override
  LazyFrame lazyFrameVariance(
      {required LazyFrame that, required int ddof, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_u_8(ddof);
        return wire.wire_LazyFrame_variance(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameVarianceConstMeta,
      argValues: [that, ddof],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameVarianceConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_variance",
        argNames: ["that", "ddof"],
      );

  @override
  LazyFrame lazyFrameWithColumn(
      {required LazyFrame that, required Expr expr, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_box_autoadd_expr(expr);
        return wire.wire_LazyFrame_with_column(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameWithColumnConstMeta,
      argValues: [that, expr],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameWithColumnConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_with_column",
        argNames: ["that", "expr"],
      );

  @override
  LazyFrame lazyFrameWithRowCount(
      {required LazyFrame that,
      required String name,
      int? offset,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
                that);
        var arg1 = cst_encode_String(name);
        var arg2 = cst_encode_opt_box_autoadd_u_32(offset);
        return wire.wire_LazyFrame_with_row_count(arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyFrameWithRowCountConstMeta,
      argValues: [that, name, offset],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyFrameWithRowCountConstMeta => const TaskConstMeta(
        debugName: "LazyFrame_with_row_count",
        argNames: ["that", "name", "offset"],
      );

  @override
  LazyFrame lazyGroupByHead({required LazyGroupBy that, int? n, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
                that);
        var arg1 = cst_encode_opt_box_autoadd_usize(n);
        return wire.wire_LazyGroupBy_head(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyGroupByHeadConstMeta,
      argValues: [that, n],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyGroupByHeadConstMeta => const TaskConstMeta(
        debugName: "LazyGroupBy_head",
        argNames: ["that", "n"],
      );

  @override
  LazyFrame lazyGroupByTail({required LazyGroupBy that, int? n, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
                that);
        var arg1 = cst_encode_opt_box_autoadd_usize(n);
        return wire.wire_LazyGroupBy_tail(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kLazyGroupByTailConstMeta,
      argValues: [that, n],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLazyGroupByTailConstMeta => const TaskConstMeta(
        debugName: "LazyGroupBy_tail",
        argNames: ["that", "n"],
      );

  @override
  Schema schemaOf({required List<Field> fields, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_list_field(fields);
        return wire.wire_Schema_of(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSchema,
        decodeErrorData: null,
      ),
      constMeta: kSchemaOfConstMeta,
      argValues: [fields],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSchemaOfConstMeta => const TaskConstMeta(
        debugName: "Schema_of",
        argNames: ["fields"],
      );

  @override
  Series seriesAddTo(
      {required Series that, required Series other, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                other);
        return wire.wire_Series_add_to(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesAddToConstMeta,
      argValues: [that, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesAddToConstMeta => const TaskConstMeta(
        debugName: "Series_add_to",
        argNames: ["that", "other"],
      );

  @override
  Future<void> seriesAppend(
      {required Series that, required Series other, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                other);
        return wire.wire_Series_append(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesAppendConstMeta,
      argValues: [that, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesAppendConstMeta => const TaskConstMeta(
        debugName: "Series_append",
        argNames: ["that", "other"],
      );

  @override
  Future<Series> seriesApplyScalar(
      {required Series that,
      required Operator op,
      required double value,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_operator(op);
        var arg2 = cst_encode_f_64(value);
        return wire.wire_Series_apply_scalar(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesApplyScalarConstMeta,
      argValues: [that, op, value],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesApplyScalarConstMeta => const TaskConstMeta(
        debugName: "Series_apply_scalar",
        argNames: ["that", "op", "value"],
      );

  @override
  Future<List<double?>> seriesAsDoubles(
      {required Series that, bool strict = true, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_bool(strict);
        return wire.wire_Series_as_doubles(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_opt_box_autoadd_f_64,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesAsDoublesConstMeta,
      argValues: [that, strict],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesAsDoublesConstMeta => const TaskConstMeta(
        debugName: "Series_as_doubles",
        argNames: ["that", "strict"],
      );

  @override
  Future<List<Duration?>> seriesAsDurations(
      {required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_as_durations(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_opt_box_autoadd_Chrono_Duration,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesAsDurationsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesAsDurationsConstMeta => const TaskConstMeta(
        debugName: "Series_as_durations",
        argNames: ["that"],
      );

  @override
  Future<List<int?>> seriesAsInts(
      {required Series that, bool strict = true, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_bool(strict);
        return wire.wire_Series_as_ints(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_opt_box_autoadd_i_64,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesAsIntsConstMeta,
      argValues: [that, strict],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesAsIntsConstMeta => const TaskConstMeta(
        debugName: "Series_as_ints",
        argNames: ["that", "strict"],
      );

  @override
  Future<List<DateTime?>> seriesAsLocalDatetime(
      {required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_as_local_datetime(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_opt_box_autoadd_Chrono_Local,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesAsLocalDatetimeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesAsLocalDatetimeConstMeta => const TaskConstMeta(
        debugName: "Series_as_local_datetime",
        argNames: ["that"],
      );

  @override
  Future<List<DateTime?>> seriesAsNaiveDatetime(
      {required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_as_naive_datetime(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_opt_box_autoadd_Chrono_Naive,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesAsNaiveDatetimeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesAsNaiveDatetimeConstMeta => const TaskConstMeta(
        debugName: "Series_as_naive_datetime",
        argNames: ["that"],
      );

  @override
  Future<List<String?>> seriesAsStrings({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_as_strings(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_opt_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesAsStringsConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesAsStringsConstMeta => const TaskConstMeta(
        debugName: "Series_as_strings",
        argNames: ["that"],
      );

  @override
  Future<List<DateTime?>> seriesAsUtcDatetime(
      {required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_as_utc_datetime(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_opt_box_autoadd_Chrono_Utc,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesAsUtcDatetimeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesAsUtcDatetimeConstMeta => const TaskConstMeta(
        debugName: "Series_as_utc_datetime",
        argNames: ["that"],
      );

  @override
  Future<Series> seriesCast(
      {required Series that,
      required DataType dtype,
      bool strict = true,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_box_autoadd_data_type(dtype);
        var arg2 = cst_encode_bool(strict);
        return wire.wire_Series_cast(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesCastConstMeta,
      argValues: [that, dtype, strict],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesCastConstMeta => const TaskConstMeta(
        debugName: "Series_cast",
        argNames: ["that", "dtype", "strict"],
      );

  @override
  Series seriesDivide(
      {required Series that, required Series other, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries(
                other);
        return wire.wire_Series_divide(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesDivideConstMeta,
      argValues: [that, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesDivideConstMeta => const TaskConstMeta(
        debugName: "Series_divide",
        argNames: ["that", "other"],
      );

  @override
  Future<String> seriesDump({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_dump(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesDumpConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesDumpConstMeta => const TaskConstMeta(
        debugName: "Series_dump",
        argNames: ["that"],
      );

  @override
  Future<bool> seriesEqual(
      {required Series that,
      required Series other,
      bool ignoreNull = false,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                other);
        var arg2 = cst_encode_bool(ignoreNull);
        return wire.wire_Series_equal(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesEqualConstMeta,
      argValues: [that, other, ignoreNull],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesEqualConstMeta => const TaskConstMeta(
        debugName: "Series_equal",
        argNames: ["that", "other", "ignoreNull"],
      );

  @override
  int seriesEstimatedSize({required Series that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_estimated_size(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesEstimatedSizeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesEstimatedSizeConstMeta => const TaskConstMeta(
        debugName: "Series_estimated_size",
        argNames: ["that"],
      );

  @override
  Future<Series> seriesExplode({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_explode(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesExplodeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesExplodeConstMeta => const TaskConstMeta(
        debugName: "Series_explode",
        argNames: ["that"],
      );

  @override
  Future<Series> seriesExplodeByOffsets(
      {required Series that, required Int64List offsets, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_list_prim_i_64(offsets);
        return wire.wire_Series_explode_by_offsets(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesExplodeByOffsetsConstMeta,
      argValues: [that, offsets],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesExplodeByOffsetsConstMeta => const TaskConstMeta(
        debugName: "Series_explode_by_offsets",
        argNames: ["that", "offsets"],
      );

  @override
  double? seriesGet({required Series that, required int index, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_usize(index);
        return wire.wire_Series_get(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_f_64,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesGetConstMeta,
      argValues: [that, index],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesGetConstMeta => const TaskConstMeta(
        debugName: "Series_get",
        argNames: ["that", "index"],
      );

  @override
  String? seriesGetString(
      {required Series that, required int index, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_usize(index);
        return wire.wire_Series_get_string(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_String,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesGetStringConstMeta,
      argValues: [that, index],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesGetStringConstMeta => const TaskConstMeta(
        debugName: "Series_get_string",
        argNames: ["that", "index"],
      );

  @override
  Series seriesHead({required Series that, int? length, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_opt_box_autoadd_usize(length);
        return wire.wire_Series_head(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesHeadConstMeta,
      argValues: [that, length],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesHeadConstMeta => const TaskConstMeta(
        debugName: "Series_head",
        argNames: ["that", "length"],
      );

  @override
  DataFrame seriesIntoFrame({required Series that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_into_frame(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: null,
      ),
      constMeta: kSeriesIntoFrameConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesIntoFrameConstMeta => const TaskConstMeta(
        debugName: "Series_into_frame",
        argNames: ["that"],
      );

  @override
  bool seriesIsBool({required Series that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_is_bool(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesIsBoolConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesIsBoolConstMeta => const TaskConstMeta(
        debugName: "Series_is_bool",
        argNames: ["that"],
      );

  @override
  bool seriesIsNumeric({required Series that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_is_numeric(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesIsNumericConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesIsNumericConstMeta => const TaskConstMeta(
        debugName: "Series_is_numeric",
        argNames: ["that"],
      );

  @override
  bool seriesIsTemporal({required Series that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_is_temporal(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesIsTemporalConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesIsTemporalConstMeta => const TaskConstMeta(
        debugName: "Series_is_temporal",
        argNames: ["that"],
      );

  @override
  bool seriesIsUtf8({required Series that, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_is_utf8(arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesIsUtf8ConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesIsUtf8ConstMeta => const TaskConstMeta(
        debugName: "Series_is_utf8",
        argNames: ["that"],
      );

  @override
  Future<double?> seriesMax({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_max(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_f_64,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesMaxConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesMaxConstMeta => const TaskConstMeta(
        debugName: "Series_max",
        argNames: ["that"],
      );

  @override
  Future<double?> seriesMean({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_mean(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_f_64,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesMeanConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesMeanConstMeta => const TaskConstMeta(
        debugName: "Series_mean",
        argNames: ["that"],
      );

  @override
  Future<Series> seriesMeanAsSeries({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_mean_as_series(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesMeanAsSeriesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesMeanAsSeriesConstMeta => const TaskConstMeta(
        debugName: "Series_mean_as_series",
        argNames: ["that"],
      );

  @override
  Future<double?> seriesMedian({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_median(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_f_64,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesMedianConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesMedianConstMeta => const TaskConstMeta(
        debugName: "Series_median",
        argNames: ["that"],
      );

  @override
  Future<Series> seriesMedianAsSeries({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_median_as_series(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesMedianAsSeriesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesMedianAsSeriesConstMeta => const TaskConstMeta(
        debugName: "Series_median_as_series",
        argNames: ["that"],
      );

  @override
  Future<double?> seriesMin({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_min(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_f_64,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesMinConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesMinConstMeta => const TaskConstMeta(
        debugName: "Series_min",
        argNames: ["that"],
      );

  @override
  Series seriesMultiply(
      {required Series that, required Series other, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries(
                other);
        return wire.wire_Series_multiply(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesMultiplyConstMeta,
      argValues: [that, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesMultiplyConstMeta => const TaskConstMeta(
        debugName: "Series_multiply",
        argNames: ["that", "other"],
      );

  @override
  Series seriesOfBools(
      {required String name, List<bool>? values, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(name);
        var arg1 = cst_encode_opt_list_bool(values);
        return wire.wire_Series_of_bools(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: null,
      ),
      constMeta: kSeriesOfBoolsConstMeta,
      argValues: [name, values],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesOfBoolsConstMeta => const TaskConstMeta(
        debugName: "Series_of_bools",
        argNames: ["name", "values"],
      );

  @override
  Series seriesOfDoubles(
      {required String name, List<double?>? values, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(name);
        var arg1 = cst_encode_opt_list_opt_box_autoadd_f_64(values);
        return wire.wire_Series_of_doubles(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: null,
      ),
      constMeta: kSeriesOfDoublesConstMeta,
      argValues: [name, values],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesOfDoublesConstMeta => const TaskConstMeta(
        debugName: "Series_of_doubles",
        argNames: ["name", "values"],
      );

  @override
  Series seriesOfDurations(
      {required String name,
      List<Duration?>? values,
      TimeUnit unit = TimeUnit.milliseconds,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(name);
        var arg1 = cst_encode_opt_list_opt_box_autoadd_Chrono_Duration(values);
        var arg2 = cst_encode_time_unit(unit);
        return wire.wire_Series_of_durations(arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: null,
      ),
      constMeta: kSeriesOfDurationsConstMeta,
      argValues: [name, values, unit],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesOfDurationsConstMeta => const TaskConstMeta(
        debugName: "Series_of_durations",
        argNames: ["name", "values", "unit"],
      );

  @override
  Series seriesOfI32({required String name, List<int?>? values, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(name);
        var arg1 = cst_encode_opt_list_opt_box_autoadd_i_32(values);
        return wire.wire_Series_of_i32(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: null,
      ),
      constMeta: kSeriesOfI32ConstMeta,
      argValues: [name, values],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesOfI32ConstMeta => const TaskConstMeta(
        debugName: "Series_of_i32",
        argNames: ["name", "values"],
      );

  @override
  Series seriesOfInts(
      {required String name, List<int?>? values, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(name);
        var arg1 = cst_encode_opt_list_opt_box_autoadd_i_64(values);
        return wire.wire_Series_of_ints(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: null,
      ),
      constMeta: kSeriesOfIntsConstMeta,
      argValues: [name, values],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesOfIntsConstMeta => const TaskConstMeta(
        debugName: "Series_of_ints",
        argNames: ["name", "values"],
      );

  @override
  Series seriesOfStrings(
      {required String name, List<String?>? values, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(name);
        var arg1 = cst_encode_opt_list_opt_String(values);
        return wire.wire_Series_of_strings(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: null,
      ),
      constMeta: kSeriesOfStringsConstMeta,
      argValues: [name, values],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesOfStringsConstMeta => const TaskConstMeta(
        debugName: "Series_of_strings",
        argNames: ["name", "values"],
      );

  @override
  Future<Series> seriesProduct({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_product(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesProductConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesProductConstMeta => const TaskConstMeta(
        debugName: "Series_product",
        argNames: ["that"],
      );

  @override
  Series seriesRemainder(
      {required Series that, required Series other, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries(
                other);
        return wire.wire_Series_remainder(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesRemainderConstMeta,
      argValues: [that, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesRemainderConstMeta => const TaskConstMeta(
        debugName: "Series_remainder",
        argNames: ["that", "other"],
      );

  @override
  void seriesRename(
      {required Series that, required String name, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_String(name);
        return wire.wire_Series_rename(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesRenameConstMeta,
      argValues: [that, name],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesRenameConstMeta => const TaskConstMeta(
        debugName: "Series_rename",
        argNames: ["that", "name"],
      );

  @override
  Future<Series> seriesReshape(
      {required Series that, required Int64List dims, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_list_prim_i_64(dims);
        return wire.wire_Series_reshape(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesReshapeConstMeta,
      argValues: [that, dims],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesReshapeConstMeta => const TaskConstMeta(
        debugName: "Series_reshape",
        argNames: ["that", "dims"],
      );

  @override
  Future<Series> seriesShuffle(
      {required Series that, int? seed, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_opt_box_autoadd_u_64(seed);
        return wire.wire_Series_shuffle(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesShuffleConstMeta,
      argValues: [that, seed],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesShuffleConstMeta => const TaskConstMeta(
        debugName: "Series_shuffle",
        argNames: ["that", "seed"],
      );

  @override
  Future<Series> seriesSort(
      {required Series that, bool reverse = false, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_bool(reverse);
        return wire.wire_Series_sort(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesSortConstMeta,
      argValues: [that, reverse],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesSortConstMeta => const TaskConstMeta(
        debugName: "Series_sort",
        argNames: ["that", "reverse"],
      );

  @override
  Future<Series> seriesStdAsSeries(
      {required Series that, required int ddof, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_u_8(ddof);
        return wire.wire_Series_std_as_series(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: null,
      ),
      constMeta: kSeriesStdAsSeriesConstMeta,
      argValues: [that, ddof],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesStdAsSeriesConstMeta => const TaskConstMeta(
        debugName: "Series_std_as_series",
        argNames: ["that", "ddof"],
      );

  @override
  Series seriesSubtract(
      {required Series that, required Series other, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                other);
        return wire.wire_Series_subtract(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesSubtractConstMeta,
      argValues: [that, other],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesSubtractConstMeta => const TaskConstMeta(
        debugName: "Series_subtract",
        argNames: ["that", "other"],
      );

  @override
  Future<double?> seriesSum({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_sum(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_opt_box_autoadd_f_64,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesSumConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesSumConstMeta => const TaskConstMeta(
        debugName: "Series_sum",
        argNames: ["that"],
      );

  @override
  Future<Series> seriesSumAsSeries({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_sum_as_series(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesSumAsSeriesConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesSumAsSeriesConstMeta => const TaskConstMeta(
        debugName: "Series_sum_as_series",
        argNames: ["that"],
      );

  @override
  Series seriesTail({required Series that, int? length, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_opt_box_autoadd_usize(length);
        return wire.wire_Series_tail(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesTailConstMeta,
      argValues: [that, length],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesTailConstMeta => const TaskConstMeta(
        debugName: "Series_tail",
        argNames: ["that", "length"],
      );

  @override
  Future<dynamic> seriesToList({required Series that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        return wire.wire_Series_to_list(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_dartabi,
        decodeErrorData: null,
      ),
      constMeta: kSeriesToListConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesToListConstMeta => const TaskConstMeta(
        debugName: "Series_to_list",
        argNames: ["that"],
      );

  @override
  Future<Series> seriesUnique(
      {required Series that, bool stable = false, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_bool(stable);
        return wire.wire_Series_unique(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kSeriesUniqueConstMeta,
      argValues: [that, stable],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesUniqueConstMeta => const TaskConstMeta(
        debugName: "Series_unique",
        argNames: ["that", "stable"],
      );

  @override
  Future<Series> seriesVarAsSeries(
      {required Series that, required int ddof, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 =
            cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
                that);
        var arg1 = cst_encode_u_8(ddof);
        return wire.wire_Series_var_as_series(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries,
        decodeErrorData: null,
      ),
      constMeta: kSeriesVarAsSeriesConstMeta,
      argValues: [that, ddof],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kSeriesVarAsSeriesConstMeta => const TaskConstMeta(
        debugName: "Series_var_as_series",
        argNames: ["that", "ddof"],
      );

  @override
  Future<DataFrame> readCsv(
      {required String path,
      List<DataType>? dtypesSlice,
      bool? hasHeader,
      List<String>? columns,
      String? commentChar,
      String? eolChar,
      int? chunkSize,
      int? sampleSize,
      RowCount? rowCount,
      CsvEncoding? encoding,
      int? nRows,
      int? nThreads,
      NullValues? nullValues,
      Uint32List? projection,
      String? quoteChar = '"',
      int skipRows = 0,
      int skipRowsAfterHeader = 0,
      bool ignoreErrors = false,
      bool rechunk = false,
      bool tryParseDates = true,
      bool lowMemory = false,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(path);
        var arg1 = cst_encode_opt_list_data_type(dtypesSlice);
        var arg2 = cst_encode_opt_box_autoadd_bool(hasHeader);
        var arg3 = cst_encode_opt_list_String(columns);
        var arg4 = cst_encode_opt_String(commentChar);
        var arg5 = cst_encode_opt_String(eolChar);
        var arg6 = cst_encode_opt_box_autoadd_usize(chunkSize);
        var arg7 = cst_encode_opt_box_autoadd_usize(sampleSize);
        var arg8 = cst_encode_opt_box_autoadd_row_count(rowCount);
        var arg9 = cst_encode_opt_box_autoadd_csv_encoding(encoding);
        var arg10 = cst_encode_opt_box_autoadd_usize(nRows);
        var arg11 = cst_encode_opt_box_autoadd_usize(nThreads);
        var arg12 = cst_encode_opt_box_autoadd_null_values(nullValues);
        var arg13 = cst_encode_opt_list_prim_u_32(projection);
        var arg14 = cst_encode_opt_String(quoteChar);
        var arg15 = cst_encode_usize(skipRows);
        var arg16 = cst_encode_usize(skipRowsAfterHeader);
        var arg17 = cst_encode_bool(ignoreErrors);
        var arg18 = cst_encode_bool(rechunk);
        var arg19 = cst_encode_bool(tryParseDates);
        var arg20 = cst_encode_bool(lowMemory);
        return wire.wire_read_csv(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
            arg8,
            arg9,
            arg10,
            arg11,
            arg12,
            arg13,
            arg14,
            arg15,
            arg16,
            arg17,
            arg18,
            arg19,
            arg20);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kReadCsvConstMeta,
      argValues: [
        path,
        dtypesSlice,
        hasHeader,
        columns,
        commentChar,
        eolChar,
        chunkSize,
        sampleSize,
        rowCount,
        encoding,
        nRows,
        nThreads,
        nullValues,
        projection,
        quoteChar,
        skipRows,
        skipRowsAfterHeader,
        ignoreErrors,
        rechunk,
        tryParseDates,
        lowMemory
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kReadCsvConstMeta => const TaskConstMeta(
        debugName: "read_csv",
        argNames: [
          "path",
          "dtypesSlice",
          "hasHeader",
          "columns",
          "commentChar",
          "eolChar",
          "chunkSize",
          "sampleSize",
          "rowCount",
          "encoding",
          "nRows",
          "nThreads",
          "nullValues",
          "projection",
          "quoteChar",
          "skipRows",
          "skipRowsAfterHeader",
          "ignoreErrors",
          "rechunk",
          "tryParseDates",
          "lowMemory"
        ],
      );

  @override
  Future<DataFrame> readJson(
      {required String path,
      int? batchSize,
      List<String>? projection,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(path);
        var arg1 = cst_encode_opt_box_autoadd_usize(batchSize);
        var arg2 = cst_encode_opt_list_String(projection);
        return wire.wire_read_json(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kReadJsonConstMeta,
      argValues: [path, batchSize, projection],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kReadJsonConstMeta => const TaskConstMeta(
        debugName: "read_json",
        argNames: ["path", "batchSize", "projection"],
      );

  @override
  Future<LazyFrame> scanCsv(
      {required String path,
      required Schema dtypeOverwrite,
      bool? hasHeader,
      String? commentChar,
      String? eolChar,
      String? quoteChar = '"',
      int skipRows = 0,
      int skipRowsAfterHeader = 0,
      RowCount? rowCount,
      CsvEncoding? encoding,
      int? nRows,
      NullValues? nullValues,
      bool ignoreErrors = false,
      bool rechunk = false,
      bool tryParseDates = true,
      int? inferSchemaLength = 100,
      bool cache = false,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(path);
        var arg1 =
            cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockOptioncratewrapperSchema(
                dtypeOverwrite);
        var arg2 = cst_encode_opt_box_autoadd_bool(hasHeader);
        var arg3 = cst_encode_opt_String(commentChar);
        var arg4 = cst_encode_opt_String(eolChar);
        var arg5 = cst_encode_opt_String(quoteChar);
        var arg6 = cst_encode_usize(skipRows);
        var arg7 = cst_encode_usize(skipRowsAfterHeader);
        var arg8 = cst_encode_opt_box_autoadd_row_count(rowCount);
        var arg9 = cst_encode_opt_box_autoadd_csv_encoding(encoding);
        var arg10 = cst_encode_opt_box_autoadd_usize(nRows);
        var arg11 = cst_encode_opt_box_autoadd_null_values(nullValues);
        var arg12 = cst_encode_bool(ignoreErrors);
        var arg13 = cst_encode_bool(rechunk);
        var arg14 = cst_encode_bool(tryParseDates);
        var arg15 = cst_encode_opt_box_autoadd_usize(inferSchemaLength);
        var arg16 = cst_encode_bool(cache);
        return wire.wire_scan_csv(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
            arg8,
            arg9,
            arg10,
            arg11,
            arg12,
            arg13,
            arg14,
            arg15,
            arg16);
      },
      codec: DcoCodec(
        decodeSuccessData:
            dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame,
        decodeErrorData: dco_decode_AnyhowException,
      ),
      constMeta: kScanCsvConstMeta,
      argValues: [
        path,
        dtypeOverwrite,
        hasHeader,
        commentChar,
        eolChar,
        quoteChar,
        skipRows,
        skipRowsAfterHeader,
        rowCount,
        encoding,
        nRows,
        nullValues,
        ignoreErrors,
        rechunk,
        tryParseDates,
        inferSchemaLength,
        cache
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kScanCsvConstMeta => const TaskConstMeta(
        debugName: "scan_csv",
        argNames: [
          "path",
          "dtypeOverwrite",
          "hasHeader",
          "commentChar",
          "eolChar",
          "quoteChar",
          "skipRows",
          "skipRowsAfterHeader",
          "rowCount",
          "encoding",
          "nRows",
          "nullValues",
          "ignoreErrors",
          "rechunk",
          "tryParseDates",
          "inferSchemaLength",
          "cache"
        ],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Series => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Series => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Schema => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncRwLockOptioncratewrapperSchema;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Schema => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncRwLockOptioncratewrapperSchema;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Series => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncRwLockVeccratewrapperSeries;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Series => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncRwLockVeccratewrapperSeries;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DataFrame => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncRwLockcratewrapperDataFrame;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DataFrame => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncRwLockcratewrapperDataFrame;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LazyFrame => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncRwLockcratewrapperLazyFrame;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LazyFrame => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncRwLockcratewrapperLazyFrame;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_LazyGroupBy => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_LazyGroupBy => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Schema => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncRwLockcratewrapperSchema;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Schema => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncRwLockcratewrapperSchema;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Series => wire
          .rust_arc_increment_strong_count_RustOpaque_stdsyncRwLockcratewrapperSeries;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Series => wire
          .rust_arc_decrement_strong_count_RustOpaque_stdsyncRwLockcratewrapperSeries;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    return AnyhowException(raw as String);
  }

  @protected
  Series
      dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries(
          dynamic raw) {
    return Series.dcoDecode(raw);
  }

  @protected
  Schema dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockOptioncratewrapperSchema(
      dynamic raw) {
    return Schema.dcoDecode(raw);
  }

  @protected
  Series dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockVeccratewrapperSeries(
      dynamic raw) {
    return Series.dcoDecode(raw);
  }

  @protected
  DataFrame dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      dynamic raw) {
    return DataFrame.dcoDecode(raw);
  }

  @protected
  LazyFrame dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
      dynamic raw) {
    return LazyFrame.dcoDecode(raw);
  }

  @protected
  LazyGroupBy
      dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
          dynamic raw) {
    return LazyGroupBy.dcoDecode(raw);
  }

  @protected
  Schema dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSchema(
      dynamic raw) {
    return Schema.dcoDecode(raw);
  }

  @protected
  Series dco_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries(
      dynamic raw) {
    return Series.dcoDecode(raw);
  }

  @protected
  DataFrame
      dco_decode_Auto_RefMut_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
          dynamic raw) {
    return DataFrame.dcoDecode(raw);
  }

  @protected
  DataFrame dco_decode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      dynamic raw) {
    return DataFrame.dcoDecode(raw);
  }

  @protected
  Series dco_decode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
      dynamic raw) {
    return Series.dcoDecode(raw);
  }

  @protected
  Duration dco_decode_Chrono_Duration(dynamic raw) {
    return dcoDecodeDuration(dco_decode_i_64(raw).toInt());
  }

  @protected
  DateTime dco_decode_Chrono_Local(dynamic raw) {
    return dcoDecodeTimestamp(ts: dco_decode_i_64(raw).toInt(), isUtc: false);
  }

  @protected
  DateTime dco_decode_Chrono_Naive(dynamic raw) {
    return dcoDecodeTimestamp(ts: dco_decode_i_64(raw).toInt(), isUtc: true);
  }

  @protected
  DateTime dco_decode_Chrono_Utc(dynamic raw) {
    return dcoDecodeTimestamp(ts: dco_decode_i_64(raw).toInt(), isUtc: true);
  }

  @protected
  Series dco_decode_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries(
      dynamic raw) {
    return Series.dcoDecode(raw);
  }

  @protected
  Schema dco_decode_RustOpaque_stdsyncRwLockOptioncratewrapperSchema(
      dynamic raw) {
    return Schema.dcoDecode(raw);
  }

  @protected
  Series dco_decode_RustOpaque_stdsyncRwLockVeccratewrapperSeries(dynamic raw) {
    return Series.dcoDecode(raw);
  }

  @protected
  DataFrame dco_decode_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      dynamic raw) {
    return DataFrame.dcoDecode(raw);
  }

  @protected
  LazyFrame dco_decode_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
      dynamic raw) {
    return LazyFrame.dcoDecode(raw);
  }

  @protected
  LazyGroupBy dco_decode_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
      dynamic raw) {
    return LazyGroupBy.dcoDecode(raw);
  }

  @protected
  Schema dco_decode_RustOpaque_stdsyncRwLockcratewrapperSchema(dynamic raw) {
    return Schema.dcoDecode(raw);
  }

  @protected
  Series dco_decode_RustOpaque_stdsyncRwLockcratewrapperSeries(dynamic raw) {
    return Series.dcoDecode(raw);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    return raw as String;
  }

  @protected
  AggExpr dco_decode_agg_expr(dynamic raw) {
    switch (raw[0]) {
      case 0:
        return AggExpr_Min(
          input: dco_decode_box_expr(raw[1]),
          propagateNans: dco_decode_bool(raw[2]),
        );
      case 1:
        return AggExpr_Max(
          input: dco_decode_box_expr(raw[1]),
          propagateNans: dco_decode_bool(raw[2]),
        );
      case 2:
        return AggExpr_Median(
          dco_decode_box_expr(raw[1]),
        );
      case 3:
        return AggExpr_NUnique(
          dco_decode_box_expr(raw[1]),
        );
      case 4:
        return AggExpr_First(
          dco_decode_box_expr(raw[1]),
        );
      case 5:
        return AggExpr_Last(
          dco_decode_box_expr(raw[1]),
        );
      case 6:
        return AggExpr_Mean(
          dco_decode_box_expr(raw[1]),
        );
      case 7:
        return AggExpr_Count(
          dco_decode_box_expr(raw[1]),
        );
      case 8:
        return AggExpr_Quantile(
          expr: dco_decode_box_expr(raw[1]),
          quantile: dco_decode_box_expr(raw[2]),
          interpol: dco_decode_quantile_interpol_options(raw[3]),
        );
      case 9:
        return AggExpr_Sum(
          dco_decode_box_expr(raw[1]),
        );
      case 10:
        return AggExpr_AggGroups(
          dco_decode_box_expr(raw[1]),
        );
      case 11:
        return AggExpr_Std(
          dco_decode_box_expr(raw[1]),
          dco_decode_u_8(raw[2]),
        );
      case 12:
        return AggExpr_Var(
          dco_decode_box_expr(raw[1]),
          dco_decode_u_8(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    return raw as bool;
  }

  @protected
  Duration dco_decode_box_autoadd_Chrono_Duration(dynamic raw) {
    return dco_decode_Chrono_Duration(raw);
  }

  @protected
  DateTime dco_decode_box_autoadd_Chrono_Local(dynamic raw) {
    return dco_decode_Chrono_Local(raw);
  }

  @protected
  DateTime dco_decode_box_autoadd_Chrono_Naive(dynamic raw) {
    return dco_decode_Chrono_Naive(raw);
  }

  @protected
  DateTime dco_decode_box_autoadd_Chrono_Utc(dynamic raw) {
    return dco_decode_Chrono_Utc(raw);
  }

  @protected
  AggExpr dco_decode_box_autoadd_agg_expr(dynamic raw) {
    return dco_decode_agg_expr(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    return raw as bool;
  }

  @protected
  CsvEncoding dco_decode_box_autoadd_csv_encoding(dynamic raw) {
    return dco_decode_csv_encoding(raw);
  }

  @protected
  DataType dco_decode_box_autoadd_data_type(dynamic raw) {
    return dco_decode_data_type(raw);
  }

  @protected
  Expr dco_decode_box_autoadd_expr(dynamic raw) {
    return dco_decode_expr(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_64(dynamic raw) {
    return raw as double;
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_i_64(dynamic raw) {
    return dco_decode_i_64(raw);
  }

  @protected
  LiteralValue dco_decode_box_autoadd_literal_value(dynamic raw) {
    return dco_decode_literal_value(raw);
  }

  @protected
  NullValues dco_decode_box_autoadd_null_values(dynamic raw) {
    return dco_decode_null_values(raw);
  }

  @protected
  RowCount dco_decode_box_autoadd_row_count(dynamic raw) {
    return dco_decode_row_count(raw);
  }

  @protected
  SortOptions dco_decode_box_autoadd_sort_options(dynamic raw) {
    return dco_decode_sort_options(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    return raw as int;
  }

  @protected
  int dco_decode_box_autoadd_u_64(dynamic raw) {
    return dco_decode_u_64(raw);
  }

  @protected
  int dco_decode_box_autoadd_usize(dynamic raw) {
    return dco_decode_usize(raw);
  }

  @protected
  WindowType dco_decode_box_autoadd_window_type(dynamic raw) {
    return dco_decode_window_type(raw);
  }

  @protected
  DataType dco_decode_box_data_type(dynamic raw) {
    return dco_decode_data_type(raw);
  }

  @protected
  Expr dco_decode_box_expr(dynamic raw) {
    return dco_decode_expr(raw);
  }

  @protected
  CsvEncoding dco_decode_csv_encoding(dynamic raw) {
    return CsvEncoding.values[raw as int];
  }

  @protected
  dynamic dco_decode_dartabi(dynamic raw) {
    return raw;
  }

  @protected
  DataType dco_decode_data_type(dynamic raw) {
    switch (raw[0]) {
      case 0:
        return DataType_Boolean();
      case 1:
        return DataType_UInt8();
      case 2:
        return DataType_UInt16();
      case 3:
        return DataType_UInt32();
      case 4:
        return DataType_UInt64();
      case 5:
        return DataType_Int8();
      case 6:
        return DataType_Int16();
      case 7:
        return DataType_Int32();
      case 8:
        return DataType_Int64();
      case 9:
        return DataType_Float32();
      case 10:
        return DataType_Float64();
      case 11:
        return DataType_Utf8();
      case 12:
        return DataType_Binary();
      case 13:
        return DataType_Date();
      case 14:
        return DataType_Datetime(
          dco_decode_time_unit(raw[1]),
          dco_decode_opt_String(raw[2]),
        );
      case 15:
        return DataType_Duration(
          dco_decode_time_unit(raw[1]),
        );
      case 16:
        return DataType_Time();
      case 17:
        return DataType_List(
          dco_decode_box_data_type(raw[1]),
        );
      case 18:
        return DataType_Null();
      case 19:
        return DataType_Struct(
          dco_decode_list_field(raw[1]),
        );
      case 20:
        return DataType_Unknown();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Excluded dco_decode_excluded(dynamic raw) {
    switch (raw[0]) {
      case 0:
        return Excluded_Name(
          dco_decode_String(raw[1]),
        );
      case 1:
        return Excluded_Dtype(
          dco_decode_box_autoadd_data_type(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Expr dco_decode_expr(dynamic raw) {
    switch (raw[0]) {
      case 0:
        return Expr_Alias(
          dco_decode_box_expr(raw[1]),
          dco_decode_String(raw[2]),
        );
      case 1:
        return Expr_Column(
          dco_decode_String(raw[1]),
        );
      case 2:
        return Expr_Columns(
          dco_decode_list_String(raw[1]),
        );
      case 3:
        return Expr_DtypeColumn(
          dco_decode_list_data_type(raw[1]),
        );
      case 4:
        return Expr_Literal(
          dco_decode_box_autoadd_literal_value(raw[1]),
        );
      case 5:
        return Expr_BinaryExpr(
          left: dco_decode_box_expr(raw[1]),
          op: dco_decode_operator(raw[2]),
          right: dco_decode_box_expr(raw[3]),
        );
      case 6:
        return Expr_Cast(
          expr: dco_decode_box_expr(raw[1]),
          dataType: dco_decode_box_autoadd_data_type(raw[2]),
          strict: dco_decode_bool(raw[3]),
        );
      case 7:
        return Expr_Sort(
          expr: dco_decode_box_expr(raw[1]),
          options: dco_decode_box_autoadd_sort_options(raw[2]),
        );
      case 8:
        return Expr_Gather(
          expr: dco_decode_box_expr(raw[1]),
          idx: dco_decode_box_expr(raw[2]),
          returnsScalar: dco_decode_bool(raw[3]),
        );
      case 9:
        return Expr_SortBy(
          expr: dco_decode_box_expr(raw[1]),
          by: dco_decode_list_expr(raw[2]),
          descending: dco_decode_list_bool(raw[3]),
        );
      case 10:
        return Expr_Agg(
          dco_decode_box_autoadd_agg_expr(raw[1]),
        );
      case 11:
        return Expr_Ternary(
          predicate: dco_decode_box_expr(raw[1]),
          truthy: dco_decode_box_expr(raw[2]),
          falsy: dco_decode_box_expr(raw[3]),
        );
      case 12:
        return Expr_Explode(
          dco_decode_box_expr(raw[1]),
        );
      case 13:
        return Expr_Filter(
          input: dco_decode_box_expr(raw[1]),
          by: dco_decode_box_expr(raw[2]),
        );
      case 14:
        return Expr_Window(
          function: dco_decode_box_expr(raw[1]),
          partitionBy: dco_decode_list_expr(raw[2]),
          options: dco_decode_box_autoadd_window_type(raw[3]),
        );
      case 15:
        return Expr_Wildcard();
      case 16:
        return Expr_Slice(
          input: dco_decode_box_expr(raw[1]),
          offset: dco_decode_box_expr(raw[2]),
          length: dco_decode_box_expr(raw[3]),
        );
      case 17:
        return Expr_Exclude(
          dco_decode_box_expr(raw[1]),
          dco_decode_list_excluded(raw[2]),
        );
      case 18:
        return Expr_KeepName(
          dco_decode_box_expr(raw[1]),
        );
      case 19:
        return Expr_Count();
      case 20:
        return Expr_Nth(
          dco_decode_i_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    return raw as double;
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    return raw as double;
  }

  @protected
  Field dco_decode_field(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Field(
      name: dco_decode_String(arr[0]),
      dtype: dco_decode_data_type(arr[1]),
    );
  }

  @protected
  int dco_decode_i_16(dynamic raw) {
    return raw as int;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    return raw as int;
  }

  @protected
  int dco_decode_i_64(dynamic raw) {
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  int dco_decode_i_8(dynamic raw) {
    return raw as int;
  }

  @protected
  JoinType dco_decode_join_type(dynamic raw) {
    return JoinType.values[raw as int];
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<bool> dco_decode_list_bool(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_bool).toList();
  }

  @protected
  List<dynamic> dco_decode_list_dartabi(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_dartabi).toList();
  }

  @protected
  List<DataType> dco_decode_list_data_type(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_data_type).toList();
  }

  @protected
  List<Excluded> dco_decode_list_excluded(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_excluded).toList();
  }

  @protected
  List<Expr> dco_decode_list_expr(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_expr).toList();
  }

  @protected
  List<Field> dco_decode_list_field(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_field).toList();
  }

  @protected
  List<String?> dco_decode_list_opt_String(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_opt_String).toList();
  }

  @protected
  List<Duration?> dco_decode_list_opt_box_autoadd_Chrono_Duration(dynamic raw) {
    return (raw as List<dynamic>)
        .map(dco_decode_opt_box_autoadd_Chrono_Duration)
        .toList();
  }

  @protected
  List<DateTime?> dco_decode_list_opt_box_autoadd_Chrono_Local(dynamic raw) {
    return (raw as List<dynamic>)
        .map(dco_decode_opt_box_autoadd_Chrono_Local)
        .toList();
  }

  @protected
  List<DateTime?> dco_decode_list_opt_box_autoadd_Chrono_Naive(dynamic raw) {
    return (raw as List<dynamic>)
        .map(dco_decode_opt_box_autoadd_Chrono_Naive)
        .toList();
  }

  @protected
  List<DateTime?> dco_decode_list_opt_box_autoadd_Chrono_Utc(dynamic raw) {
    return (raw as List<dynamic>)
        .map(dco_decode_opt_box_autoadd_Chrono_Utc)
        .toList();
  }

  @protected
  List<double?> dco_decode_list_opt_box_autoadd_f_64(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_opt_box_autoadd_f_64).toList();
  }

  @protected
  List<int?> dco_decode_list_opt_box_autoadd_i_32(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_opt_box_autoadd_i_32).toList();
  }

  @protected
  List<int?> dco_decode_list_opt_box_autoadd_i_64(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_opt_box_autoadd_i_64).toList();
  }

  @protected
  Float64List dco_decode_list_prim_f_64(dynamic raw) {
    return raw as Float64List;
  }

  @protected
  Int64List dco_decode_list_prim_i_64(dynamic raw) {
    return Int64List.from(raw);
  }

  @protected
  Uint32List dco_decode_list_prim_u_32(dynamic raw) {
    return raw as Uint32List;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8(dynamic raw) {
    return raw as Uint8List;
  }

  @protected
  List<(String, String)> dco_decode_list_record_string_string(dynamic raw) {
    return (raw as List<dynamic>).map(dco_decode_record_string_string).toList();
  }

  @protected
  LiteralValue dco_decode_literal_value(dynamic raw) {
    switch (raw[0]) {
      case 0:
        return LiteralValue_Null();
      case 1:
        return LiteralValue_Boolean(
          dco_decode_bool(raw[1]),
        );
      case 2:
        return LiteralValue_Utf8(
          dco_decode_String(raw[1]),
        );
      case 3:
        return LiteralValue_Binary(
          dco_decode_list_prim_u_8(raw[1]),
        );
      case 4:
        return LiteralValue_UInt8(
          dco_decode_u_8(raw[1]),
        );
      case 5:
        return LiteralValue_UInt16(
          dco_decode_u_16(raw[1]),
        );
      case 6:
        return LiteralValue_UInt32(
          dco_decode_u_32(raw[1]),
        );
      case 7:
        return LiteralValue_UInt64(
          dco_decode_u_64(raw[1]),
        );
      case 8:
        return LiteralValue_Int8(
          dco_decode_i_8(raw[1]),
        );
      case 9:
        return LiteralValue_Int16(
          dco_decode_i_16(raw[1]),
        );
      case 10:
        return LiteralValue_Int32(
          dco_decode_i_32(raw[1]),
        );
      case 11:
        return LiteralValue_Int64(
          dco_decode_i_64(raw[1]),
        );
      case 12:
        return LiteralValue_Float32(
          dco_decode_f_32(raw[1]),
        );
      case 13:
        return LiteralValue_Float64(
          dco_decode_f_64(raw[1]),
        );
      case 14:
        return LiteralValue_Range(
          low: dco_decode_i_64(raw[1]),
          high: dco_decode_i_64(raw[2]),
          dataType: dco_decode_box_autoadd_data_type(raw[3]),
        );
      case 15:
        return LiteralValue_DateTime(
          dco_decode_i_64(raw[1]),
          dco_decode_time_unit(raw[2]),
          dco_decode_opt_String(raw[3]),
        );
      case 16:
        return LiteralValue_Duration(
          dco_decode_i_64(raw[1]),
          dco_decode_time_unit(raw[2]),
        );
      case 17:
        return LiteralValue_Date(
          dco_decode_i_32(raw[1]),
        );
      case 18:
        return LiteralValue_Time(
          dco_decode_i_64(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  NullValues dco_decode_null_values(dynamic raw) {
    switch (raw[0]) {
      case 0:
        return NullValues_AllColumnsSingle(
          dco_decode_String(raw[1]),
        );
      case 1:
        return NullValues_AllColumns(
          dco_decode_list_String(raw[1]),
        );
      case 2:
        return NullValues_Named(
          dco_decode_list_record_string_string(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  Operator dco_decode_operator(dynamic raw) {
    return Operator.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  Duration? dco_decode_opt_box_autoadd_Chrono_Duration(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_Chrono_Duration(raw);
  }

  @protected
  DateTime? dco_decode_opt_box_autoadd_Chrono_Local(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_Chrono_Local(raw);
  }

  @protected
  DateTime? dco_decode_opt_box_autoadd_Chrono_Naive(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_Chrono_Naive(raw);
  }

  @protected
  DateTime? dco_decode_opt_box_autoadd_Chrono_Utc(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_Chrono_Utc(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  CsvEncoding? dco_decode_opt_box_autoadd_csv_encoding(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_csv_encoding(raw);
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_64(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_f_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_64(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_i_64(raw);
  }

  @protected
  NullValues? dco_decode_opt_box_autoadd_null_values(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_null_values(raw);
  }

  @protected
  RowCount? dco_decode_opt_box_autoadd_row_count(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_row_count(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_64(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_u_64(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_usize(dynamic raw) {
    return raw == null ? null : dco_decode_box_autoadd_usize(raw);
  }

  @protected
  List<String>? dco_decode_opt_list_String(dynamic raw) {
    return raw == null ? null : dco_decode_list_String(raw);
  }

  @protected
  List<bool>? dco_decode_opt_list_bool(dynamic raw) {
    return raw == null ? null : dco_decode_list_bool(raw);
  }

  @protected
  List<DataType>? dco_decode_opt_list_data_type(dynamic raw) {
    return raw == null ? null : dco_decode_list_data_type(raw);
  }

  @protected
  List<Expr>? dco_decode_opt_list_expr(dynamic raw) {
    return raw == null ? null : dco_decode_list_expr(raw);
  }

  @protected
  List<String?>? dco_decode_opt_list_opt_String(dynamic raw) {
    return raw == null ? null : dco_decode_list_opt_String(raw);
  }

  @protected
  List<Duration?>? dco_decode_opt_list_opt_box_autoadd_Chrono_Duration(
      dynamic raw) {
    return raw == null
        ? null
        : dco_decode_list_opt_box_autoadd_Chrono_Duration(raw);
  }

  @protected
  List<double?>? dco_decode_opt_list_opt_box_autoadd_f_64(dynamic raw) {
    return raw == null ? null : dco_decode_list_opt_box_autoadd_f_64(raw);
  }

  @protected
  List<int?>? dco_decode_opt_list_opt_box_autoadd_i_32(dynamic raw) {
    return raw == null ? null : dco_decode_list_opt_box_autoadd_i_32(raw);
  }

  @protected
  List<int?>? dco_decode_opt_list_opt_box_autoadd_i_64(dynamic raw) {
    return raw == null ? null : dco_decode_list_opt_box_autoadd_i_64(raw);
  }

  @protected
  Float64List? dco_decode_opt_list_prim_f_64(dynamic raw) {
    return raw == null ? null : dco_decode_list_prim_f_64(raw);
  }

  @protected
  Uint32List? dco_decode_opt_list_prim_u_32(dynamic raw) {
    return raw == null ? null : dco_decode_list_prim_u_32(raw);
  }

  @protected
  QuantileInterpolOptions dco_decode_quantile_interpol_options(dynamic raw) {
    return QuantileInterpolOptions.values[raw as int];
  }

  @protected
  (String, String) dco_decode_record_string_string(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  RowCount dco_decode_row_count(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RowCount(
      name: dco_decode_String(arr[0]),
      offset: dco_decode_u_32(arr[1]),
    );
  }

  @protected
  Shape dco_decode_shape(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Shape(
      height: dco_decode_usize(arr[0]),
      width: dco_decode_usize(arr[1]),
    );
  }

  @protected
  SortOptions dco_decode_sort_options(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SortOptions(
      descending: dco_decode_bool(arr[0]),
      nullsLast: dco_decode_bool(arr[1]),
      multithreaded: dco_decode_bool(arr[2]),
      maintainOrder: dco_decode_bool(arr[3]),
    );
  }

  @protected
  TimeUnit dco_decode_time_unit(dynamic raw) {
    return TimeUnit.values[raw as int];
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    return raw as int;
  }

  @protected
  int dco_decode_u_64(dynamic raw) {
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    return raw as int;
  }

  @protected
  UniqueKeepStrategy dco_decode_unique_keep_strategy(dynamic raw) {
    return UniqueKeepStrategy.values[raw as int];
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    return;
  }

  @protected
  int dco_decode_usize(dynamic raw) {
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  WindowMapping dco_decode_window_mapping(dynamic raw) {
    return WindowMapping.values[raw as int];
  }

  @protected
  WindowType dco_decode_window_type(dynamic raw) {
    switch (raw[0]) {
      case 0:
        return WindowType_Over(
          dco_decode_window_mapping(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Series
      sse_decode_Auto_Owned_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries(
          SseDeserializer deserializer) {
    return Series.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Schema sse_decode_Auto_Owned_RustOpaque_stdsyncRwLockOptioncratewrapperSchema(
      SseDeserializer deserializer) {
    return Schema.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Series sse_decode_Auto_Owned_RustOpaque_stdsyncRwLockVeccratewrapperSeries(
      SseDeserializer deserializer) {
    return Series.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DataFrame sse_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      SseDeserializer deserializer) {
    return DataFrame.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  LazyFrame sse_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
      SseDeserializer deserializer) {
    return LazyFrame.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  LazyGroupBy
      sse_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
          SseDeserializer deserializer) {
    return LazyGroupBy.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Schema sse_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSchema(
      SseDeserializer deserializer) {
    return Schema.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Series sse_decode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries(
      SseDeserializer deserializer) {
    return Series.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DataFrame
      sse_decode_Auto_RefMut_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
          SseDeserializer deserializer) {
    return DataFrame.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DataFrame sse_decode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      SseDeserializer deserializer) {
    return DataFrame.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Series sse_decode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
      SseDeserializer deserializer) {
    return Series.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Duration sse_decode_Chrono_Duration(SseDeserializer deserializer) {
    throw UnimplementedError(
        'not yet supported in serialized mode, feel free to create an issue');
  }

  @protected
  DateTime sse_decode_Chrono_Local(SseDeserializer deserializer) {
    throw UnimplementedError(
        'not yet supported in serialized mode, feel free to create an issue');
  }

  @protected
  DateTime sse_decode_Chrono_Naive(SseDeserializer deserializer) {
    throw UnimplementedError(
        'not yet supported in serialized mode, feel free to create an issue');
  }

  @protected
  DateTime sse_decode_Chrono_Utc(SseDeserializer deserializer) {
    throw UnimplementedError(
        'not yet supported in serialized mode, feel free to create an issue');
  }

  @protected
  Series sse_decode_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries(
      SseDeserializer deserializer) {
    return Series.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Schema sse_decode_RustOpaque_stdsyncRwLockOptioncratewrapperSchema(
      SseDeserializer deserializer) {
    return Schema.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Series sse_decode_RustOpaque_stdsyncRwLockVeccratewrapperSeries(
      SseDeserializer deserializer) {
    return Series.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DataFrame sse_decode_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      SseDeserializer deserializer) {
    return DataFrame.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  LazyFrame sse_decode_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
      SseDeserializer deserializer) {
    return LazyFrame.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  LazyGroupBy sse_decode_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
      SseDeserializer deserializer) {
    return LazyGroupBy.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Schema sse_decode_RustOpaque_stdsyncRwLockcratewrapperSchema(
      SseDeserializer deserializer) {
    return Schema.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Series sse_decode_RustOpaque_stdsyncRwLockcratewrapperSeries(
      SseDeserializer deserializer) {
    return Series.sseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    var inner = sse_decode_list_prim_u_8(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AggExpr sse_decode_agg_expr(SseDeserializer deserializer) {
    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_input = sse_decode_box_expr(deserializer);
        var var_propagateNans = sse_decode_bool(deserializer);
        return AggExpr_Min(input: var_input, propagateNans: var_propagateNans);
      case 1:
        var var_input = sse_decode_box_expr(deserializer);
        var var_propagateNans = sse_decode_bool(deserializer);
        return AggExpr_Max(input: var_input, propagateNans: var_propagateNans);
      case 2:
        var var_field0 = sse_decode_box_expr(deserializer);
        return AggExpr_Median(var_field0);
      case 3:
        var var_field0 = sse_decode_box_expr(deserializer);
        return AggExpr_NUnique(var_field0);
      case 4:
        var var_field0 = sse_decode_box_expr(deserializer);
        return AggExpr_First(var_field0);
      case 5:
        var var_field0 = sse_decode_box_expr(deserializer);
        return AggExpr_Last(var_field0);
      case 6:
        var var_field0 = sse_decode_box_expr(deserializer);
        return AggExpr_Mean(var_field0);
      case 7:
        var var_field0 = sse_decode_box_expr(deserializer);
        return AggExpr_Count(var_field0);
      case 8:
        var var_expr = sse_decode_box_expr(deserializer);
        var var_quantile = sse_decode_box_expr(deserializer);
        var var_interpol = sse_decode_quantile_interpol_options(deserializer);
        return AggExpr_Quantile(
            expr: var_expr, quantile: var_quantile, interpol: var_interpol);
      case 9:
        var var_field0 = sse_decode_box_expr(deserializer);
        return AggExpr_Sum(var_field0);
      case 10:
        var var_field0 = sse_decode_box_expr(deserializer);
        return AggExpr_AggGroups(var_field0);
      case 11:
        var var_field0 = sse_decode_box_expr(deserializer);
        var var_field1 = sse_decode_u_8(deserializer);
        return AggExpr_Std(var_field0, var_field1);
      case 12:
        var var_field0 = sse_decode_box_expr(deserializer);
        var var_field1 = sse_decode_u_8(deserializer);
        return AggExpr_Var(var_field0, var_field1);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  Duration sse_decode_box_autoadd_Chrono_Duration(
      SseDeserializer deserializer) {
    return (sse_decode_Chrono_Duration(deserializer));
  }

  @protected
  DateTime sse_decode_box_autoadd_Chrono_Local(SseDeserializer deserializer) {
    return (sse_decode_Chrono_Local(deserializer));
  }

  @protected
  DateTime sse_decode_box_autoadd_Chrono_Naive(SseDeserializer deserializer) {
    return (sse_decode_Chrono_Naive(deserializer));
  }

  @protected
  DateTime sse_decode_box_autoadd_Chrono_Utc(SseDeserializer deserializer) {
    return (sse_decode_Chrono_Utc(deserializer));
  }

  @protected
  AggExpr sse_decode_box_autoadd_agg_expr(SseDeserializer deserializer) {
    return (sse_decode_agg_expr(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    return (sse_decode_bool(deserializer));
  }

  @protected
  CsvEncoding sse_decode_box_autoadd_csv_encoding(
      SseDeserializer deserializer) {
    return (sse_decode_csv_encoding(deserializer));
  }

  @protected
  DataType sse_decode_box_autoadd_data_type(SseDeserializer deserializer) {
    return (sse_decode_data_type(deserializer));
  }

  @protected
  Expr sse_decode_box_autoadd_expr(SseDeserializer deserializer) {
    return (sse_decode_expr(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_64(SseDeserializer deserializer) {
    return (sse_decode_f_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    return (sse_decode_i_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_64(SseDeserializer deserializer) {
    return (sse_decode_i_64(deserializer));
  }

  @protected
  LiteralValue sse_decode_box_autoadd_literal_value(
      SseDeserializer deserializer) {
    return (sse_decode_literal_value(deserializer));
  }

  @protected
  NullValues sse_decode_box_autoadd_null_values(SseDeserializer deserializer) {
    return (sse_decode_null_values(deserializer));
  }

  @protected
  RowCount sse_decode_box_autoadd_row_count(SseDeserializer deserializer) {
    return (sse_decode_row_count(deserializer));
  }

  @protected
  SortOptions sse_decode_box_autoadd_sort_options(
      SseDeserializer deserializer) {
    return (sse_decode_sort_options(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    return (sse_decode_u_32(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_64(SseDeserializer deserializer) {
    return (sse_decode_u_64(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_usize(SseDeserializer deserializer) {
    return (sse_decode_usize(deserializer));
  }

  @protected
  WindowType sse_decode_box_autoadd_window_type(SseDeserializer deserializer) {
    return (sse_decode_window_type(deserializer));
  }

  @protected
  DataType sse_decode_box_data_type(SseDeserializer deserializer) {
    return (sse_decode_data_type(deserializer));
  }

  @protected
  Expr sse_decode_box_expr(SseDeserializer deserializer) {
    return (sse_decode_expr(deserializer));
  }

  @protected
  CsvEncoding sse_decode_csv_encoding(SseDeserializer deserializer) {
    var inner = sse_decode_i_32(deserializer);
    return CsvEncoding.values[inner];
  }

  @protected
  dynamic sse_decode_dartabi(SseDeserializer deserializer) {
    throw UnimplementedError('');
  }

  @protected
  DataType sse_decode_data_type(SseDeserializer deserializer) {
    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return DataType_Boolean();
      case 1:
        return DataType_UInt8();
      case 2:
        return DataType_UInt16();
      case 3:
        return DataType_UInt32();
      case 4:
        return DataType_UInt64();
      case 5:
        return DataType_Int8();
      case 6:
        return DataType_Int16();
      case 7:
        return DataType_Int32();
      case 8:
        return DataType_Int64();
      case 9:
        return DataType_Float32();
      case 10:
        return DataType_Float64();
      case 11:
        return DataType_Utf8();
      case 12:
        return DataType_Binary();
      case 13:
        return DataType_Date();
      case 14:
        var var_field0 = sse_decode_time_unit(deserializer);
        var var_field1 = sse_decode_opt_String(deserializer);
        return DataType_Datetime(var_field0, var_field1);
      case 15:
        var var_field0 = sse_decode_time_unit(deserializer);
        return DataType_Duration(var_field0);
      case 16:
        return DataType_Time();
      case 17:
        var var_field0 = sse_decode_box_data_type(deserializer);
        return DataType_List(var_field0);
      case 18:
        return DataType_Null();
      case 19:
        var var_field0 = sse_decode_list_field(deserializer);
        return DataType_Struct(var_field0);
      case 20:
        return DataType_Unknown();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Excluded sse_decode_excluded(SseDeserializer deserializer) {
    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return Excluded_Name(var_field0);
      case 1:
        var var_field0 = sse_decode_box_autoadd_data_type(deserializer);
        return Excluded_Dtype(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Expr sse_decode_expr(SseDeserializer deserializer) {
    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_box_expr(deserializer);
        var var_field1 = sse_decode_String(deserializer);
        return Expr_Alias(var_field0, var_field1);
      case 1:
        var var_field0 = sse_decode_String(deserializer);
        return Expr_Column(var_field0);
      case 2:
        var var_field0 = sse_decode_list_String(deserializer);
        return Expr_Columns(var_field0);
      case 3:
        var var_field0 = sse_decode_list_data_type(deserializer);
        return Expr_DtypeColumn(var_field0);
      case 4:
        var var_field0 = sse_decode_box_autoadd_literal_value(deserializer);
        return Expr_Literal(var_field0);
      case 5:
        var var_left = sse_decode_box_expr(deserializer);
        var var_op = sse_decode_operator(deserializer);
        var var_right = sse_decode_box_expr(deserializer);
        return Expr_BinaryExpr(left: var_left, op: var_op, right: var_right);
      case 6:
        var var_expr = sse_decode_box_expr(deserializer);
        var var_dataType = sse_decode_box_autoadd_data_type(deserializer);
        var var_strict = sse_decode_bool(deserializer);
        return Expr_Cast(
            expr: var_expr, dataType: var_dataType, strict: var_strict);
      case 7:
        var var_expr = sse_decode_box_expr(deserializer);
        var var_options = sse_decode_box_autoadd_sort_options(deserializer);
        return Expr_Sort(expr: var_expr, options: var_options);
      case 8:
        var var_expr = sse_decode_box_expr(deserializer);
        var var_idx = sse_decode_box_expr(deserializer);
        var var_returnsScalar = sse_decode_bool(deserializer);
        return Expr_Gather(
            expr: var_expr, idx: var_idx, returnsScalar: var_returnsScalar);
      case 9:
        var var_expr = sse_decode_box_expr(deserializer);
        var var_by = sse_decode_list_expr(deserializer);
        var var_descending = sse_decode_list_bool(deserializer);
        return Expr_SortBy(
            expr: var_expr, by: var_by, descending: var_descending);
      case 10:
        var var_field0 = sse_decode_box_autoadd_agg_expr(deserializer);
        return Expr_Agg(var_field0);
      case 11:
        var var_predicate = sse_decode_box_expr(deserializer);
        var var_truthy = sse_decode_box_expr(deserializer);
        var var_falsy = sse_decode_box_expr(deserializer);
        return Expr_Ternary(
            predicate: var_predicate, truthy: var_truthy, falsy: var_falsy);
      case 12:
        var var_field0 = sse_decode_box_expr(deserializer);
        return Expr_Explode(var_field0);
      case 13:
        var var_input = sse_decode_box_expr(deserializer);
        var var_by = sse_decode_box_expr(deserializer);
        return Expr_Filter(input: var_input, by: var_by);
      case 14:
        var var_function = sse_decode_box_expr(deserializer);
        var var_partitionBy = sse_decode_list_expr(deserializer);
        var var_options = sse_decode_box_autoadd_window_type(deserializer);
        return Expr_Window(
            function: var_function,
            partitionBy: var_partitionBy,
            options: var_options);
      case 15:
        return Expr_Wildcard();
      case 16:
        var var_input = sse_decode_box_expr(deserializer);
        var var_offset = sse_decode_box_expr(deserializer);
        var var_length = sse_decode_box_expr(deserializer);
        return Expr_Slice(
            input: var_input, offset: var_offset, length: var_length);
      case 17:
        var var_field0 = sse_decode_box_expr(deserializer);
        var var_field1 = sse_decode_list_excluded(deserializer);
        return Expr_Exclude(var_field0, var_field1);
      case 18:
        var var_field0 = sse_decode_box_expr(deserializer);
        return Expr_KeepName(var_field0);
      case 19:
        return Expr_Count();
      case 20:
        var var_field0 = sse_decode_i_64(deserializer);
        return Expr_Nth(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    return deserializer.buffer.getFloat32();
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    return deserializer.buffer.getFloat64();
  }

  @protected
  Field sse_decode_field(SseDeserializer deserializer) {
    var var_name = sse_decode_String(deserializer);
    var var_dtype = sse_decode_data_type(deserializer);
    return Field(name: var_name, dtype: var_dtype);
  }

  @protected
  int sse_decode_i_16(SseDeserializer deserializer) {
    return deserializer.buffer.getInt16();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    return deserializer.buffer.getInt32();
  }

  @protected
  int sse_decode_i_64(SseDeserializer deserializer) {
    return deserializer.buffer.getInt64();
  }

  @protected
  int sse_decode_i_8(SseDeserializer deserializer) {
    return deserializer.buffer.getInt8();
  }

  @protected
  JoinType sse_decode_join_type(SseDeserializer deserializer) {
    var inner = sse_decode_i_32(deserializer);
    return JoinType.values[inner];
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<bool> sse_decode_list_bool(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <bool>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_bool(deserializer));
    }
    return ans_;
  }

  @protected
  List<dynamic> sse_decode_list_dartabi(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <dynamic>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_dartabi(deserializer));
    }
    return ans_;
  }

  @protected
  List<DataType> sse_decode_list_data_type(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DataType>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_data_type(deserializer));
    }
    return ans_;
  }

  @protected
  List<Excluded> sse_decode_list_excluded(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Excluded>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_excluded(deserializer));
    }
    return ans_;
  }

  @protected
  List<Expr> sse_decode_list_expr(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Expr>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_expr(deserializer));
    }
    return ans_;
  }

  @protected
  List<Field> sse_decode_list_field(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Field>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_field(deserializer));
    }
    return ans_;
  }

  @protected
  List<String?> sse_decode_list_opt_String(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<Duration?> sse_decode_list_opt_box_autoadd_Chrono_Duration(
      SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Duration?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_box_autoadd_Chrono_Duration(deserializer));
    }
    return ans_;
  }

  @protected
  List<DateTime?> sse_decode_list_opt_box_autoadd_Chrono_Local(
      SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DateTime?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_box_autoadd_Chrono_Local(deserializer));
    }
    return ans_;
  }

  @protected
  List<DateTime?> sse_decode_list_opt_box_autoadd_Chrono_Naive(
      SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DateTime?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_box_autoadd_Chrono_Naive(deserializer));
    }
    return ans_;
  }

  @protected
  List<DateTime?> sse_decode_list_opt_box_autoadd_Chrono_Utc(
      SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <DateTime?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_box_autoadd_Chrono_Utc(deserializer));
    }
    return ans_;
  }

  @protected
  List<double?> sse_decode_list_opt_box_autoadd_f_64(
      SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <double?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_box_autoadd_f_64(deserializer));
    }
    return ans_;
  }

  @protected
  List<int?> sse_decode_list_opt_box_autoadd_i_32(
      SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <int?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_box_autoadd_i_32(deserializer));
    }
    return ans_;
  }

  @protected
  List<int?> sse_decode_list_opt_box_autoadd_i_64(
      SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <int?>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_opt_box_autoadd_i_64(deserializer));
    }
    return ans_;
  }

  @protected
  Float64List sse_decode_list_prim_f_64(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getFloat64List(len_);
  }

  @protected
  Int64List sse_decode_list_prim_i_64(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getInt64List(len_);
  }

  @protected
  Uint32List sse_decode_list_prim_u_32(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8(SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, String)> sse_decode_list_record_string_string(
      SseDeserializer deserializer) {
    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, String)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_string(deserializer));
    }
    return ans_;
  }

  @protected
  LiteralValue sse_decode_literal_value(SseDeserializer deserializer) {
    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return LiteralValue_Null();
      case 1:
        var var_field0 = sse_decode_bool(deserializer);
        return LiteralValue_Boolean(var_field0);
      case 2:
        var var_field0 = sse_decode_String(deserializer);
        return LiteralValue_Utf8(var_field0);
      case 3:
        var var_field0 = sse_decode_list_prim_u_8(deserializer);
        return LiteralValue_Binary(var_field0);
      case 4:
        var var_field0 = sse_decode_u_8(deserializer);
        return LiteralValue_UInt8(var_field0);
      case 5:
        var var_field0 = sse_decode_u_16(deserializer);
        return LiteralValue_UInt16(var_field0);
      case 6:
        var var_field0 = sse_decode_u_32(deserializer);
        return LiteralValue_UInt32(var_field0);
      case 7:
        var var_field0 = sse_decode_u_64(deserializer);
        return LiteralValue_UInt64(var_field0);
      case 8:
        var var_field0 = sse_decode_i_8(deserializer);
        return LiteralValue_Int8(var_field0);
      case 9:
        var var_field0 = sse_decode_i_16(deserializer);
        return LiteralValue_Int16(var_field0);
      case 10:
        var var_field0 = sse_decode_i_32(deserializer);
        return LiteralValue_Int32(var_field0);
      case 11:
        var var_field0 = sse_decode_i_64(deserializer);
        return LiteralValue_Int64(var_field0);
      case 12:
        var var_field0 = sse_decode_f_32(deserializer);
        return LiteralValue_Float32(var_field0);
      case 13:
        var var_field0 = sse_decode_f_64(deserializer);
        return LiteralValue_Float64(var_field0);
      case 14:
        var var_low = sse_decode_i_64(deserializer);
        var var_high = sse_decode_i_64(deserializer);
        var var_dataType = sse_decode_box_autoadd_data_type(deserializer);
        return LiteralValue_Range(
            low: var_low, high: var_high, dataType: var_dataType);
      case 15:
        var var_field0 = sse_decode_i_64(deserializer);
        var var_field1 = sse_decode_time_unit(deserializer);
        var var_field2 = sse_decode_opt_String(deserializer);
        return LiteralValue_DateTime(var_field0, var_field1, var_field2);
      case 16:
        var var_field0 = sse_decode_i_64(deserializer);
        var var_field1 = sse_decode_time_unit(deserializer);
        return LiteralValue_Duration(var_field0, var_field1);
      case 17:
        var var_field0 = sse_decode_i_32(deserializer);
        return LiteralValue_Date(var_field0);
      case 18:
        var var_field0 = sse_decode_i_64(deserializer);
        return LiteralValue_Time(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  NullValues sse_decode_null_values(SseDeserializer deserializer) {
    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_String(deserializer);
        return NullValues_AllColumnsSingle(var_field0);
      case 1:
        var var_field0 = sse_decode_list_String(deserializer);
        return NullValues_AllColumns(var_field0);
      case 2:
        var var_field0 = sse_decode_list_record_string_string(deserializer);
        return NullValues_Named(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  Operator sse_decode_operator(SseDeserializer deserializer) {
    var inner = sse_decode_i_32(deserializer);
    return Operator.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Duration? sse_decode_opt_box_autoadd_Chrono_Duration(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Chrono_Duration(deserializer));
    } else {
      return null;
    }
  }

  @protected
  DateTime? sse_decode_opt_box_autoadd_Chrono_Local(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Chrono_Local(deserializer));
    } else {
      return null;
    }
  }

  @protected
  DateTime? sse_decode_opt_box_autoadd_Chrono_Naive(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Chrono_Naive(deserializer));
    } else {
      return null;
    }
  }

  @protected
  DateTime? sse_decode_opt_box_autoadd_Chrono_Utc(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Chrono_Utc(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  CsvEncoding? sse_decode_opt_box_autoadd_csv_encoding(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_csv_encoding(deserializer));
    } else {
      return null;
    }
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_64(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_64(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NullValues? sse_decode_opt_box_autoadd_null_values(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_null_values(deserializer));
    } else {
      return null;
    }
  }

  @protected
  RowCount? sse_decode_opt_box_autoadd_row_count(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_row_count(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_64(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_usize(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_usize(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String>? sse_decode_opt_list_String(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<bool>? sse_decode_opt_list_bool(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<DataType>? sse_decode_opt_list_data_type(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_data_type(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<Expr>? sse_decode_opt_list_expr(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_expr(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<String?>? sse_decode_opt_list_opt_String(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_opt_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<Duration?>? sse_decode_opt_list_opt_box_autoadd_Chrono_Duration(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_opt_box_autoadd_Chrono_Duration(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<double?>? sse_decode_opt_list_opt_box_autoadd_f_64(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_opt_box_autoadd_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<int?>? sse_decode_opt_list_opt_box_autoadd_i_32(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_opt_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  List<int?>? sse_decode_opt_list_opt_box_autoadd_i_64(
      SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_opt_box_autoadd_i_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Float64List? sse_decode_opt_list_prim_f_64(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_f_64(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint32List? sse_decode_opt_list_prim_u_32(SseDeserializer deserializer) {
    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  QuantileInterpolOptions sse_decode_quantile_interpol_options(
      SseDeserializer deserializer) {
    var inner = sse_decode_i_32(deserializer);
    return QuantileInterpolOptions.values[inner];
  }

  @protected
  (String, String) sse_decode_record_string_string(
      SseDeserializer deserializer) {
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  RowCount sse_decode_row_count(SseDeserializer deserializer) {
    var var_name = sse_decode_String(deserializer);
    var var_offset = sse_decode_u_32(deserializer);
    return RowCount(name: var_name, offset: var_offset);
  }

  @protected
  Shape sse_decode_shape(SseDeserializer deserializer) {
    var var_height = sse_decode_usize(deserializer);
    var var_width = sse_decode_usize(deserializer);
    return Shape(height: var_height, width: var_width);
  }

  @protected
  SortOptions sse_decode_sort_options(SseDeserializer deserializer) {
    var var_descending = sse_decode_bool(deserializer);
    var var_nullsLast = sse_decode_bool(deserializer);
    var var_multithreaded = sse_decode_bool(deserializer);
    var var_maintainOrder = sse_decode_bool(deserializer);
    return SortOptions(
        descending: var_descending,
        nullsLast: var_nullsLast,
        multithreaded: var_multithreaded,
        maintainOrder: var_maintainOrder);
  }

  @protected
  TimeUnit sse_decode_time_unit(SseDeserializer deserializer) {
    var inner = sse_decode_i_32(deserializer);
    return TimeUnit.values[inner];
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_64(SseDeserializer deserializer) {
    return deserializer.buffer.getUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    return deserializer.buffer.getUint8();
  }

  @protected
  UniqueKeepStrategy sse_decode_unique_keep_strategy(
      SseDeserializer deserializer) {
    var inner = sse_decode_i_32(deserializer);
    return UniqueKeepStrategy.values[inner];
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {}

  @protected
  int sse_decode_usize(SseDeserializer deserializer) {
    return deserializer.buffer.getUint64();
  }

  @protected
  WindowMapping sse_decode_window_mapping(SseDeserializer deserializer) {
    var inner = sse_decode_i_32(deserializer);
    return WindowMapping.values[inner];
  }

  @protected
  WindowType sse_decode_window_type(SseDeserializer deserializer) {
    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_window_mapping(deserializer);
        return WindowType_Over(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries(
          Series raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: true);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockOptioncratewrapperSchema(
          Schema raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: true);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockVeccratewrapperSeries(
          Series raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: true);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
          DataFrame raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: true);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
          LazyFrame raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: true);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
          LazyGroupBy raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: true);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSchema(
          Schema raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: true);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries(
          Series raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: true);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_RefMut_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
          DataFrame raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: false);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
          DataFrame raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: false);
  }

  @protected
  PlatformPointer
      cst_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
          Series raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode(move: false);
  }

  @protected
  PlatformPointer
      cst_encode_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries(
          Series raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  PlatformPointer cst_encode_RustOpaque_stdsyncRwLockOptioncratewrapperSchema(
      Schema raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  PlatformPointer cst_encode_RustOpaque_stdsyncRwLockVeccratewrapperSeries(
      Series raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  PlatformPointer cst_encode_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      DataFrame raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  PlatformPointer cst_encode_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
      LazyFrame raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  PlatformPointer cst_encode_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
      LazyGroupBy raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  PlatformPointer cst_encode_RustOpaque_stdsyncRwLockcratewrapperSchema(
      Schema raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  PlatformPointer cst_encode_RustOpaque_stdsyncRwLockcratewrapperSeries(
      Series raw) {
    // ignore: invalid_use_of_internal_member
    return raw.cstEncode();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    return raw;
  }

  @protected
  int cst_encode_csv_encoding(CsvEncoding raw) {
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_32(double raw) {
    return raw;
  }

  @protected
  double cst_encode_f_64(double raw) {
    return raw;
  }

  @protected
  int cst_encode_i_16(int raw) {
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    return raw;
  }

  @protected
  int cst_encode_i_8(int raw) {
    return raw;
  }

  @protected
  int cst_encode_join_type(JoinType raw) {
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_operator(Operator raw) {
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_quantile_interpol_options(QuantileInterpolOptions raw) {
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_time_unit(TimeUnit raw) {
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_16(int raw) {
    return raw;
  }

  @protected
  int cst_encode_u_32(int raw) {
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    return raw;
  }

  @protected
  int cst_encode_unique_keep_strategy(UniqueKeepStrategy raw) {
    return cst_encode_i_32(raw.index);
  }

  @protected
  void cst_encode_unit(void raw) {
    return raw;
  }

  @protected
  int cst_encode_usize(int raw) {
    return raw;
  }

  @protected
  int cst_encode_window_mapping(WindowMapping raw) {
    return cst_encode_i_32(raw.index);
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    throw UnimplementedError(
        'not yet supported in serialized mode, feel free to create an issue');
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries(
          Series self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_stdsyncRwLockOptioncratewrapperSchema(
      Schema self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_stdsyncRwLockVeccratewrapperSeries(
      Series self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      DataFrame self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
      LazyFrame self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
      LazyGroupBy self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSchema(
      Schema self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_Owned_RustOpaque_stdsyncRwLockcratewrapperSeries(
      Series self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: true), serializer);
  }

  @protected
  void sse_encode_Auto_RefMut_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      DataFrame self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      DataFrame self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_Auto_Ref_RustOpaque_stdsyncRwLockcratewrapperSeries(
      Series self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_Chrono_Duration(Duration self, SseSerializer serializer) {
    throw UnimplementedError(
        'not yet supported in serialized mode, feel free to create an issue');
  }

  @protected
  void sse_encode_Chrono_Local(DateTime self, SseSerializer serializer) {
    throw UnimplementedError(
        'not yet supported in serialized mode, feel free to create an issue');
  }

  @protected
  void sse_encode_Chrono_Naive(DateTime self, SseSerializer serializer) {
    throw UnimplementedError(
        'not yet supported in serialized mode, feel free to create an issue');
  }

  @protected
  void sse_encode_Chrono_Utc(DateTime self, SseSerializer serializer) {
    throw UnimplementedError(
        'not yet supported in serialized mode, feel free to create an issue');
  }

  @protected
  void sse_encode_RustOpaque_stdsyncRwLockOptionVeccratewrapperSeries(
      Series self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_stdsyncRwLockOptioncratewrapperSchema(
      Schema self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_stdsyncRwLockVeccratewrapperSeries(
      Series self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_stdsyncRwLockcratewrapperDataFrame(
      DataFrame self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_stdsyncRwLockcratewrapperLazyFrame(
      LazyFrame self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_stdsyncRwLockcratewrapperLazyGroupBy(
      LazyGroupBy self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_stdsyncRwLockcratewrapperSchema(
      Schema self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_RustOpaque_stdsyncRwLockcratewrapperSeries(
      Series self, SseSerializer serializer) {
    sse_encode_usize(self.sseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    sse_encode_list_prim_u_8(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_agg_expr(AggExpr self, SseSerializer serializer) {
    switch (self) {
      case AggExpr_Min(input: final input, propagateNans: final propagateNans):
        sse_encode_i_32(0, serializer);
        sse_encode_box_expr(input, serializer);
        sse_encode_bool(propagateNans, serializer);
      case AggExpr_Max(input: final input, propagateNans: final propagateNans):
        sse_encode_i_32(1, serializer);
        sse_encode_box_expr(input, serializer);
        sse_encode_bool(propagateNans, serializer);
      case AggExpr_Median(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_box_expr(field0, serializer);
      case AggExpr_NUnique(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_box_expr(field0, serializer);
      case AggExpr_First(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_box_expr(field0, serializer);
      case AggExpr_Last(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_box_expr(field0, serializer);
      case AggExpr_Mean(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_box_expr(field0, serializer);
      case AggExpr_Count(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_box_expr(field0, serializer);
      case AggExpr_Quantile(
          expr: final expr,
          quantile: final quantile,
          interpol: final interpol
        ):
        sse_encode_i_32(8, serializer);
        sse_encode_box_expr(expr, serializer);
        sse_encode_box_expr(quantile, serializer);
        sse_encode_quantile_interpol_options(interpol, serializer);
      case AggExpr_Sum(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_box_expr(field0, serializer);
      case AggExpr_AggGroups(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_box_expr(field0, serializer);
      case AggExpr_Std(field0: final field0, field1: final field1):
        sse_encode_i_32(11, serializer);
        sse_encode_box_expr(field0, serializer);
        sse_encode_u_8(field1, serializer);
      case AggExpr_Var(field0: final field0, field1: final field1):
        sse_encode_i_32(12, serializer);
        sse_encode_box_expr(field0, serializer);
        sse_encode_u_8(field1, serializer);
    }
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_Chrono_Duration(
      Duration self, SseSerializer serializer) {
    sse_encode_Chrono_Duration(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_Chrono_Local(
      DateTime self, SseSerializer serializer) {
    sse_encode_Chrono_Local(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_Chrono_Naive(
      DateTime self, SseSerializer serializer) {
    sse_encode_Chrono_Naive(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_Chrono_Utc(
      DateTime self, SseSerializer serializer) {
    sse_encode_Chrono_Utc(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_agg_expr(AggExpr self, SseSerializer serializer) {
    sse_encode_agg_expr(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_csv_encoding(
      CsvEncoding self, SseSerializer serializer) {
    sse_encode_csv_encoding(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_data_type(
      DataType self, SseSerializer serializer) {
    sse_encode_data_type(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_expr(Expr self, SseSerializer serializer) {
    sse_encode_expr(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_64(double self, SseSerializer serializer) {
    sse_encode_f_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_64(int self, SseSerializer serializer) {
    sse_encode_i_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_literal_value(
      LiteralValue self, SseSerializer serializer) {
    sse_encode_literal_value(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_null_values(
      NullValues self, SseSerializer serializer) {
    sse_encode_null_values(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_row_count(
      RowCount self, SseSerializer serializer) {
    sse_encode_row_count(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_sort_options(
      SortOptions self, SseSerializer serializer) {
    sse_encode_sort_options(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_64(int self, SseSerializer serializer) {
    sse_encode_u_64(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_usize(int self, SseSerializer serializer) {
    sse_encode_usize(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_window_type(
      WindowType self, SseSerializer serializer) {
    sse_encode_window_type(self, serializer);
  }

  @protected
  void sse_encode_box_data_type(DataType self, SseSerializer serializer) {
    sse_encode_data_type(self, serializer);
  }

  @protected
  void sse_encode_box_expr(Expr self, SseSerializer serializer) {
    sse_encode_expr(self, serializer);
  }

  @protected
  void sse_encode_csv_encoding(CsvEncoding self, SseSerializer serializer) {
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_dartabi(dynamic self, SseSerializer serializer) {
    throw UnimplementedError('');
  }

  @protected
  void sse_encode_data_type(DataType self, SseSerializer serializer) {
    switch (self) {
      case DataType_Boolean():
        sse_encode_i_32(0, serializer);
      case DataType_UInt8():
        sse_encode_i_32(1, serializer);
      case DataType_UInt16():
        sse_encode_i_32(2, serializer);
      case DataType_UInt32():
        sse_encode_i_32(3, serializer);
      case DataType_UInt64():
        sse_encode_i_32(4, serializer);
      case DataType_Int8():
        sse_encode_i_32(5, serializer);
      case DataType_Int16():
        sse_encode_i_32(6, serializer);
      case DataType_Int32():
        sse_encode_i_32(7, serializer);
      case DataType_Int64():
        sse_encode_i_32(8, serializer);
      case DataType_Float32():
        sse_encode_i_32(9, serializer);
      case DataType_Float64():
        sse_encode_i_32(10, serializer);
      case DataType_Utf8():
        sse_encode_i_32(11, serializer);
      case DataType_Binary():
        sse_encode_i_32(12, serializer);
      case DataType_Date():
        sse_encode_i_32(13, serializer);
      case DataType_Datetime(field0: final field0, field1: final field1):
        sse_encode_i_32(14, serializer);
        sse_encode_time_unit(field0, serializer);
        sse_encode_opt_String(field1, serializer);
      case DataType_Duration(field0: final field0):
        sse_encode_i_32(15, serializer);
        sse_encode_time_unit(field0, serializer);
      case DataType_Time():
        sse_encode_i_32(16, serializer);
      case DataType_List(field0: final field0):
        sse_encode_i_32(17, serializer);
        sse_encode_box_data_type(field0, serializer);
      case DataType_Null():
        sse_encode_i_32(18, serializer);
      case DataType_Struct(field0: final field0):
        sse_encode_i_32(19, serializer);
        sse_encode_list_field(field0, serializer);
      case DataType_Unknown():
        sse_encode_i_32(20, serializer);
    }
  }

  @protected
  void sse_encode_excluded(Excluded self, SseSerializer serializer) {
    switch (self) {
      case Excluded_Name(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case Excluded_Dtype(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_box_autoadd_data_type(field0, serializer);
    }
  }

  @protected
  void sse_encode_expr(Expr self, SseSerializer serializer) {
    switch (self) {
      case Expr_Alias(field0: final field0, field1: final field1):
        sse_encode_i_32(0, serializer);
        sse_encode_box_expr(field0, serializer);
        sse_encode_String(field1, serializer);
      case Expr_Column(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_String(field0, serializer);
      case Expr_Columns(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_list_String(field0, serializer);
      case Expr_DtypeColumn(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_list_data_type(field0, serializer);
      case Expr_Literal(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_box_autoadd_literal_value(field0, serializer);
      case Expr_BinaryExpr(left: final left, op: final op, right: final right):
        sse_encode_i_32(5, serializer);
        sse_encode_box_expr(left, serializer);
        sse_encode_operator(op, serializer);
        sse_encode_box_expr(right, serializer);
      case Expr_Cast(
          expr: final expr,
          dataType: final dataType,
          strict: final strict
        ):
        sse_encode_i_32(6, serializer);
        sse_encode_box_expr(expr, serializer);
        sse_encode_box_autoadd_data_type(dataType, serializer);
        sse_encode_bool(strict, serializer);
      case Expr_Sort(expr: final expr, options: final options):
        sse_encode_i_32(7, serializer);
        sse_encode_box_expr(expr, serializer);
        sse_encode_box_autoadd_sort_options(options, serializer);
      case Expr_Gather(
          expr: final expr,
          idx: final idx,
          returnsScalar: final returnsScalar
        ):
        sse_encode_i_32(8, serializer);
        sse_encode_box_expr(expr, serializer);
        sse_encode_box_expr(idx, serializer);
        sse_encode_bool(returnsScalar, serializer);
      case Expr_SortBy(
          expr: final expr,
          by: final by,
          descending: final descending
        ):
        sse_encode_i_32(9, serializer);
        sse_encode_box_expr(expr, serializer);
        sse_encode_list_expr(by, serializer);
        sse_encode_list_bool(descending, serializer);
      case Expr_Agg(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_box_autoadd_agg_expr(field0, serializer);
      case Expr_Ternary(
          predicate: final predicate,
          truthy: final truthy,
          falsy: final falsy
        ):
        sse_encode_i_32(11, serializer);
        sse_encode_box_expr(predicate, serializer);
        sse_encode_box_expr(truthy, serializer);
        sse_encode_box_expr(falsy, serializer);
      case Expr_Explode(field0: final field0):
        sse_encode_i_32(12, serializer);
        sse_encode_box_expr(field0, serializer);
      case Expr_Filter(input: final input, by: final by):
        sse_encode_i_32(13, serializer);
        sse_encode_box_expr(input, serializer);
        sse_encode_box_expr(by, serializer);
      case Expr_Window(
          function: final function,
          partitionBy: final partitionBy,
          options: final options
        ):
        sse_encode_i_32(14, serializer);
        sse_encode_box_expr(function, serializer);
        sse_encode_list_expr(partitionBy, serializer);
        sse_encode_box_autoadd_window_type(options, serializer);
      case Expr_Wildcard():
        sse_encode_i_32(15, serializer);
      case Expr_Slice(
          input: final input,
          offset: final offset,
          length: final length
        ):
        sse_encode_i_32(16, serializer);
        sse_encode_box_expr(input, serializer);
        sse_encode_box_expr(offset, serializer);
        sse_encode_box_expr(length, serializer);
      case Expr_Exclude(field0: final field0, field1: final field1):
        sse_encode_i_32(17, serializer);
        sse_encode_box_expr(field0, serializer);
        sse_encode_list_excluded(field1, serializer);
      case Expr_KeepName(field0: final field0):
        sse_encode_i_32(18, serializer);
        sse_encode_box_expr(field0, serializer);
      case Expr_Count():
        sse_encode_i_32(19, serializer);
      case Expr_Nth(field0: final field0):
        sse_encode_i_32(20, serializer);
        sse_encode_i_64(field0, serializer);
    }
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_field(Field self, SseSerializer serializer) {
    sse_encode_String(self.name, serializer);
    sse_encode_data_type(self.dtype, serializer);
  }

  @protected
  void sse_encode_i_16(int self, SseSerializer serializer) {
    serializer.buffer.putInt16(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(int self, SseSerializer serializer) {
    serializer.buffer.putInt64(self);
  }

  @protected
  void sse_encode_i_8(int self, SseSerializer serializer) {
    serializer.buffer.putInt8(self);
  }

  @protected
  void sse_encode_join_type(JoinType self, SseSerializer serializer) {
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_bool(List<bool> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_bool(item, serializer);
    }
  }

  @protected
  void sse_encode_list_dartabi(List<dynamic> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_dartabi(item, serializer);
    }
  }

  @protected
  void sse_encode_list_data_type(
      List<DataType> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_data_type(item, serializer);
    }
  }

  @protected
  void sse_encode_list_excluded(List<Excluded> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_excluded(item, serializer);
    }
  }

  @protected
  void sse_encode_list_expr(List<Expr> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_expr(item, serializer);
    }
  }

  @protected
  void sse_encode_list_field(List<Field> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_field(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_String(
      List<String?> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_box_autoadd_Chrono_Duration(
      List<Duration?> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_box_autoadd_Chrono_Duration(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_box_autoadd_Chrono_Local(
      List<DateTime?> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_box_autoadd_Chrono_Local(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_box_autoadd_Chrono_Naive(
      List<DateTime?> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_box_autoadd_Chrono_Naive(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_box_autoadd_Chrono_Utc(
      List<DateTime?> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_box_autoadd_Chrono_Utc(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_box_autoadd_f_64(
      List<double?> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_box_autoadd_f_64(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_box_autoadd_i_32(
      List<int?> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_box_autoadd_i_32(item, serializer);
    }
  }

  @protected
  void sse_encode_list_opt_box_autoadd_i_64(
      List<int?> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_opt_box_autoadd_i_64(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_f_64(Float64List self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putFloat64List(self);
  }

  @protected
  void sse_encode_list_prim_i_64(Int64List self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putInt64List(self);
  }

  @protected
  void sse_encode_list_prim_u_32(Uint32List self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8(Uint8List self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_string(
      List<(String, String)> self, SseSerializer serializer) {
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_string(item, serializer);
    }
  }

  @protected
  void sse_encode_literal_value(LiteralValue self, SseSerializer serializer) {
    switch (self) {
      case LiteralValue_Null():
        sse_encode_i_32(0, serializer);
      case LiteralValue_Boolean(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_bool(field0, serializer);
      case LiteralValue_Utf8(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_String(field0, serializer);
      case LiteralValue_Binary(field0: final field0):
        sse_encode_i_32(3, serializer);
        sse_encode_list_prim_u_8(field0, serializer);
      case LiteralValue_UInt8(field0: final field0):
        sse_encode_i_32(4, serializer);
        sse_encode_u_8(field0, serializer);
      case LiteralValue_UInt16(field0: final field0):
        sse_encode_i_32(5, serializer);
        sse_encode_u_16(field0, serializer);
      case LiteralValue_UInt32(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_u_32(field0, serializer);
      case LiteralValue_UInt64(field0: final field0):
        sse_encode_i_32(7, serializer);
        sse_encode_u_64(field0, serializer);
      case LiteralValue_Int8(field0: final field0):
        sse_encode_i_32(8, serializer);
        sse_encode_i_8(field0, serializer);
      case LiteralValue_Int16(field0: final field0):
        sse_encode_i_32(9, serializer);
        sse_encode_i_16(field0, serializer);
      case LiteralValue_Int32(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_i_32(field0, serializer);
      case LiteralValue_Int64(field0: final field0):
        sse_encode_i_32(11, serializer);
        sse_encode_i_64(field0, serializer);
      case LiteralValue_Float32(field0: final field0):
        sse_encode_i_32(12, serializer);
        sse_encode_f_32(field0, serializer);
      case LiteralValue_Float64(field0: final field0):
        sse_encode_i_32(13, serializer);
        sse_encode_f_64(field0, serializer);
      case LiteralValue_Range(
          low: final low,
          high: final high,
          dataType: final dataType
        ):
        sse_encode_i_32(14, serializer);
        sse_encode_i_64(low, serializer);
        sse_encode_i_64(high, serializer);
        sse_encode_box_autoadd_data_type(dataType, serializer);
      case LiteralValue_DateTime(
          field0: final field0,
          field1: final field1,
          field2: final field2
        ):
        sse_encode_i_32(15, serializer);
        sse_encode_i_64(field0, serializer);
        sse_encode_time_unit(field1, serializer);
        sse_encode_opt_String(field2, serializer);
      case LiteralValue_Duration(field0: final field0, field1: final field1):
        sse_encode_i_32(16, serializer);
        sse_encode_i_64(field0, serializer);
        sse_encode_time_unit(field1, serializer);
      case LiteralValue_Date(field0: final field0):
        sse_encode_i_32(17, serializer);
        sse_encode_i_32(field0, serializer);
      case LiteralValue_Time(field0: final field0):
        sse_encode_i_32(18, serializer);
        sse_encode_i_64(field0, serializer);
    }
  }

  @protected
  void sse_encode_null_values(NullValues self, SseSerializer serializer) {
    switch (self) {
      case NullValues_AllColumnsSingle(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_String(field0, serializer);
      case NullValues_AllColumns(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_list_String(field0, serializer);
      case NullValues_Named(field0: final field0):
        sse_encode_i_32(2, serializer);
        sse_encode_list_record_string_string(field0, serializer);
    }
  }

  @protected
  void sse_encode_operator(Operator self, SseSerializer serializer) {
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_Chrono_Duration(
      Duration? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Chrono_Duration(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_Chrono_Local(
      DateTime? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Chrono_Local(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_Chrono_Naive(
      DateTime? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Chrono_Naive(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_Chrono_Utc(
      DateTime? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Chrono_Utc(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_csv_encoding(
      CsvEncoding? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_csv_encoding(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_64(double? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_64(int? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_null_values(
      NullValues? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_null_values(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_row_count(
      RowCount? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_row_count(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_64(int? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_usize(int? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_usize(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_String(
      List<String>? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_bool(List<bool>? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_data_type(
      List<DataType>? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_data_type(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_expr(List<Expr>? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_expr(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_opt_String(
      List<String?>? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_opt_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_opt_box_autoadd_Chrono_Duration(
      List<Duration?>? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_opt_box_autoadd_Chrono_Duration(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_opt_box_autoadd_f_64(
      List<double?>? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_opt_box_autoadd_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_opt_box_autoadd_i_32(
      List<int?>? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_opt_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_opt_box_autoadd_i_64(
      List<int?>? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_opt_box_autoadd_i_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_f_64(
      Float64List? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_f_64(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_32(
      Uint32List? self, SseSerializer serializer) {
    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_quantile_interpol_options(
      QuantileInterpolOptions self, SseSerializer serializer) {
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_record_string_string(
      (String, String) self, SseSerializer serializer) {
    sse_encode_String(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_row_count(RowCount self, SseSerializer serializer) {
    sse_encode_String(self.name, serializer);
    sse_encode_u_32(self.offset, serializer);
  }

  @protected
  void sse_encode_shape(Shape self, SseSerializer serializer) {
    sse_encode_usize(self.height, serializer);
    sse_encode_usize(self.width, serializer);
  }

  @protected
  void sse_encode_sort_options(SortOptions self, SseSerializer serializer) {
    sse_encode_bool(self.descending, serializer);
    sse_encode_bool(self.nullsLast, serializer);
    sse_encode_bool(self.multithreaded, serializer);
    sse_encode_bool(self.maintainOrder, serializer);
  }

  @protected
  void sse_encode_time_unit(TimeUnit self, SseSerializer serializer) {
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(int self, SseSerializer serializer) {
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unique_keep_strategy(
      UniqueKeepStrategy self, SseSerializer serializer) {
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {}

  @protected
  void sse_encode_usize(int self, SseSerializer serializer) {
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_window_mapping(WindowMapping self, SseSerializer serializer) {
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_window_type(WindowType self, SseSerializer serializer) {
    switch (self) {
      case WindowType_Over(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_window_mapping(field0, serializer);
    }
  }
}
