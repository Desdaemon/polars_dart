// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'df.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$Literals {
  Object get field0 => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LiteralsCopyWith<$Res> {
  factory $LiteralsCopyWith(Literals value, $Res Function(Literals) then) =
      _$LiteralsCopyWithImpl<$Res, Literals>;
}

/// @nodoc
class _$LiteralsCopyWithImpl<$Res, $Val extends Literals>
    implements $LiteralsCopyWith<$Res> {
  _$LiteralsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Literals_Int64ImplCopyWith<$Res> {
  factory _$$Literals_Int64ImplCopyWith(_$Literals_Int64Impl value,
          $Res Function(_$Literals_Int64Impl) then) =
      __$$Literals_Int64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Int64List field0});
}

/// @nodoc
class __$$Literals_Int64ImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_Int64Impl>
    implements _$$Literals_Int64ImplCopyWith<$Res> {
  __$$Literals_Int64ImplCopyWithImpl(
      _$Literals_Int64Impl _value, $Res Function(_$Literals_Int64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Literals_Int64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Int64List,
    ));
  }
}

/// @nodoc

class _$Literals_Int64Impl extends Literals_Int64 {
  const _$Literals_Int64Impl(this.field0) : super._();

  @override
  final Int64List field0;

  @override
  String toString() {
    return 'Literals.int64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_Int64Impl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_Int64ImplCopyWith<_$Literals_Int64Impl> get copyWith =>
      __$$Literals_Int64ImplCopyWithImpl<_$Literals_Int64Impl>(
          this, _$identity);
}

abstract class Literals_Int64 extends Literals {
  const factory Literals_Int64(final Int64List field0) = _$Literals_Int64Impl;
  const Literals_Int64._() : super._();

  @override
  Int64List get field0;
  @JsonKey(ignore: true)
  _$$Literals_Int64ImplCopyWith<_$Literals_Int64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Literals_NullInt64ImplCopyWith<$Res> {
  factory _$$Literals_NullInt64ImplCopyWith(_$Literals_NullInt64Impl value,
          $Res Function(_$Literals_NullInt64Impl) then) =
      __$$Literals_NullInt64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<int?> field0});
}

/// @nodoc
class __$$Literals_NullInt64ImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_NullInt64Impl>
    implements _$$Literals_NullInt64ImplCopyWith<$Res> {
  __$$Literals_NullInt64ImplCopyWithImpl(_$Literals_NullInt64Impl _value,
      $Res Function(_$Literals_NullInt64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Literals_NullInt64Impl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<int?>,
    ));
  }
}

/// @nodoc

class _$Literals_NullInt64Impl extends Literals_NullInt64 {
  const _$Literals_NullInt64Impl(final List<int?> field0)
      : _field0 = field0,
        super._();

  final List<int?> _field0;
  @override
  List<int?> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Literals.nullInt64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_NullInt64Impl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_NullInt64ImplCopyWith<_$Literals_NullInt64Impl> get copyWith =>
      __$$Literals_NullInt64ImplCopyWithImpl<_$Literals_NullInt64Impl>(
          this, _$identity);
}

abstract class Literals_NullInt64 extends Literals {
  const factory Literals_NullInt64(final List<int?> field0) =
      _$Literals_NullInt64Impl;
  const Literals_NullInt64._() : super._();

  @override
  List<int?> get field0;
  @JsonKey(ignore: true)
  _$$Literals_NullInt64ImplCopyWith<_$Literals_NullInt64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Literals_Float64ImplCopyWith<$Res> {
  factory _$$Literals_Float64ImplCopyWith(_$Literals_Float64Impl value,
          $Res Function(_$Literals_Float64Impl) then) =
      __$$Literals_Float64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Float64List field0});
}

/// @nodoc
class __$$Literals_Float64ImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_Float64Impl>
    implements _$$Literals_Float64ImplCopyWith<$Res> {
  __$$Literals_Float64ImplCopyWithImpl(_$Literals_Float64Impl _value,
      $Res Function(_$Literals_Float64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Literals_Float64Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Float64List,
    ));
  }
}

/// @nodoc

class _$Literals_Float64Impl extends Literals_Float64 {
  const _$Literals_Float64Impl(this.field0) : super._();

  @override
  final Float64List field0;

  @override
  String toString() {
    return 'Literals.float64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_Float64Impl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_Float64ImplCopyWith<_$Literals_Float64Impl> get copyWith =>
      __$$Literals_Float64ImplCopyWithImpl<_$Literals_Float64Impl>(
          this, _$identity);
}

abstract class Literals_Float64 extends Literals {
  const factory Literals_Float64(final Float64List field0) =
      _$Literals_Float64Impl;
  const Literals_Float64._() : super._();

  @override
  Float64List get field0;
  @JsonKey(ignore: true)
  _$$Literals_Float64ImplCopyWith<_$Literals_Float64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Literals_NullFloat64ImplCopyWith<$Res> {
  factory _$$Literals_NullFloat64ImplCopyWith(_$Literals_NullFloat64Impl value,
          $Res Function(_$Literals_NullFloat64Impl) then) =
      __$$Literals_NullFloat64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<double?> field0});
}

/// @nodoc
class __$$Literals_NullFloat64ImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_NullFloat64Impl>
    implements _$$Literals_NullFloat64ImplCopyWith<$Res> {
  __$$Literals_NullFloat64ImplCopyWithImpl(_$Literals_NullFloat64Impl _value,
      $Res Function(_$Literals_NullFloat64Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Literals_NullFloat64Impl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<double?>,
    ));
  }
}

/// @nodoc

class _$Literals_NullFloat64Impl extends Literals_NullFloat64 {
  const _$Literals_NullFloat64Impl(final List<double?> field0)
      : _field0 = field0,
        super._();

  final List<double?> _field0;
  @override
  List<double?> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Literals.nullFloat64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_NullFloat64Impl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_NullFloat64ImplCopyWith<_$Literals_NullFloat64Impl>
      get copyWith =>
          __$$Literals_NullFloat64ImplCopyWithImpl<_$Literals_NullFloat64Impl>(
              this, _$identity);
}

abstract class Literals_NullFloat64 extends Literals {
  const factory Literals_NullFloat64(final List<double?> field0) =
      _$Literals_NullFloat64Impl;
  const Literals_NullFloat64._() : super._();

  @override
  List<double?> get field0;
  @JsonKey(ignore: true)
  _$$Literals_NullFloat64ImplCopyWith<_$Literals_NullFloat64Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Literals_BooleanImplCopyWith<$Res> {
  factory _$$Literals_BooleanImplCopyWith(_$Literals_BooleanImpl value,
          $Res Function(_$Literals_BooleanImpl) then) =
      __$$Literals_BooleanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<bool> field0});
}

/// @nodoc
class __$$Literals_BooleanImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_BooleanImpl>
    implements _$$Literals_BooleanImplCopyWith<$Res> {
  __$$Literals_BooleanImplCopyWithImpl(_$Literals_BooleanImpl _value,
      $Res Function(_$Literals_BooleanImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Literals_BooleanImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<bool>,
    ));
  }
}

/// @nodoc

class _$Literals_BooleanImpl extends Literals_Boolean {
  const _$Literals_BooleanImpl(final List<bool> field0)
      : _field0 = field0,
        super._();

  final List<bool> _field0;
  @override
  List<bool> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Literals.boolean(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_BooleanImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_BooleanImplCopyWith<_$Literals_BooleanImpl> get copyWith =>
      __$$Literals_BooleanImplCopyWithImpl<_$Literals_BooleanImpl>(
          this, _$identity);
}

abstract class Literals_Boolean extends Literals {
  const factory Literals_Boolean(final List<bool> field0) =
      _$Literals_BooleanImpl;
  const Literals_Boolean._() : super._();

  @override
  List<bool> get field0;
  @JsonKey(ignore: true)
  _$$Literals_BooleanImplCopyWith<_$Literals_BooleanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Literals_DurationImplCopyWith<$Res> {
  factory _$$Literals_DurationImplCopyWith(_$Literals_DurationImpl value,
          $Res Function(_$Literals_DurationImpl) then) =
      __$$Literals_DurationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Duration> field0});
}

/// @nodoc
class __$$Literals_DurationImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_DurationImpl>
    implements _$$Literals_DurationImplCopyWith<$Res> {
  __$$Literals_DurationImplCopyWithImpl(_$Literals_DurationImpl _value,
      $Res Function(_$Literals_DurationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Literals_DurationImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<Duration>,
    ));
  }
}

/// @nodoc

class _$Literals_DurationImpl extends Literals_Duration {
  const _$Literals_DurationImpl(final List<Duration> field0)
      : _field0 = field0,
        super._();

  final List<Duration> _field0;
  @override
  List<Duration> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Literals.duration(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_DurationImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_DurationImplCopyWith<_$Literals_DurationImpl> get copyWith =>
      __$$Literals_DurationImplCopyWithImpl<_$Literals_DurationImpl>(
          this, _$identity);
}

abstract class Literals_Duration extends Literals {
  const factory Literals_Duration(final List<Duration> field0) =
      _$Literals_DurationImpl;
  const Literals_Duration._() : super._();

  @override
  List<Duration> get field0;
  @JsonKey(ignore: true)
  _$$Literals_DurationImplCopyWith<_$Literals_DurationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Literals_NullDurationImplCopyWith<$Res> {
  factory _$$Literals_NullDurationImplCopyWith(
          _$Literals_NullDurationImpl value,
          $Res Function(_$Literals_NullDurationImpl) then) =
      __$$Literals_NullDurationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Duration?> field0});
}

/// @nodoc
class __$$Literals_NullDurationImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_NullDurationImpl>
    implements _$$Literals_NullDurationImplCopyWith<$Res> {
  __$$Literals_NullDurationImplCopyWithImpl(_$Literals_NullDurationImpl _value,
      $Res Function(_$Literals_NullDurationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Literals_NullDurationImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<Duration?>,
    ));
  }
}

/// @nodoc

class _$Literals_NullDurationImpl extends Literals_NullDuration {
  const _$Literals_NullDurationImpl(final List<Duration?> field0)
      : _field0 = field0,
        super._();

  final List<Duration?> _field0;
  @override
  List<Duration?> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'Literals.nullDuration(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_NullDurationImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_NullDurationImplCopyWith<_$Literals_NullDurationImpl>
      get copyWith => __$$Literals_NullDurationImplCopyWithImpl<
          _$Literals_NullDurationImpl>(this, _$identity);
}

abstract class Literals_NullDuration extends Literals {
  const factory Literals_NullDuration(final List<Duration?> field0) =
      _$Literals_NullDurationImpl;
  const Literals_NullDuration._() : super._();

  @override
  List<Duration?> get field0;
  @JsonKey(ignore: true)
  _$$Literals_NullDurationImplCopyWith<_$Literals_NullDurationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Literals_StringLikeImplCopyWith<$Res> {
  factory _$$Literals_StringLikeImplCopyWith(_$Literals_StringLikeImpl value,
          $Res Function(_$Literals_StringLikeImpl) then) =
      __$$Literals_StringLikeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> field0, DataType field1});

  $DataTypeCopyWith<$Res> get field1;
}

/// @nodoc
class __$$Literals_StringLikeImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_StringLikeImpl>
    implements _$$Literals_StringLikeImplCopyWith<$Res> {
  __$$Literals_StringLikeImplCopyWithImpl(_$Literals_StringLikeImpl _value,
      $Res Function(_$Literals_StringLikeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$Literals_StringLikeImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String>,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get field1 {
    return $DataTypeCopyWith<$Res>(_value.field1, (value) {
      return _then(_value.copyWith(field1: value));
    });
  }
}

/// @nodoc

class _$Literals_StringLikeImpl extends Literals_StringLike {
  const _$Literals_StringLikeImpl(final List<String> field0, this.field1)
      : _field0 = field0,
        super._();

  final List<String> _field0;
  @override
  List<String> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  final DataType field1;

  @override
  String toString() {
    return 'Literals.stringLike(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_StringLikeImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_field0), field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_StringLikeImplCopyWith<_$Literals_StringLikeImpl> get copyWith =>
      __$$Literals_StringLikeImplCopyWithImpl<_$Literals_StringLikeImpl>(
          this, _$identity);
}

abstract class Literals_StringLike extends Literals {
  const factory Literals_StringLike(
          final List<String> field0, final DataType field1) =
      _$Literals_StringLikeImpl;
  const Literals_StringLike._() : super._();

  @override
  List<String> get field0;
  DataType get field1;
  @JsonKey(ignore: true)
  _$$Literals_StringLikeImplCopyWith<_$Literals_StringLikeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Literals_NullStringLikeImplCopyWith<$Res> {
  factory _$$Literals_NullStringLikeImplCopyWith(
          _$Literals_NullStringLikeImpl value,
          $Res Function(_$Literals_NullStringLikeImpl) then) =
      __$$Literals_NullStringLikeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String?> field0, DataType field1});

  $DataTypeCopyWith<$Res> get field1;
}

/// @nodoc
class __$$Literals_NullStringLikeImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_NullStringLikeImpl>
    implements _$$Literals_NullStringLikeImplCopyWith<$Res> {
  __$$Literals_NullStringLikeImplCopyWithImpl(
      _$Literals_NullStringLikeImpl _value,
      $Res Function(_$Literals_NullStringLikeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$Literals_NullStringLikeImpl(
      null == field0
          ? _value._field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as List<String?>,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as DataType,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DataTypeCopyWith<$Res> get field1 {
    return $DataTypeCopyWith<$Res>(_value.field1, (value) {
      return _then(_value.copyWith(field1: value));
    });
  }
}

/// @nodoc

class _$Literals_NullStringLikeImpl extends Literals_NullStringLike {
  const _$Literals_NullStringLikeImpl(final List<String?> field0, this.field1)
      : _field0 = field0,
        super._();

  final List<String?> _field0;
  @override
  List<String?> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  final DataType field1;

  @override
  String toString() {
    return 'Literals.nullStringLike(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_NullStringLikeImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_field0), field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_NullStringLikeImplCopyWith<_$Literals_NullStringLikeImpl>
      get copyWith => __$$Literals_NullStringLikeImplCopyWithImpl<
          _$Literals_NullStringLikeImpl>(this, _$identity);
}

abstract class Literals_NullStringLike extends Literals {
  const factory Literals_NullStringLike(
          final List<String?> field0, final DataType field1) =
      _$Literals_NullStringLikeImpl;
  const Literals_NullStringLike._() : super._();

  @override
  List<String?> get field0;
  DataType get field1;
  @JsonKey(ignore: true)
  _$$Literals_NullStringLikeImplCopyWith<_$Literals_NullStringLikeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Literals_SeriesImplCopyWith<$Res> {
  factory _$$Literals_SeriesImplCopyWith(_$Literals_SeriesImpl value,
          $Res Function(_$Literals_SeriesImpl) then) =
      __$$Literals_SeriesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PSeries field0});
}

/// @nodoc
class __$$Literals_SeriesImplCopyWithImpl<$Res>
    extends _$LiteralsCopyWithImpl<$Res, _$Literals_SeriesImpl>
    implements _$$Literals_SeriesImplCopyWith<$Res> {
  __$$Literals_SeriesImplCopyWithImpl(
      _$Literals_SeriesImpl _value, $Res Function(_$Literals_SeriesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$Literals_SeriesImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as PSeries,
    ));
  }
}

/// @nodoc

class _$Literals_SeriesImpl extends Literals_Series {
  const _$Literals_SeriesImpl(this.field0) : super._();

  @override
  final PSeries field0;

  @override
  String toString() {
    return 'Literals.series(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Literals_SeriesImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Literals_SeriesImplCopyWith<_$Literals_SeriesImpl> get copyWith =>
      __$$Literals_SeriesImplCopyWithImpl<_$Literals_SeriesImpl>(
          this, _$identity);
}

abstract class Literals_Series extends Literals {
  const factory Literals_Series(final PSeries field0) = _$Literals_SeriesImpl;
  const Literals_Series._() : super._();

  @override
  PSeries get field0;
  @JsonKey(ignore: true)
  _$$Literals_SeriesImplCopyWith<_$Literals_SeriesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
