// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.3.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments
)]

// Section: imports

use crate::wrapper::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!();

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire_DataFrame_column_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    column: impl CstDecode<String> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_column",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_column = column.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::column(&api_that, api_column)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_column_at_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    index: impl CstDecode<usize> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_column_at",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_index = index.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::column_at(&api_that, api_index)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_columns_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    columns: impl CstDecode<Vec<String>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_columns",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_columns = columns.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::columns(&api_that, api_columns)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_describe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    percentiles: impl CstDecode<Option<Vec<f64>>> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_describe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_percentiles = percentiles.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::DataFrame::describe(&api_that, api_percentiles)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_DataFrame_drop_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    column: impl CstDecode<String> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_drop",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_column = column.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::drop(&api_that, api_column)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_drop_in_place_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    column: impl CstDecode<String> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_drop_in_place",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_column = column.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::drop_in_place(&api_that, api_column)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_dtypes_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_dtypes",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::dtypes(&api_that)
            })())
        },
    )
}
fn wire_DataFrame_dump_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_dump",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::dump(&api_that)
            })())
        },
    )
}
fn wire_DataFrame_estimated_size_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_estimated_size",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::estimated_size(&api_that)
            })())
        },
    )
}
fn wire_DataFrame_get_column_names_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_get_column_names",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::get_column_names(&api_that)
            })())
        },
    )
}
fn wire_DataFrame_get_columns_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_get_columns",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::get_columns(&api_that)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_get_row_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    index: impl CstDecode<usize> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_get_row",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_index = index.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::DataFrame::get_row(&api_that, api_index)
                })())
            }
        },
    )
}
fn wire_DataFrame_head_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    length: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_head",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_length = length.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::head(&api_that, api_length)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_height_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_height",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::height(&api_that)
            })())
        },
    )
}
fn wire_DataFrame_is_empty_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_is_empty",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::is_empty(&api_that)
            })())
        },
    )
}
fn wire_DataFrame_lazy_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    projection_pushdown: impl CstDecode<Option<bool>> + core::panic::UnwindSafe,
    predicate_pushdown: impl CstDecode<Option<bool>> + core::panic::UnwindSafe,
    type_coercion: impl CstDecode<Option<bool>> + core::panic::UnwindSafe,
    simplify_expressions: impl CstDecode<Option<bool>> + core::panic::UnwindSafe,
    slice_pushdown: impl CstDecode<Option<bool>> + core::panic::UnwindSafe,
    streaming: impl CstDecode<Option<bool>> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_lazy",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_projection_pushdown = projection_pushdown.cst_decode();
            let api_predicate_pushdown = predicate_pushdown.cst_decode();
            let api_type_coercion = type_coercion.cst_decode();
            let api_simplify_expressions = simplify_expressions.cst_decode();
            let api_slice_pushdown = slice_pushdown.cst_decode();
            let api_streaming = streaming.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::DataFrame::lazy(
                        &api_that,
                        api_projection_pushdown,
                        api_predicate_pushdown,
                        api_type_coercion,
                        api_simplify_expressions,
                        api_slice_pushdown,
                        api_streaming,
                    )
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_DataFrame_max_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_max",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::DataFrame::max(&api_that)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_DataFrame_of_impl(
    series: impl CstDecode<
            flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<Vec<crate::wrapper::Series>>>>,
        > + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_of",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_series = series.cst_decode();
            transform_result_dco((move || {
                let api_series = api_series.rust_auto_opaque_decode_owned()?;
                crate::wrapper::DataFrame::of(api_series)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_reverse_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_reverse",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::reverse(&api_that)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_sample_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    n: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    with_replacement: impl CstDecode<bool> + core::panic::UnwindSafe,
    shuffle: impl CstDecode<bool> + core::panic::UnwindSafe,
    seed: impl CstDecode<Option<u64>> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_sample",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_n = n.cst_decode();
            let api_with_replacement = with_replacement.cst_decode();
            let api_shuffle = shuffle.cst_decode();
            let api_seed = seed.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    let api_n = api_n.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::DataFrame::sample(
                        &api_that,
                        &api_n,
                        api_with_replacement,
                        api_shuffle,
                        api_seed,
                    )
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_DataFrame_schema_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_schema",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::schema(&api_that)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_select_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    columns: impl CstDecode<Vec<String>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_select",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_columns = columns.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::select(&api_that, api_columns)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_shape_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_shape",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::shape(&api_that)
            })())
        },
    )
}
fn wire_DataFrame_sort_in_place_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    by_column: impl CstDecode<Vec<String>> + core::panic::UnwindSafe,
    descending: impl CstDecode<Vec<bool>> + core::panic::UnwindSafe,
    maintain_order: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_sort_in_place",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_by_column = by_column.cst_decode();
            let api_descending = descending.cst_decode();
            let api_maintain_order = maintain_order.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let mut api_that = api_that.rust_auto_opaque_decode_ref_mut()?;
                    crate::wrapper::DataFrame::sort_in_place(
                        &mut api_that,
                        api_by_column,
                        api_descending,
                        api_maintain_order,
                    )
                })())
            }
        },
    )
}
fn wire_DataFrame_tail_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    length: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_tail",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_length = length.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::tail(&api_that, api_length)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_DataFrame_width_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_width",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::width(&api_that)
            })())
        },
    )
}
fn wire_DataFrame_with_row_count_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>>>
        + core::panic::UnwindSafe,
    name: impl CstDecode<String> + core::panic::UnwindSafe,
    offset: impl CstDecode<Option<u32>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "DataFrame_with_row_count",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_name = name.cst_decode();
            let api_offset = offset.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::DataFrame::with_row_count(&api_that, api_name, api_offset)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_cache_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_cache",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::cache(api_that)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_collect_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_collect",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_owned()?;
                    crate::wrapper::LazyFrame::collect(api_that)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_LazyFrame_cross_join_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_cross_join",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                let api_other = api_other.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::cross_join(api_that, api_other)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_drop_nulls_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    subset: impl CstDecode<Option<Vec<crate::wrapper::Expr>>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_drop_nulls",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_subset = subset.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                Result::<_, anyhow::Error>::Ok(
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                        crate::wrapper::LazyFrame::drop_nulls(api_that, api_subset),
                    ),
                )
            })())
        },
    )
}
fn wire_LazyFrame_explode_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    columns: impl CstDecode<Vec<crate::wrapper::Expr>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_explode",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_columns = columns.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                Result::<_, anyhow::Error>::Ok(
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                        crate::wrapper::LazyFrame::explode(api_that, api_columns),
                    ),
                )
            })())
        },
    )
}
fn wire_LazyFrame_fetch_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    n_rows: impl CstDecode<usize> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_fetch",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_n_rows = n_rows.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_owned()?;
                    crate::wrapper::LazyFrame::fetch(api_that, api_n_rows)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_LazyFrame_filter_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    pred: impl CstDecode<crate::wrapper::Expr> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_filter",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_pred = pred.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::filter(api_that, api_pred)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_first_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_first",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                Result::<_, anyhow::Error>::Ok(
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                        crate::wrapper::LazyFrame::first(api_that),
                    ),
                )
            })())
        },
    )
}
fn wire_LazyFrame_group_by_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    exprs: impl CstDecode<Vec<crate::wrapper::Expr>> + core::panic::UnwindSafe,
    maintain_order: impl CstDecode<bool> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_group_by",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_exprs = exprs.cst_decode();
            let api_maintain_order = maintain_order.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                Result::<_, anyhow::Error>::Ok(
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                        crate::wrapper::LazyFrame::group_by(
                            api_that,
                            api_exprs,
                            api_maintain_order,
                        ),
                    ),
                )
            })())
        },
    )
}
fn wire_LazyFrame_inner_join_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    left_on: impl CstDecode<crate::wrapper::Expr> + core::panic::UnwindSafe,
    right_on: impl CstDecode<crate::wrapper::Expr> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_inner_join",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            let api_left_on = left_on.cst_decode();
            let api_right_on = right_on.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                let api_other = api_other.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::inner_join(
                    api_that,
                    api_other,
                    api_left_on,
                    api_right_on,
                )
                .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_join_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    on: impl CstDecode<Option<Vec<crate::wrapper::Expr>>> + core::panic::UnwindSafe,
    left_on: impl CstDecode<Option<Vec<crate::wrapper::Expr>>> + core::panic::UnwindSafe,
    right_on: impl CstDecode<Option<Vec<crate::wrapper::Expr>>> + core::panic::UnwindSafe,
    suffix: impl CstDecode<String> + core::panic::UnwindSafe,
    how: impl CstDecode<crate::wrapper::JoinType> + core::panic::UnwindSafe,
    allow_parallel: impl CstDecode<bool> + core::panic::UnwindSafe,
    force_parallel: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_join",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            let api_on = on.cst_decode();
            let api_left_on = left_on.cst_decode();
            let api_right_on = right_on.cst_decode();
            let api_suffix = suffix.cst_decode();
            let api_how = how.cst_decode();
            let api_allow_parallel = allow_parallel.cst_decode();
            let api_force_parallel = force_parallel.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_owned()?;
                    let api_other = api_other.rust_auto_opaque_decode_owned()?;
                    crate::wrapper::LazyFrame::join(
                        api_that,
                        api_other,
                        api_on,
                        api_left_on,
                        api_right_on,
                        api_suffix,
                        api_how,
                        api_allow_parallel,
                        api_force_parallel,
                    )
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_LazyFrame_last_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_last",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                Result::<_, anyhow::Error>::Ok(
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                        crate::wrapper::LazyFrame::last(api_that),
                    ),
                )
            })())
        },
    )
}
fn wire_LazyFrame_left_join_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    left_on: impl CstDecode<crate::wrapper::Expr> + core::panic::UnwindSafe,
    right_on: impl CstDecode<crate::wrapper::Expr> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_left_join",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            let api_left_on = left_on.cst_decode();
            let api_right_on = right_on.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                let api_other = api_other.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::left_join(api_that, api_other, api_left_on, api_right_on)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_limit_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    n: impl CstDecode<u32> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_limit",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_n = n.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::limit(api_that, api_n)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_max_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_max",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::max(api_that)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_mean_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_mean",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::mean(api_that)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_median_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_median",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::median(api_that)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_melt_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    id_vars: impl CstDecode<Vec<String>> + core::panic::UnwindSafe,
    value_vars: impl CstDecode<Vec<String>> + core::panic::UnwindSafe,
    variable_name: impl CstDecode<Option<String>> + core::panic::UnwindSafe,
    value_name: impl CstDecode<Option<String>> + core::panic::UnwindSafe,
    streamable: impl CstDecode<bool> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_melt",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_id_vars = id_vars.cst_decode();
            let api_value_vars = value_vars.cst_decode();
            let api_variable_name = variable_name.cst_decode();
            let api_value_name = value_name.cst_decode();
            let api_streamable = streamable.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::melt(
                    api_that,
                    api_id_vars,
                    api_value_vars,
                    api_variable_name,
                    api_value_name,
                    api_streamable,
                )
                .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_min_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_min",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_owned()?;
                    crate::wrapper::LazyFrame::min(api_that)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_LazyFrame_outer_join_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    left_on: impl CstDecode<crate::wrapper::Expr> + core::panic::UnwindSafe,
    right_on: impl CstDecode<crate::wrapper::Expr> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_outer_join",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            let api_left_on = left_on.cst_decode();
            let api_right_on = right_on.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                let api_other = api_other.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::outer_join(
                    api_that,
                    api_other,
                    api_left_on,
                    api_right_on,
                )
                .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_quantile_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    quantile: impl CstDecode<crate::wrapper::Expr> + core::panic::UnwindSafe,
    interpol: impl CstDecode<crate::wrapper::QuantileInterpolOptions> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_quantile",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_quantile = quantile.cst_decode();
            let api_interpol = interpol.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::quantile(api_that, api_quantile, api_interpol)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_reverse_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_reverse",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::reverse(api_that)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_slice_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    offset: impl CstDecode<i64> + core::panic::UnwindSafe,
    len: impl CstDecode<u32> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_slice",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offset = offset.cst_decode();
            let api_len = len.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::slice(api_that, api_offset, api_len)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_std_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    ddof: impl CstDecode<u8> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_std",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_ddof = ddof.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::std(api_that, api_ddof)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_sum_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_sum",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::sum(api_that)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_tail_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    n: impl CstDecode<u32> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_tail",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_n = n.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                Result::<_, anyhow::Error>::Ok(
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                        crate::wrapper::LazyFrame::tail(api_that, api_n),
                    ),
                )
            })())
        },
    )
}
fn wire_LazyFrame_unique_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    subset: impl CstDecode<Option<Vec<String>>> + core::panic::UnwindSafe,
    keep_strategy: impl CstDecode<crate::wrapper::UniqueKeepStrategy> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_unique",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_subset = subset.cst_decode();
            let api_keep_strategy = keep_strategy.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::unique(api_that, api_subset, api_keep_strategy)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_variance_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    ddof: impl CstDecode<u8> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_variance",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_ddof = ddof.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::variance(api_that, api_ddof)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_with_column_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    expr: impl CstDecode<crate::wrapper::Expr> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_with_column",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_expr = expr.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::with_column(api_that, api_expr)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyFrame_with_row_count_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>>>
        + core::panic::UnwindSafe,
    name: impl CstDecode<String> + core::panic::UnwindSafe,
    offset: impl CstDecode<Option<u32>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyFrame_with_row_count",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_name = name.cst_decode();
            let api_offset = offset.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyFrame::with_row_count(api_that, api_name, api_offset)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyGroupBy_head_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyGroupBy>>>
        + core::panic::UnwindSafe,
    n: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyGroupBy_head",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_n = n.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyGroupBy::head(api_that, api_n)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_LazyGroupBy_tail_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyGroupBy>>>
        + core::panic::UnwindSafe,
    n: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "LazyGroupBy_tail",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_n = n.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                crate::wrapper::LazyGroupBy::tail(api_that, api_n)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_Schema_of_impl(
    fields: impl CstDecode<Vec<crate::wrapper::Field>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Schema_of",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_fields = fields.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                    crate::wrapper::Schema::of(api_fields),
                ))
            })())
        },
    )
}
fn wire_Series_add_to_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_add_to",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                let api_other = api_other.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::add_to(&api_that, &api_other)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_Series_append_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_append",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    let api_other = api_other.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::append(&api_that, &api_other)
                })())
            }
        },
    )
}
fn wire_Series_apply_scalar_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    op: impl CstDecode<crate::wrapper::Operator> + core::panic::UnwindSafe,
    value: impl CstDecode<f64> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_apply_scalar",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_op = op.cst_decode();
            let api_value = value.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::apply_scalar(&api_that, api_op, api_value)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_as_doubles_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    strict: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_as_doubles",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_strict = strict.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::as_doubles(&api_that, api_strict)
                })())
            }
        },
    )
}
fn wire_Series_as_durations_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_as_durations",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::as_durations(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_as_ints_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    strict: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_as_ints",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_strict = strict.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::as_ints(&api_that, api_strict)
                })())
            }
        },
    )
}
fn wire_Series_as_local_datetime_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_as_local_datetime",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::as_local_datetime(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_as_naive_datetime_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_as_naive_datetime",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::as_naive_datetime(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_as_strings_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_as_strings",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::as_strings(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_as_utc_datetime_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_as_utc_datetime",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::as_utc_datetime(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_cast_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    dtype: impl CstDecode<crate::wrapper::DataType> + core::panic::UnwindSafe,
    strict: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_cast",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_dtype = dtype.cst_decode();
            let api_strict = strict.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::cast(&api_that, api_dtype, api_strict)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_divide_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_divide",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                let api_other = api_other.rust_auto_opaque_decode_owned()?;
                crate::wrapper::Series::divide(&api_that, api_other)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_Series_dump_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_dump",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::dump(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_equal_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    ignore_null: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_equal",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            let api_ignore_null = ignore_null.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    let api_other = api_other.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::equal(&api_that, &api_other, api_ignore_null)
                })())
            }
        },
    )
}
fn wire_Series_estimated_size_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_estimated_size",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::estimated_size(&api_that)
            })())
        },
    )
}
fn wire_Series_explode_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_explode",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::explode(&api_that)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_explode_by_offsets_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    offsets: impl CstDecode<Vec<i64>> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_explode_by_offsets",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_offsets = offsets.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::explode_by_offsets(&api_that, api_offsets)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_get_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    index: impl CstDecode<usize> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_get",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_index = index.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::get(&api_that, api_index)
            })())
        },
    )
}
fn wire_Series_get_string_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    index: impl CstDecode<usize> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_get_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_index = index.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::get_string(&api_that, api_index)
            })())
        },
    )
}
fn wire_Series_head_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    length: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_head",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_length = length.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::head(&api_that, api_length)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_Series_into_frame_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_into_frame",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_owned()?;
                Result::<_, anyhow::Error>::Ok(
                    flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                        crate::wrapper::Series::into_frame(api_that),
                    ),
                )
            })())
        },
    )
}
fn wire_Series_is_bool_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_is_bool",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::is_bool(&api_that)
            })())
        },
    )
}
fn wire_Series_is_numeric_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_is_numeric",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::is_numeric(&api_that)
            })())
        },
    )
}
fn wire_Series_is_temporal_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_is_temporal",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::is_temporal(&api_that)
            })())
        },
    )
}
fn wire_Series_is_utf8_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_is_utf8",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::is_utf8(&api_that)
            })())
        },
    )
}
fn wire_Series_max_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_max",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::max(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_mean_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_mean",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::mean(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_mean_as_series_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_mean_as_series",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::mean_as_series(&api_that)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_median_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_median",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::median(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_median_as_series_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_median_as_series",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::median_as_series(&api_that)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_min_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_min",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::min(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_multiply_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_multiply",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                let api_other = api_other.rust_auto_opaque_decode_owned()?;
                crate::wrapper::Series::multiply(&api_that, api_other)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_Series_of_bools_impl(
    name: impl CstDecode<String> + core::panic::UnwindSafe,
    values: impl CstDecode<Option<Vec<bool>>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_of_bools",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_name = name.cst_decode();
            let api_values = values.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                    crate::wrapper::Series::of_bools(api_name, api_values),
                ))
            })())
        },
    )
}
fn wire_Series_of_doubles_impl(
    name: impl CstDecode<String> + core::panic::UnwindSafe,
    values: impl CstDecode<Option<Vec<Option<f64>>>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_of_doubles",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_name = name.cst_decode();
            let api_values = values.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                    crate::wrapper::Series::of_doubles(api_name, api_values),
                ))
            })())
        },
    )
}
fn wire_Series_of_durations_impl(
    name: impl CstDecode<String> + core::panic::UnwindSafe,
    values: impl CstDecode<Option<Vec<Option<chrono::Duration>>>> + core::panic::UnwindSafe,
    unit: impl CstDecode<crate::wrapper::TimeUnit> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_of_durations",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_name = name.cst_decode();
            let api_values = values.cst_decode();
            let api_unit = unit.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                    crate::wrapper::Series::of_durations(api_name, api_values, api_unit),
                ))
            })())
        },
    )
}
fn wire_Series_of_i32_impl(
    name: impl CstDecode<String> + core::panic::UnwindSafe,
    values: impl CstDecode<Option<Vec<Option<i32>>>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_of_i32",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_name = name.cst_decode();
            let api_values = values.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                    crate::wrapper::Series::of_i32(api_name, api_values),
                ))
            })())
        },
    )
}
fn wire_Series_of_ints_impl(
    name: impl CstDecode<String> + core::panic::UnwindSafe,
    values: impl CstDecode<Option<Vec<Option<i64>>>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_of_ints",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_name = name.cst_decode();
            let api_values = values.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                    crate::wrapper::Series::of_ints(api_name, api_values),
                ))
            })())
        },
    )
}
fn wire_Series_of_strings_impl(
    name: impl CstDecode<String> + core::panic::UnwindSafe,
    values: impl CstDecode<Option<Vec<Option<String>>>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_of_strings",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_name = name.cst_decode();
            let api_values = values.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                    crate::wrapper::Series::of_strings(api_name, api_values),
                ))
            })())
        },
    )
}
fn wire_Series_product_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_product",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::product(&api_that)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_remainder_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_remainder",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                let api_other = api_other.rust_auto_opaque_decode_owned()?;
                crate::wrapper::Series::remainder(&api_that, api_other)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_Series_rename_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    name: impl CstDecode<String> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_rename",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_name = name.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::rename(&api_that, api_name)
            })())
        },
    )
}
fn wire_Series_reshape_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    dims: impl CstDecode<Vec<i64>> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_reshape",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_dims = dims.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::reshape(&api_that, api_dims)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_shuffle_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    seed: impl CstDecode<Option<u64>> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_shuffle",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_seed = seed.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::shuffle(&api_that, api_seed)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_sort_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    reverse: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_sort",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_reverse = reverse.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::sort(&api_that, api_reverse)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_std_as_series_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    ddof: impl CstDecode<u8> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_std_as_series",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_ddof = ddof.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    Result::<_, anyhow::Error>::Ok(
                        flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                            crate::wrapper::Series::std_as_series(&api_that, api_ddof),
                        ),
                    )
                })())
            }
        },
    )
}
fn wire_Series_subtract_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    other: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_subtract",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_other = other.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                let api_other = api_other.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::subtract(&api_that, &api_other)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_Series_sum_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_sum",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::sum(&api_that)
                })())
            }
        },
    )
}
fn wire_Series_sum_as_series_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_sum_as_series",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::sum_as_series(&api_that)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_tail_impl(
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    length: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_tail",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_that = that.cst_decode();
            let api_length = length.cst_decode();
            transform_result_dco((move || {
                let api_that = api_that.rust_auto_opaque_decode_ref()?;
                crate::wrapper::Series::tail(&api_that, api_length)
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
            })())
        },
    )
}
fn wire_Series_to_list_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_to_list",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    Result::<_, anyhow::Error>::Ok(crate::wrapper::Series::to_list(&api_that))
                })())
            }
        },
    )
}
fn wire_Series_unique_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    stable: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_unique",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_stable = stable.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    crate::wrapper::Series::unique(&api_that, api_stable)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_Series_var_as_series_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>>>
        + core::panic::UnwindSafe,
    ddof: impl CstDecode<u8> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "Series_var_as_series",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_ddof = ddof.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_that = api_that.rust_auto_opaque_decode_ref()?;
                    Result::<_, anyhow::Error>::Ok(
                        flutter_rust_bridge::for_generated::rust_auto_opaque_encode(
                            crate::wrapper::Series::var_as_series(&api_that, api_ddof),
                        ),
                    )
                })())
            }
        },
    )
}
fn wire_read_csv_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String> + core::panic::UnwindSafe,
    dtypes_slice: impl CstDecode<Option<Vec<crate::wrapper::DataType>>> + core::panic::UnwindSafe,
    has_header: impl CstDecode<Option<bool>> + core::panic::UnwindSafe,
    columns: impl CstDecode<Option<Vec<String>>> + core::panic::UnwindSafe,
    comment_char: impl CstDecode<Option<String>> + core::panic::UnwindSafe,
    eol_char: impl CstDecode<Option<String>> + core::panic::UnwindSafe,
    chunk_size: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
    sample_size: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
    row_count: impl CstDecode<Option<crate::wrapper::RowCount>> + core::panic::UnwindSafe,
    encoding: impl CstDecode<Option<crate::wrapper::CsvEncoding>> + core::panic::UnwindSafe,
    n_rows: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
    n_threads: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
    null_values: impl CstDecode<Option<crate::wrapper::NullValues>> + core::panic::UnwindSafe,
    projection: impl CstDecode<Option<Vec<u32>>> + core::panic::UnwindSafe,
    quote_char: impl CstDecode<Option<String>> + core::panic::UnwindSafe,
    skip_rows: impl CstDecode<usize> + core::panic::UnwindSafe,
    skip_rows_after_header: impl CstDecode<usize> + core::panic::UnwindSafe,
    ignore_errors: impl CstDecode<bool> + core::panic::UnwindSafe,
    rechunk: impl CstDecode<bool> + core::panic::UnwindSafe,
    try_parse_dates: impl CstDecode<bool> + core::panic::UnwindSafe,
    low_memory: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "read_csv",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            let api_dtypes_slice = dtypes_slice.cst_decode();
            let api_has_header = has_header.cst_decode();
            let api_columns = columns.cst_decode();
            let api_comment_char = comment_char.cst_decode();
            let api_eol_char = eol_char.cst_decode();
            let api_chunk_size = chunk_size.cst_decode();
            let api_sample_size = sample_size.cst_decode();
            let api_row_count = row_count.cst_decode();
            let api_encoding = encoding.cst_decode();
            let api_n_rows = n_rows.cst_decode();
            let api_n_threads = n_threads.cst_decode();
            let api_null_values = null_values.cst_decode();
            let api_projection = projection.cst_decode();
            let api_quote_char = quote_char.cst_decode();
            let api_skip_rows = skip_rows.cst_decode();
            let api_skip_rows_after_header = skip_rows_after_header.cst_decode();
            let api_ignore_errors = ignore_errors.cst_decode();
            let api_rechunk = rechunk.cst_decode();
            let api_try_parse_dates = try_parse_dates.cst_decode();
            let api_low_memory = low_memory.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::wrapper::read_csv(
                        api_path,
                        api_dtypes_slice,
                        api_has_header,
                        api_columns,
                        api_comment_char,
                        api_eol_char,
                        api_chunk_size,
                        api_sample_size,
                        api_row_count,
                        api_encoding,
                        api_n_rows,
                        api_n_threads,
                        api_null_values,
                        api_projection,
                        api_quote_char,
                        api_skip_rows,
                        api_skip_rows_after_header,
                        api_ignore_errors,
                        api_rechunk,
                        api_try_parse_dates,
                        api_low_memory,
                    )
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_read_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String> + core::panic::UnwindSafe,
    batch_size: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
    projection: impl CstDecode<Option<Vec<String>>> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "read_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            let api_batch_size = batch_size.cst_decode();
            let api_projection = projection.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::wrapper::read_json(api_path, api_batch_size, api_projection)
                        .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}
fn wire_scan_csv_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    path: impl CstDecode<String> + core::panic::UnwindSafe,
    dtype_overwrite: impl CstDecode<
            flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<crate::wrapper::Schema>>>,
        > + core::panic::UnwindSafe,
    has_header: impl CstDecode<Option<bool>> + core::panic::UnwindSafe,
    comment_char: impl CstDecode<Option<String>> + core::panic::UnwindSafe,
    eol_char: impl CstDecode<Option<String>> + core::panic::UnwindSafe,
    quote_char: impl CstDecode<Option<String>> + core::panic::UnwindSafe,
    skip_rows: impl CstDecode<usize> + core::panic::UnwindSafe,
    skip_rows_after_header: impl CstDecode<usize> + core::panic::UnwindSafe,
    row_count: impl CstDecode<Option<crate::wrapper::RowCount>> + core::panic::UnwindSafe,
    encoding: impl CstDecode<Option<crate::wrapper::CsvEncoding>> + core::panic::UnwindSafe,
    n_rows: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
    null_values: impl CstDecode<Option<crate::wrapper::NullValues>> + core::panic::UnwindSafe,
    ignore_errors: impl CstDecode<bool> + core::panic::UnwindSafe,
    rechunk: impl CstDecode<bool> + core::panic::UnwindSafe,
    try_parse_dates: impl CstDecode<bool> + core::panic::UnwindSafe,
    infer_schema_length: impl CstDecode<Option<usize>> + core::panic::UnwindSafe,
    cache: impl CstDecode<bool> + core::panic::UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "scan_csv",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_path = path.cst_decode();
            let api_dtype_overwrite = dtype_overwrite.cst_decode();
            let api_has_header = has_header.cst_decode();
            let api_comment_char = comment_char.cst_decode();
            let api_eol_char = eol_char.cst_decode();
            let api_quote_char = quote_char.cst_decode();
            let api_skip_rows = skip_rows.cst_decode();
            let api_skip_rows_after_header = skip_rows_after_header.cst_decode();
            let api_row_count = row_count.cst_decode();
            let api_encoding = encoding.cst_decode();
            let api_n_rows = n_rows.cst_decode();
            let api_null_values = null_values.cst_decode();
            let api_ignore_errors = ignore_errors.cst_decode();
            let api_rechunk = rechunk.cst_decode();
            let api_try_parse_dates = try_parse_dates.cst_decode();
            let api_infer_schema_length = infer_schema_length.cst_decode();
            let api_cache = cache.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    let api_dtype_overwrite =
                        api_dtype_overwrite.rust_auto_opaque_decode_owned()?;
                    crate::wrapper::scan_csv(
                        api_path,
                        api_dtype_overwrite,
                        api_has_header,
                        api_comment_char,
                        api_eol_char,
                        api_quote_char,
                        api_skip_rows,
                        api_skip_rows_after_header,
                        api_row_count,
                        api_encoding,
                        api_n_rows,
                        api_null_values,
                        api_ignore_errors,
                        api_rechunk,
                        api_try_parse_dates,
                        api_infer_schema_length,
                        api_cache,
                    )
                    .map(flutter_rust_bridge::for_generated::rust_auto_opaque_encode)
                })())
            }
        },
    )
}

// Section: wrapper_structs

#[derive(Clone)]
pub struct mirror_AggExpr(crate::wrapper::AggExpr);

#[derive(Clone)]
pub struct mirror_CsvEncoding(crate::wrapper::CsvEncoding);

#[derive(Clone)]
pub struct mirror_DataType(crate::wrapper::DataType);

#[derive(Clone)]
pub struct mirror_Excluded(crate::wrapper::Excluded);

#[derive(Clone)]
pub struct mirror_Expr(crate::wrapper::Expr);

#[derive(Clone)]
pub struct mirror_Field(crate::wrapper::Field);

#[derive(Clone)]
pub struct mirror_JoinType(crate::wrapper::JoinType);

#[derive(Clone)]
pub struct mirror_LiteralValue(crate::wrapper::LiteralValue);

#[derive(Clone)]
pub struct mirror_NullValues(crate::wrapper::NullValues);

#[derive(Clone)]
pub struct mirror_Operator(crate::wrapper::Operator);

#[derive(Clone)]
pub struct mirror_QuantileInterpolOptions(crate::wrapper::QuantileInterpolOptions);

#[derive(Clone)]
pub struct mirror_RowCount(crate::wrapper::RowCount);

#[derive(Clone)]
pub struct mirror_SortOptions(crate::wrapper::SortOptions);

#[derive(Clone)]
pub struct mirror_TimeUnit(crate::wrapper::TimeUnit);

#[derive(Clone)]
pub struct mirror_UniqueKeepStrategy(crate::wrapper::UniqueKeepStrategy);

#[derive(Clone)]
pub struct mirror_WindowMapping(crate::wrapper::WindowMapping);

#[derive(Clone)]
pub struct mirror_WindowType(crate::wrapper::WindowType);

// Section: static_checks

#[allow(clippy::unnecessary_literal_unwrap)]
const _: fn() = || {
    match None::<crate::wrapper::AggExpr>.unwrap() {
        crate::wrapper::AggExpr::Min {
            input,
            propagate_nans,
        } => {
            let _: Box<crate::wrapper::Expr> = input;
            let _: bool = propagate_nans;
        }
        crate::wrapper::AggExpr::Max {
            input,
            propagate_nans,
        } => {
            let _: Box<crate::wrapper::Expr> = input;
            let _: bool = propagate_nans;
        }
        crate::wrapper::AggExpr::Median(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::AggExpr::NUnique(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::AggExpr::First(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::AggExpr::Last(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::AggExpr::Mean(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::AggExpr::Count(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::AggExpr::Quantile {
            expr,
            quantile,
            interpol,
        } => {
            let _: Box<crate::wrapper::Expr> = expr;
            let _: Box<crate::wrapper::Expr> = quantile;
            let _: crate::wrapper::QuantileInterpolOptions = interpol;
        }
        crate::wrapper::AggExpr::Sum(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::AggExpr::AggGroups(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::AggExpr::Std(field0, field1) => {
            let _: Box<crate::wrapper::Expr> = field0;
            let _: u8 = field1;
        }
        crate::wrapper::AggExpr::Var(field0, field1) => {
            let _: Box<crate::wrapper::Expr> = field0;
            let _: u8 = field1;
        }
    }
    match None::<crate::wrapper::DataType>.unwrap() {
        crate::wrapper::DataType::Boolean => {}
        crate::wrapper::DataType::UInt8 => {}
        crate::wrapper::DataType::UInt16 => {}
        crate::wrapper::DataType::UInt32 => {}
        crate::wrapper::DataType::UInt64 => {}
        crate::wrapper::DataType::Int8 => {}
        crate::wrapper::DataType::Int16 => {}
        crate::wrapper::DataType::Int32 => {}
        crate::wrapper::DataType::Int64 => {}
        crate::wrapper::DataType::Float32 => {}
        crate::wrapper::DataType::Float64 => {}
        crate::wrapper::DataType::Utf8 => {}
        crate::wrapper::DataType::Binary => {}
        crate::wrapper::DataType::Date => {}
        crate::wrapper::DataType::Datetime(field0, field1) => {
            let _: crate::wrapper::TimeUnit = field0;
            let _: Option<String> = field1;
        }
        crate::wrapper::DataType::Duration(field0) => {
            let _: crate::wrapper::TimeUnit = field0;
        }
        crate::wrapper::DataType::Time => {}
        crate::wrapper::DataType::List(field0) => {
            let _: Box<crate::wrapper::DataType> = field0;
        }
        crate::wrapper::DataType::Null => {}
        crate::wrapper::DataType::Struct(field0) => {
            let _: Vec<crate::wrapper::Field> = field0;
        }
        crate::wrapper::DataType::Unknown => {}
    }
    match None::<crate::wrapper::Excluded>.unwrap() {
        crate::wrapper::Excluded::Name(field0) => {
            let _: String = field0;
        }
        crate::wrapper::Excluded::Dtype(field0) => {
            let _: crate::wrapper::DataType = field0;
        }
    }
    match None::<crate::wrapper::Expr>.unwrap() {
        crate::wrapper::Expr::Alias(field0, field1) => {
            let _: Box<crate::wrapper::Expr> = field0;
            let _: String = field1;
        }
        crate::wrapper::Expr::Column(field0) => {
            let _: String = field0;
        }
        crate::wrapper::Expr::Columns(field0) => {
            let _: Vec<String> = field0;
        }
        crate::wrapper::Expr::DtypeColumn(field0) => {
            let _: Vec<crate::wrapper::DataType> = field0;
        }
        crate::wrapper::Expr::Literal(field0) => {
            let _: crate::wrapper::LiteralValue = field0;
        }
        crate::wrapper::Expr::BinaryExpr { left, op, right } => {
            let _: Box<crate::wrapper::Expr> = left;
            let _: crate::wrapper::Operator = op;
            let _: Box<crate::wrapper::Expr> = right;
        }
        crate::wrapper::Expr::Cast {
            expr,
            data_type,
            strict,
        } => {
            let _: Box<crate::wrapper::Expr> = expr;
            let _: crate::wrapper::DataType = data_type;
            let _: bool = strict;
        }
        crate::wrapper::Expr::Sort { expr, options } => {
            let _: Box<crate::wrapper::Expr> = expr;
            let _: crate::wrapper::SortOptions = options;
        }
        crate::wrapper::Expr::Gather {
            expr,
            idx,
            returns_scalar,
        } => {
            let _: Box<crate::wrapper::Expr> = expr;
            let _: Box<crate::wrapper::Expr> = idx;
            let _: bool = returns_scalar;
        }
        crate::wrapper::Expr::SortBy {
            expr,
            by,
            descending,
        } => {
            let _: Box<crate::wrapper::Expr> = expr;
            let _: Vec<crate::wrapper::Expr> = by;
            let _: Vec<bool> = descending;
        }
        crate::wrapper::Expr::Agg(field0) => {
            let _: crate::wrapper::AggExpr = field0;
        }
        crate::wrapper::Expr::Ternary {
            predicate,
            truthy,
            falsy,
        } => {
            let _: Box<crate::wrapper::Expr> = predicate;
            let _: Box<crate::wrapper::Expr> = truthy;
            let _: Box<crate::wrapper::Expr> = falsy;
        }
        crate::wrapper::Expr::Explode(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::Expr::Filter { input, by } => {
            let _: Box<crate::wrapper::Expr> = input;
            let _: Box<crate::wrapper::Expr> = by;
        }
        crate::wrapper::Expr::Window {
            function,
            partition_by,
            options,
        } => {
            let _: Box<crate::wrapper::Expr> = function;
            let _: Vec<crate::wrapper::Expr> = partition_by;
            let _: crate::wrapper::WindowType = options;
        }
        crate::wrapper::Expr::Wildcard => {}
        crate::wrapper::Expr::Slice {
            input,
            offset,
            length,
        } => {
            let _: Box<crate::wrapper::Expr> = input;
            let _: Box<crate::wrapper::Expr> = offset;
            let _: Box<crate::wrapper::Expr> = length;
        }
        crate::wrapper::Expr::Exclude(field0, field1) => {
            let _: Box<crate::wrapper::Expr> = field0;
            let _: Vec<crate::wrapper::Excluded> = field1;
        }
        crate::wrapper::Expr::KeepName(field0) => {
            let _: Box<crate::wrapper::Expr> = field0;
        }
        crate::wrapper::Expr::Count => {}
        crate::wrapper::Expr::Nth(field0) => {
            let _: i64 = field0;
        }
    }
    {
        let Field = None::<crate::wrapper::Field>.unwrap();
        let _: String = Field.name;
        let _: crate::wrapper::DataType = Field.dtype;
    }
    match None::<crate::wrapper::LiteralValue>.unwrap() {
        crate::wrapper::LiteralValue::Null => {}
        crate::wrapper::LiteralValue::Boolean(field0) => {
            let _: bool = field0;
        }
        crate::wrapper::LiteralValue::Utf8(field0) => {
            let _: String = field0;
        }
        crate::wrapper::LiteralValue::Binary(field0) => {
            let _: Vec<u8> = field0;
        }
        crate::wrapper::LiteralValue::UInt8(field0) => {
            let _: u8 = field0;
        }
        crate::wrapper::LiteralValue::UInt16(field0) => {
            let _: u16 = field0;
        }
        crate::wrapper::LiteralValue::UInt32(field0) => {
            let _: u32 = field0;
        }
        crate::wrapper::LiteralValue::UInt64(field0) => {
            let _: u64 = field0;
        }
        crate::wrapper::LiteralValue::Int8(field0) => {
            let _: i8 = field0;
        }
        crate::wrapper::LiteralValue::Int16(field0) => {
            let _: i16 = field0;
        }
        crate::wrapper::LiteralValue::Int32(field0) => {
            let _: i32 = field0;
        }
        crate::wrapper::LiteralValue::Int64(field0) => {
            let _: i64 = field0;
        }
        crate::wrapper::LiteralValue::Float32(field0) => {
            let _: f32 = field0;
        }
        crate::wrapper::LiteralValue::Float64(field0) => {
            let _: f64 = field0;
        }
        crate::wrapper::LiteralValue::Range {
            low,
            high,
            data_type,
        } => {
            let _: i64 = low;
            let _: i64 = high;
            let _: crate::wrapper::DataType = data_type;
        }
        crate::wrapper::LiteralValue::DateTime(field0, field1, field2) => {
            let _: i64 = field0;
            let _: crate::wrapper::TimeUnit = field1;
            let _: Option<String> = field2;
        }
        crate::wrapper::LiteralValue::Duration(field0, field1) => {
            let _: i64 = field0;
            let _: crate::wrapper::TimeUnit = field1;
        }
        crate::wrapper::LiteralValue::Date(field0) => {
            let _: i32 = field0;
        }
        crate::wrapper::LiteralValue::Time(field0) => {
            let _: i64 = field0;
        }
    }
    match None::<crate::wrapper::NullValues>.unwrap() {
        crate::wrapper::NullValues::AllColumnsSingle(field0) => {
            let _: String = field0;
        }
        crate::wrapper::NullValues::AllColumns(field0) => {
            let _: Vec<String> = field0;
        }
        crate::wrapper::NullValues::Named(field0) => {
            let _: Vec<(String, String)> = field0;
        }
    }
    {
        let RowCount = None::<crate::wrapper::RowCount>.unwrap();
        let _: String = RowCount.name;
        let _: u32 = RowCount.offset;
    }
    {
        let SortOptions = None::<crate::wrapper::SortOptions>.unwrap();
        let _: bool = SortOptions.descending;
        let _: bool = SortOptions.nulls_last;
        let _: bool = SortOptions.multithreaded;
        let _: bool = SortOptions.maintain_order;
    }
    match None::<crate::wrapper::WindowType>.unwrap() {
        crate::wrapper::WindowType::Over(field0) => {
            let _: crate::wrapper::WindowMapping = field0;
        }
    }
};

// Section: dart2rust

impl CstDecode<chrono::DateTime<chrono::Local>> for i64 {
    fn cst_decode(self) -> chrono::DateTime<chrono::Local> {
        let flutter_rust_bridge::for_generated::Timestamp { s, ns } =
            flutter_rust_bridge::for_generated::decode_timestamp(self);
        chrono::DateTime::<chrono::Local>::from(
            chrono::DateTime::<chrono::Utc>::from_naive_utc_and_offset(
                chrono::NaiveDateTime::from_timestamp_opt(s, ns)
                    .expect("invalid or out-of-range datetime"),
                chrono::Utc,
            ),
        )
    }
}
impl CstDecode<chrono::NaiveDateTime> for i64 {
    fn cst_decode(self) -> chrono::NaiveDateTime {
        let flutter_rust_bridge::for_generated::Timestamp { s, ns } =
            flutter_rust_bridge::for_generated::decode_timestamp(self);
        chrono::NaiveDateTime::from_timestamp_opt(s, ns).expect("invalid or out-of-range datetime")
    }
}
impl CstDecode<chrono::DateTime<chrono::Utc>> for i64 {
    fn cst_decode(self) -> chrono::DateTime<chrono::Utc> {
        let flutter_rust_bridge::for_generated::Timestamp { s, ns } =
            flutter_rust_bridge::for_generated::decode_timestamp(self);
        chrono::DateTime::<chrono::Utc>::from_naive_utc_and_offset(
            chrono::NaiveDateTime::from_timestamp_opt(s, ns)
                .expect("invalid or out-of-range datetime"),
            chrono::Utc,
        )
    }
}
impl CstDecode<bool> for bool {
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::wrapper::CsvEncoding> for i32 {
    fn cst_decode(self) -> crate::wrapper::CsvEncoding {
        match self {
            0 => crate::wrapper::CsvEncoding::Utf8,
            1 => crate::wrapper::CsvEncoding::LossyUtf8,
            _ => unreachable!("Invalid variant for CsvEncoding: {}", self),
        }
    }
}
impl CstDecode<f32> for f32 {
    fn cst_decode(self) -> f32 {
        self
    }
}
impl CstDecode<f64> for f64 {
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i16> for i16 {
    fn cst_decode(self) -> i16 {
        self
    }
}
impl CstDecode<i32> for i32 {
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<i64> for i64 {
    fn cst_decode(self) -> i64 {
        self
    }
}
impl CstDecode<i8> for i8 {
    fn cst_decode(self) -> i8 {
        self
    }
}
impl CstDecode<crate::wrapper::JoinType> for i32 {
    fn cst_decode(self) -> crate::wrapper::JoinType {
        match self {
            0 => crate::wrapper::JoinType::Left,
            1 => crate::wrapper::JoinType::Inner,
            2 => crate::wrapper::JoinType::Outer,
            3 => crate::wrapper::JoinType::Cross,
            4 => crate::wrapper::JoinType::Semi,
            5 => crate::wrapper::JoinType::Anti,
            _ => unreachable!("Invalid variant for JoinType: {}", self),
        }
    }
}
impl CstDecode<crate::wrapper::Operator> for i32 {
    fn cst_decode(self) -> crate::wrapper::Operator {
        match self {
            0 => crate::wrapper::Operator::Eq,
            1 => crate::wrapper::Operator::EqValidity,
            2 => crate::wrapper::Operator::NotEq,
            3 => crate::wrapper::Operator::NotEqValidity,
            4 => crate::wrapper::Operator::Lt,
            5 => crate::wrapper::Operator::LtEq,
            6 => crate::wrapper::Operator::Gt,
            7 => crate::wrapper::Operator::GtEq,
            8 => crate::wrapper::Operator::Plus,
            9 => crate::wrapper::Operator::Minus,
            10 => crate::wrapper::Operator::Multiply,
            11 => crate::wrapper::Operator::Divide,
            12 => crate::wrapper::Operator::TrueDivide,
            13 => crate::wrapper::Operator::FloorDivide,
            14 => crate::wrapper::Operator::Modulus,
            15 => crate::wrapper::Operator::And,
            16 => crate::wrapper::Operator::Or,
            17 => crate::wrapper::Operator::Xor,
            _ => unreachable!("Invalid variant for Operator: {}", self),
        }
    }
}
impl CstDecode<crate::wrapper::QuantileInterpolOptions> for i32 {
    fn cst_decode(self) -> crate::wrapper::QuantileInterpolOptions {
        match self {
            0 => crate::wrapper::QuantileInterpolOptions::Nearest,
            1 => crate::wrapper::QuantileInterpolOptions::Lower,
            2 => crate::wrapper::QuantileInterpolOptions::Higher,
            3 => crate::wrapper::QuantileInterpolOptions::Midpoint,
            4 => crate::wrapper::QuantileInterpolOptions::Linear,
            _ => unreachable!("Invalid variant for QuantileInterpolOptions: {}", self),
        }
    }
}
impl CstDecode<crate::wrapper::TimeUnit> for i32 {
    fn cst_decode(self) -> crate::wrapper::TimeUnit {
        match self {
            0 => crate::wrapper::TimeUnit::Nanoseconds,
            1 => crate::wrapper::TimeUnit::Microseconds,
            2 => crate::wrapper::TimeUnit::Milliseconds,
            _ => unreachable!("Invalid variant for TimeUnit: {}", self),
        }
    }
}
impl CstDecode<u16> for u16 {
    fn cst_decode(self) -> u16 {
        self
    }
}
impl CstDecode<u32> for u32 {
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<crate::wrapper::UniqueKeepStrategy> for i32 {
    fn cst_decode(self) -> crate::wrapper::UniqueKeepStrategy {
        match self {
            0 => crate::wrapper::UniqueKeepStrategy::First,
            1 => crate::wrapper::UniqueKeepStrategy::Last,
            _ => unreachable!("Invalid variant for UniqueKeepStrategy: {}", self),
        }
    }
}
impl CstDecode<usize> for usize {
    fn cst_decode(self) -> usize {
        self
    }
}
impl CstDecode<crate::wrapper::WindowMapping> for i32 {
    fn cst_decode(self) -> crate::wrapper::WindowMapping {
        match self {
            0 => crate::wrapper::WindowMapping::GroupsToRows,
            1 => crate::wrapper::WindowMapping::Explode,
            2 => crate::wrapper::WindowMapping::Join,
            _ => unreachable!("Invalid variant for WindowMapping: {}", self),
        }
    }
}
impl SseDecode for anyhow::Error {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        unimplemented!("not yet supported in serialized mode, feel free to create an issue");
    }
}

impl SseDecode for chrono::Duration {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        unimplemented!("not yet supported in serialized mode, feel free to create an issue");
    }
}

impl SseDecode for chrono::DateTime<chrono::Local> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        unimplemented!("not yet supported in serialized mode, feel free to create an issue");
    }
}

impl SseDecode for chrono::NaiveDateTime {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        unimplemented!("not yet supported in serialized mode, feel free to create an issue");
    }
}

impl SseDecode for chrono::DateTime<chrono::Utc> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        unimplemented!("not yet supported in serialized mode, feel free to create an issue");
    }
}

impl SseDecode
    for flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<Vec<crate::wrapper::Series>>>>
{
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_rust_opaque(inner) };
    }
}

impl SseDecode
    for flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<crate::wrapper::Schema>>>
{
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_rust_opaque(inner) };
    }
}

impl SseDecode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<Vec<crate::wrapper::Series>>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_rust_opaque(inner) };
    }
}

impl SseDecode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_rust_opaque(inner) };
    }
}

impl SseDecode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_rust_opaque(inner) };
    }
}

impl SseDecode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyGroupBy>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_rust_opaque(inner) };
    }
}

impl SseDecode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Schema>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_rust_opaque(inner) };
    }
}

impl SseDecode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return unsafe { flutter_rust_bridge::for_generated::sse_decode_rust_opaque(inner) };
    }
}

impl SseDecode for String {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::wrapper::AggExpr {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_input = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_propagateNans = <bool>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Min {
                    input: var_input,
                    propagate_nans: var_propagateNans,
                };
            }
            1 => {
                let mut var_input = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_propagateNans = <bool>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Max {
                    input: var_input,
                    propagate_nans: var_propagateNans,
                };
            }
            2 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Median(var_field0);
            }
            3 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::NUnique(var_field0);
            }
            4 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::First(var_field0);
            }
            5 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Last(var_field0);
            }
            6 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Mean(var_field0);
            }
            7 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Count(var_field0);
            }
            8 => {
                let mut var_expr = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_quantile = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_interpol =
                    <crate::wrapper::QuantileInterpolOptions>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Quantile {
                    expr: var_expr,
                    quantile: var_quantile,
                    interpol: var_interpol,
                };
            }
            9 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Sum(var_field0);
            }
            10 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::AggGroups(var_field0);
            }
            11 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_field1 = <u8>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Std(var_field0, var_field1);
            }
            12 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_field1 = <u8>::sse_decode(deserializer);
                return crate::wrapper::AggExpr::Var(var_field0, var_field1);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for bool {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for Box<crate::wrapper::DataType> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return Box::new(<crate::wrapper::DataType>::sse_decode(deserializer));
    }
}

impl SseDecode for Box<crate::wrapper::Expr> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return Box::new(<crate::wrapper::Expr>::sse_decode(deserializer));
    }
}

impl SseDecode for crate::wrapper::CsvEncoding {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::wrapper::CsvEncoding::Utf8,
            1 => crate::wrapper::CsvEncoding::LossyUtf8,
            _ => unreachable!("Invalid variant for CsvEncoding: {}", inner),
        };
    }
}

impl SseDecode for flutter_rust_bridge::for_generated::DartAbi {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        unimplemented!("");
    }
}

impl SseDecode for crate::wrapper::DataType {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::wrapper::DataType::Boolean;
            }
            1 => {
                return crate::wrapper::DataType::UInt8;
            }
            2 => {
                return crate::wrapper::DataType::UInt16;
            }
            3 => {
                return crate::wrapper::DataType::UInt32;
            }
            4 => {
                return crate::wrapper::DataType::UInt64;
            }
            5 => {
                return crate::wrapper::DataType::Int8;
            }
            6 => {
                return crate::wrapper::DataType::Int16;
            }
            7 => {
                return crate::wrapper::DataType::Int32;
            }
            8 => {
                return crate::wrapper::DataType::Int64;
            }
            9 => {
                return crate::wrapper::DataType::Float32;
            }
            10 => {
                return crate::wrapper::DataType::Float64;
            }
            11 => {
                return crate::wrapper::DataType::Utf8;
            }
            12 => {
                return crate::wrapper::DataType::Binary;
            }
            13 => {
                return crate::wrapper::DataType::Date;
            }
            14 => {
                let mut var_field0 = <crate::wrapper::TimeUnit>::sse_decode(deserializer);
                let mut var_field1 = <Option<String>>::sse_decode(deserializer);
                return crate::wrapper::DataType::Datetime(var_field0, var_field1);
            }
            15 => {
                let mut var_field0 = <crate::wrapper::TimeUnit>::sse_decode(deserializer);
                return crate::wrapper::DataType::Duration(var_field0);
            }
            16 => {
                return crate::wrapper::DataType::Time;
            }
            17 => {
                let mut var_field0 = <Box<crate::wrapper::DataType>>::sse_decode(deserializer);
                return crate::wrapper::DataType::List(var_field0);
            }
            18 => {
                return crate::wrapper::DataType::Null;
            }
            19 => {
                let mut var_field0 = <Vec<crate::wrapper::Field>>::sse_decode(deserializer);
                return crate::wrapper::DataType::Struct(var_field0);
            }
            20 => {
                return crate::wrapper::DataType::Unknown;
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::wrapper::Excluded {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::wrapper::Excluded::Name(var_field0);
            }
            1 => {
                let mut var_field0 = <crate::wrapper::DataType>::sse_decode(deserializer);
                return crate::wrapper::Excluded::Dtype(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::wrapper::Expr {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_field1 = <String>::sse_decode(deserializer);
                return crate::wrapper::Expr::Alias(var_field0, var_field1);
            }
            1 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::wrapper::Expr::Column(var_field0);
            }
            2 => {
                let mut var_field0 = <Vec<String>>::sse_decode(deserializer);
                return crate::wrapper::Expr::Columns(var_field0);
            }
            3 => {
                let mut var_field0 = <Vec<crate::wrapper::DataType>>::sse_decode(deserializer);
                return crate::wrapper::Expr::DtypeColumn(var_field0);
            }
            4 => {
                let mut var_field0 = <crate::wrapper::LiteralValue>::sse_decode(deserializer);
                return crate::wrapper::Expr::Literal(var_field0);
            }
            5 => {
                let mut var_left = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_op = <crate::wrapper::Operator>::sse_decode(deserializer);
                let mut var_right = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::Expr::BinaryExpr {
                    left: var_left,
                    op: var_op,
                    right: var_right,
                };
            }
            6 => {
                let mut var_expr = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_dataType = <crate::wrapper::DataType>::sse_decode(deserializer);
                let mut var_strict = <bool>::sse_decode(deserializer);
                return crate::wrapper::Expr::Cast {
                    expr: var_expr,
                    data_type: var_dataType,
                    strict: var_strict,
                };
            }
            7 => {
                let mut var_expr = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_options = <crate::wrapper::SortOptions>::sse_decode(deserializer);
                return crate::wrapper::Expr::Sort {
                    expr: var_expr,
                    options: var_options,
                };
            }
            8 => {
                let mut var_expr = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_idx = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_returnsScalar = <bool>::sse_decode(deserializer);
                return crate::wrapper::Expr::Gather {
                    expr: var_expr,
                    idx: var_idx,
                    returns_scalar: var_returnsScalar,
                };
            }
            9 => {
                let mut var_expr = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_by = <Vec<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_descending = <Vec<bool>>::sse_decode(deserializer);
                return crate::wrapper::Expr::SortBy {
                    expr: var_expr,
                    by: var_by,
                    descending: var_descending,
                };
            }
            10 => {
                let mut var_field0 = <crate::wrapper::AggExpr>::sse_decode(deserializer);
                return crate::wrapper::Expr::Agg(var_field0);
            }
            11 => {
                let mut var_predicate = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_truthy = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_falsy = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::Expr::Ternary {
                    predicate: var_predicate,
                    truthy: var_truthy,
                    falsy: var_falsy,
                };
            }
            12 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::Expr::Explode(var_field0);
            }
            13 => {
                let mut var_input = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_by = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::Expr::Filter {
                    input: var_input,
                    by: var_by,
                };
            }
            14 => {
                let mut var_function = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_partitionBy = <Vec<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_options = <crate::wrapper::WindowType>::sse_decode(deserializer);
                return crate::wrapper::Expr::Window {
                    function: var_function,
                    partition_by: var_partitionBy,
                    options: var_options,
                };
            }
            15 => {
                return crate::wrapper::Expr::Wildcard;
            }
            16 => {
                let mut var_input = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_offset = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_length = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::Expr::Slice {
                    input: var_input,
                    offset: var_offset,
                    length: var_length,
                };
            }
            17 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                let mut var_field1 = <Vec<crate::wrapper::Excluded>>::sse_decode(deserializer);
                return crate::wrapper::Expr::Exclude(var_field0, var_field1);
            }
            18 => {
                let mut var_field0 = <Box<crate::wrapper::Expr>>::sse_decode(deserializer);
                return crate::wrapper::Expr::KeepName(var_field0);
            }
            19 => {
                return crate::wrapper::Expr::Count;
            }
            20 => {
                let mut var_field0 = <i64>::sse_decode(deserializer);
                return crate::wrapper::Expr::Nth(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for f32 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::wrapper::Field {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_dtype = <crate::wrapper::DataType>::sse_decode(deserializer);
        return crate::wrapper::Field {
            name: var_name,
            dtype: var_dtype,
        };
    }
}

impl SseDecode for i16 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i32 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i8 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i8().unwrap()
    }
}

impl SseDecode for crate::wrapper::JoinType {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::wrapper::JoinType::Left,
            1 => crate::wrapper::JoinType::Inner,
            2 => crate::wrapper::JoinType::Outer,
            3 => crate::wrapper::JoinType::Cross,
            4 => crate::wrapper::JoinType::Semi,
            5 => crate::wrapper::JoinType::Anti,
            _ => unreachable!("Invalid variant for JoinType: {}", inner),
        };
    }
}

impl SseDecode for Vec<String> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<bool> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<bool>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<flutter_rust_bridge::for_generated::DartAbi> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<flutter_rust_bridge::for_generated::DartAbi>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::wrapper::DataType> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::wrapper::DataType>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::wrapper::Excluded> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::wrapper::Excluded>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::wrapper::Expr> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::wrapper::Expr>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::wrapper::Field> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::wrapper::Field>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Option<String>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Option<String>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Option<chrono::Duration>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Option<chrono::Duration>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Option<chrono::DateTime<chrono::Local>>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Option<chrono::DateTime<chrono::Local>>>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Option<chrono::NaiveDateTime>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Option<chrono::NaiveDateTime>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Option<chrono::DateTime<chrono::Utc>>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Option<chrono::DateTime<chrono::Utc>>>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Option<f64>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Option<f64>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Option<i32>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Option<i32>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<Option<i64>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<Option<i64>>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<f64> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<f64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<i64> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<i64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u32> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, String)> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, String)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::wrapper::LiteralValue {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::wrapper::LiteralValue::Null;
            }
            1 => {
                let mut var_field0 = <bool>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Boolean(var_field0);
            }
            2 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Utf8(var_field0);
            }
            3 => {
                let mut var_field0 = <Vec<u8>>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Binary(var_field0);
            }
            4 => {
                let mut var_field0 = <u8>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::UInt8(var_field0);
            }
            5 => {
                let mut var_field0 = <u16>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::UInt16(var_field0);
            }
            6 => {
                let mut var_field0 = <u32>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::UInt32(var_field0);
            }
            7 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::UInt64(var_field0);
            }
            8 => {
                let mut var_field0 = <i8>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Int8(var_field0);
            }
            9 => {
                let mut var_field0 = <i16>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Int16(var_field0);
            }
            10 => {
                let mut var_field0 = <i32>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Int32(var_field0);
            }
            11 => {
                let mut var_field0 = <i64>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Int64(var_field0);
            }
            12 => {
                let mut var_field0 = <f32>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Float32(var_field0);
            }
            13 => {
                let mut var_field0 = <f64>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Float64(var_field0);
            }
            14 => {
                let mut var_low = <i64>::sse_decode(deserializer);
                let mut var_high = <i64>::sse_decode(deserializer);
                let mut var_dataType = <crate::wrapper::DataType>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Range {
                    low: var_low,
                    high: var_high,
                    data_type: var_dataType,
                };
            }
            15 => {
                let mut var_field0 = <i64>::sse_decode(deserializer);
                let mut var_field1 = <crate::wrapper::TimeUnit>::sse_decode(deserializer);
                let mut var_field2 = <Option<String>>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::DateTime(var_field0, var_field1, var_field2);
            }
            16 => {
                let mut var_field0 = <i64>::sse_decode(deserializer);
                let mut var_field1 = <crate::wrapper::TimeUnit>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Duration(var_field0, var_field1);
            }
            17 => {
                let mut var_field0 = <i32>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Date(var_field0);
            }
            18 => {
                let mut var_field0 = <i64>::sse_decode(deserializer);
                return crate::wrapper::LiteralValue::Time(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::wrapper::NullValues {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::wrapper::NullValues::AllColumnsSingle(var_field0);
            }
            1 => {
                let mut var_field0 = <Vec<String>>::sse_decode(deserializer);
                return crate::wrapper::NullValues::AllColumns(var_field0);
            }
            2 => {
                let mut var_field0 = <Vec<(String, String)>>::sse_decode(deserializer);
                return crate::wrapper::NullValues::Named(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::wrapper::Operator {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::wrapper::Operator::Eq,
            1 => crate::wrapper::Operator::EqValidity,
            2 => crate::wrapper::Operator::NotEq,
            3 => crate::wrapper::Operator::NotEqValidity,
            4 => crate::wrapper::Operator::Lt,
            5 => crate::wrapper::Operator::LtEq,
            6 => crate::wrapper::Operator::Gt,
            7 => crate::wrapper::Operator::GtEq,
            8 => crate::wrapper::Operator::Plus,
            9 => crate::wrapper::Operator::Minus,
            10 => crate::wrapper::Operator::Multiply,
            11 => crate::wrapper::Operator::Divide,
            12 => crate::wrapper::Operator::TrueDivide,
            13 => crate::wrapper::Operator::FloorDivide,
            14 => crate::wrapper::Operator::Modulus,
            15 => crate::wrapper::Operator::And,
            16 => crate::wrapper::Operator::Or,
            17 => crate::wrapper::Operator::Xor,
            _ => unreachable!("Invalid variant for Operator: {}", inner),
        };
    }
}

impl SseDecode for Option<String> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<chrono::Duration> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<chrono::Duration>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<chrono::DateTime<chrono::Local>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<chrono::DateTime<chrono::Local>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<chrono::NaiveDateTime> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<chrono::NaiveDateTime>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<chrono::DateTime<chrono::Utc>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<chrono::DateTime<chrono::Utc>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::wrapper::CsvEncoding> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::wrapper::CsvEncoding>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i64> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::wrapper::NullValues> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::wrapper::NullValues>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::wrapper::RowCount> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::wrapper::RowCount>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u64> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<usize> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<usize>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<String>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<String>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<bool>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<bool>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::wrapper::DataType>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::wrapper::DataType>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::wrapper::Expr>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<crate::wrapper::Expr>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<Option<String>>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<Option<String>>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<Option<chrono::Duration>>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<Option<chrono::Duration>>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<Option<f64>>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<Option<f64>>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<Option<i32>>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<Option<i32>>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<Option<i64>>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<Option<i64>>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<f64>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<f64>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<u32>> {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<u32>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::wrapper::QuantileInterpolOptions {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::wrapper::QuantileInterpolOptions::Nearest,
            1 => crate::wrapper::QuantileInterpolOptions::Lower,
            2 => crate::wrapper::QuantileInterpolOptions::Higher,
            3 => crate::wrapper::QuantileInterpolOptions::Midpoint,
            4 => crate::wrapper::QuantileInterpolOptions::Linear,
            _ => unreachable!("Invalid variant for QuantileInterpolOptions: {}", inner),
        };
    }
}

impl SseDecode for (String, String) {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <String>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::wrapper::RowCount {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_offset = <u32>::sse_decode(deserializer);
        return crate::wrapper::RowCount {
            name: var_name,
            offset: var_offset,
        };
    }
}

impl SseDecode for crate::wrapper::Shape {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_height = <usize>::sse_decode(deserializer);
        let mut var_width = <usize>::sse_decode(deserializer);
        return crate::wrapper::Shape {
            height: var_height,
            width: var_width,
        };
    }
}

impl SseDecode for crate::wrapper::SortOptions {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_descending = <bool>::sse_decode(deserializer);
        let mut var_nullsLast = <bool>::sse_decode(deserializer);
        let mut var_multithreaded = <bool>::sse_decode(deserializer);
        let mut var_maintainOrder = <bool>::sse_decode(deserializer);
        return crate::wrapper::SortOptions {
            descending: var_descending,
            nulls_last: var_nullsLast,
            multithreaded: var_multithreaded,
            maintain_order: var_maintainOrder,
        };
    }
}

impl SseDecode for crate::wrapper::TimeUnit {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::wrapper::TimeUnit::Nanoseconds,
            1 => crate::wrapper::TimeUnit::Microseconds,
            2 => crate::wrapper::TimeUnit::Milliseconds,
            _ => unreachable!("Invalid variant for TimeUnit: {}", inner),
        };
    }
}

impl SseDecode for u16 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for crate::wrapper::UniqueKeepStrategy {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::wrapper::UniqueKeepStrategy::First,
            1 => crate::wrapper::UniqueKeepStrategy::Last,
            _ => unreachable!("Invalid variant for UniqueKeepStrategy: {}", inner),
        };
    }
}

impl SseDecode for () {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::wrapper::WindowMapping {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::wrapper::WindowMapping::GroupsToRows,
            1 => crate::wrapper::WindowMapping::Explode,
            2 => crate::wrapper::WindowMapping::Join,
            _ => unreachable!("Invalid variant for WindowMapping: {}", inner),
        };
    }
}

impl SseDecode for crate::wrapper::WindowType {
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <crate::wrapper::WindowMapping>::sse_decode(deserializer);
                return crate::wrapper::WindowType::Over(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

// Section: rust2dart

impl flutter_rust_bridge::IntoDart for mirror_AggExpr {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::AggExpr::Min {
                input,
                propagate_nans,
            } => {
                vec![
                    0.into_dart(),
                    input.into_into_dart().into_dart(),
                    propagate_nans.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::AggExpr::Max {
                input,
                propagate_nans,
            } => {
                vec![
                    1.into_dart(),
                    input.into_into_dart().into_dart(),
                    propagate_nans.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::AggExpr::Median(field0) => {
                vec![2.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::AggExpr::NUnique(field0) => {
                vec![3.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::AggExpr::First(field0) => {
                vec![4.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::AggExpr::Last(field0) => {
                vec![5.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::AggExpr::Mean(field0) => {
                vec![6.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::AggExpr::Count(field0) => {
                vec![7.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::AggExpr::Quantile {
                expr,
                quantile,
                interpol,
            } => {
                vec![
                    8.into_dart(),
                    expr.into_into_dart().into_dart(),
                    quantile.into_into_dart().into_dart(),
                    interpol.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::AggExpr::Sum(field0) => {
                vec![9.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::AggExpr::AggGroups(field0) => {
                vec![10.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::AggExpr::Std(field0, field1) => {
                vec![
                    11.into_dart(),
                    field0.into_into_dart().into_dart(),
                    field1.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::AggExpr::Var(field0, field1) => {
                vec![
                    12.into_dart(),
                    field0.into_into_dart().into_dart(),
                    field1.into_into_dart().into_dart(),
                ]
            }
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_AggExpr {}
impl flutter_rust_bridge::IntoIntoDart<mirror_AggExpr> for crate::wrapper::AggExpr {
    fn into_into_dart(self) -> mirror_AggExpr {
        mirror_AggExpr(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_CsvEncoding {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::CsvEncoding::Utf8 => 0,
            crate::wrapper::CsvEncoding::LossyUtf8 => 1,
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_CsvEncoding {}
impl flutter_rust_bridge::IntoIntoDart<mirror_CsvEncoding> for crate::wrapper::CsvEncoding {
    fn into_into_dart(self) -> mirror_CsvEncoding {
        mirror_CsvEncoding(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_DataType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::DataType::Boolean => {
                vec![0.into_dart()]
            }
            crate::wrapper::DataType::UInt8 => {
                vec![1.into_dart()]
            }
            crate::wrapper::DataType::UInt16 => {
                vec![2.into_dart()]
            }
            crate::wrapper::DataType::UInt32 => {
                vec![3.into_dart()]
            }
            crate::wrapper::DataType::UInt64 => {
                vec![4.into_dart()]
            }
            crate::wrapper::DataType::Int8 => {
                vec![5.into_dart()]
            }
            crate::wrapper::DataType::Int16 => {
                vec![6.into_dart()]
            }
            crate::wrapper::DataType::Int32 => {
                vec![7.into_dart()]
            }
            crate::wrapper::DataType::Int64 => {
                vec![8.into_dart()]
            }
            crate::wrapper::DataType::Float32 => {
                vec![9.into_dart()]
            }
            crate::wrapper::DataType::Float64 => {
                vec![10.into_dart()]
            }
            crate::wrapper::DataType::Utf8 => {
                vec![11.into_dart()]
            }
            crate::wrapper::DataType::Binary => {
                vec![12.into_dart()]
            }
            crate::wrapper::DataType::Date => {
                vec![13.into_dart()]
            }
            crate::wrapper::DataType::Datetime(field0, field1) => {
                vec![
                    14.into_dart(),
                    field0.into_into_dart().into_dart(),
                    field1.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::DataType::Duration(field0) => {
                vec![15.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::DataType::Time => {
                vec![16.into_dart()]
            }
            crate::wrapper::DataType::List(field0) => {
                vec![17.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::DataType::Null => {
                vec![18.into_dart()]
            }
            crate::wrapper::DataType::Struct(field0) => {
                vec![19.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::DataType::Unknown => {
                vec![20.into_dart()]
            }
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_DataType {}
impl flutter_rust_bridge::IntoIntoDart<mirror_DataType> for crate::wrapper::DataType {
    fn into_into_dart(self) -> mirror_DataType {
        mirror_DataType(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_Excluded {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::Excluded::Name(field0) => {
                vec![0.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::Excluded::Dtype(field0) => {
                vec![1.into_dart(), field0.into_into_dart().into_dart()]
            }
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_Excluded {}
impl flutter_rust_bridge::IntoIntoDart<mirror_Excluded> for crate::wrapper::Excluded {
    fn into_into_dart(self) -> mirror_Excluded {
        mirror_Excluded(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_Expr {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::Expr::Alias(field0, field1) => {
                vec![
                    0.into_dart(),
                    field0.into_into_dart().into_dart(),
                    field1.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::Column(field0) => {
                vec![1.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::Expr::Columns(field0) => {
                vec![2.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::Expr::DtypeColumn(field0) => {
                vec![3.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::Expr::Literal(field0) => {
                vec![4.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::Expr::BinaryExpr { left, op, right } => {
                vec![
                    5.into_dart(),
                    left.into_into_dart().into_dart(),
                    op.into_into_dart().into_dart(),
                    right.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::Cast {
                expr,
                data_type,
                strict,
            } => {
                vec![
                    6.into_dart(),
                    expr.into_into_dart().into_dart(),
                    data_type.into_into_dart().into_dart(),
                    strict.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::Sort { expr, options } => {
                vec![
                    7.into_dart(),
                    expr.into_into_dart().into_dart(),
                    options.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::Gather {
                expr,
                idx,
                returns_scalar,
            } => {
                vec![
                    8.into_dart(),
                    expr.into_into_dart().into_dart(),
                    idx.into_into_dart().into_dart(),
                    returns_scalar.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::SortBy {
                expr,
                by,
                descending,
            } => {
                vec![
                    9.into_dart(),
                    expr.into_into_dart().into_dart(),
                    by.into_into_dart().into_dart(),
                    descending.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::Agg(field0) => {
                vec![10.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::Expr::Ternary {
                predicate,
                truthy,
                falsy,
            } => {
                vec![
                    11.into_dart(),
                    predicate.into_into_dart().into_dart(),
                    truthy.into_into_dart().into_dart(),
                    falsy.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::Explode(field0) => {
                vec![12.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::Expr::Filter { input, by } => {
                vec![
                    13.into_dart(),
                    input.into_into_dart().into_dart(),
                    by.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::Window {
                function,
                partition_by,
                options,
            } => {
                vec![
                    14.into_dart(),
                    function.into_into_dart().into_dart(),
                    partition_by.into_into_dart().into_dart(),
                    options.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::Wildcard => {
                vec![15.into_dart()]
            }
            crate::wrapper::Expr::Slice {
                input,
                offset,
                length,
            } => {
                vec![
                    16.into_dart(),
                    input.into_into_dart().into_dart(),
                    offset.into_into_dart().into_dart(),
                    length.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::Exclude(field0, field1) => {
                vec![
                    17.into_dart(),
                    field0.into_into_dart().into_dart(),
                    field1.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::Expr::KeepName(field0) => {
                vec![18.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::Expr::Count => {
                vec![19.into_dart()]
            }
            crate::wrapper::Expr::Nth(field0) => {
                vec![20.into_dart(), field0.into_into_dart().into_dart()]
            }
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_Expr {}
impl flutter_rust_bridge::IntoIntoDart<mirror_Expr> for crate::wrapper::Expr {
    fn into_into_dart(self) -> mirror_Expr {
        mirror_Expr(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_Field {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        vec![
            self.0.name.into_into_dart().into_dart(),
            self.0.dtype.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_Field {}
impl flutter_rust_bridge::IntoIntoDart<mirror_Field> for crate::wrapper::Field {
    fn into_into_dart(self) -> mirror_Field {
        mirror_Field(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_JoinType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::JoinType::Left => 0,
            crate::wrapper::JoinType::Inner => 1,
            crate::wrapper::JoinType::Outer => 2,
            crate::wrapper::JoinType::Cross => 3,
            crate::wrapper::JoinType::Semi => 4,
            crate::wrapper::JoinType::Anti => 5,
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_JoinType {}
impl flutter_rust_bridge::IntoIntoDart<mirror_JoinType> for crate::wrapper::JoinType {
    fn into_into_dart(self) -> mirror_JoinType {
        mirror_JoinType(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_LiteralValue {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::LiteralValue::Null => {
                vec![0.into_dart()]
            }
            crate::wrapper::LiteralValue::Boolean(field0) => {
                vec![1.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Utf8(field0) => {
                vec![2.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Binary(field0) => {
                vec![3.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::UInt8(field0) => {
                vec![4.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::UInt16(field0) => {
                vec![5.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::UInt32(field0) => {
                vec![6.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::UInt64(field0) => {
                vec![7.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Int8(field0) => {
                vec![8.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Int16(field0) => {
                vec![9.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Int32(field0) => {
                vec![10.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Int64(field0) => {
                vec![11.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Float32(field0) => {
                vec![12.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Float64(field0) => {
                vec![13.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Range {
                low,
                high,
                data_type,
            } => {
                vec![
                    14.into_dart(),
                    low.into_into_dart().into_dart(),
                    high.into_into_dart().into_dart(),
                    data_type.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::LiteralValue::DateTime(field0, field1, field2) => {
                vec![
                    15.into_dart(),
                    field0.into_into_dart().into_dart(),
                    field1.into_into_dart().into_dart(),
                    field2.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::LiteralValue::Duration(field0, field1) => {
                vec![
                    16.into_dart(),
                    field0.into_into_dart().into_dart(),
                    field1.into_into_dart().into_dart(),
                ]
            }
            crate::wrapper::LiteralValue::Date(field0) => {
                vec![17.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::LiteralValue::Time(field0) => {
                vec![18.into_dart(), field0.into_into_dart().into_dart()]
            }
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_LiteralValue {}
impl flutter_rust_bridge::IntoIntoDart<mirror_LiteralValue> for crate::wrapper::LiteralValue {
    fn into_into_dart(self) -> mirror_LiteralValue {
        mirror_LiteralValue(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_NullValues {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::NullValues::AllColumnsSingle(field0) => {
                vec![0.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::NullValues::AllColumns(field0) => {
                vec![1.into_dart(), field0.into_into_dart().into_dart()]
            }
            crate::wrapper::NullValues::Named(field0) => {
                vec![2.into_dart(), field0.into_into_dart().into_dart()]
            }
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_NullValues {}
impl flutter_rust_bridge::IntoIntoDart<mirror_NullValues> for crate::wrapper::NullValues {
    fn into_into_dart(self) -> mirror_NullValues {
        mirror_NullValues(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_Operator {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::Operator::Eq => 0,
            crate::wrapper::Operator::EqValidity => 1,
            crate::wrapper::Operator::NotEq => 2,
            crate::wrapper::Operator::NotEqValidity => 3,
            crate::wrapper::Operator::Lt => 4,
            crate::wrapper::Operator::LtEq => 5,
            crate::wrapper::Operator::Gt => 6,
            crate::wrapper::Operator::GtEq => 7,
            crate::wrapper::Operator::Plus => 8,
            crate::wrapper::Operator::Minus => 9,
            crate::wrapper::Operator::Multiply => 10,
            crate::wrapper::Operator::Divide => 11,
            crate::wrapper::Operator::TrueDivide => 12,
            crate::wrapper::Operator::FloorDivide => 13,
            crate::wrapper::Operator::Modulus => 14,
            crate::wrapper::Operator::And => 15,
            crate::wrapper::Operator::Or => 16,
            crate::wrapper::Operator::Xor => 17,
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_Operator {}
impl flutter_rust_bridge::IntoIntoDart<mirror_Operator> for crate::wrapper::Operator {
    fn into_into_dart(self) -> mirror_Operator {
        mirror_Operator(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_QuantileInterpolOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::QuantileInterpolOptions::Nearest => 0,
            crate::wrapper::QuantileInterpolOptions::Lower => 1,
            crate::wrapper::QuantileInterpolOptions::Higher => 2,
            crate::wrapper::QuantileInterpolOptions::Midpoint => 3,
            crate::wrapper::QuantileInterpolOptions::Linear => 4,
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for mirror_QuantileInterpolOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<mirror_QuantileInterpolOptions>
    for crate::wrapper::QuantileInterpolOptions
{
    fn into_into_dart(self) -> mirror_QuantileInterpolOptions {
        mirror_QuantileInterpolOptions(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_RowCount {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        vec![
            self.0.name.into_into_dart().into_dart(),
            self.0.offset.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_RowCount {}
impl flutter_rust_bridge::IntoIntoDart<mirror_RowCount> for crate::wrapper::RowCount {
    fn into_into_dart(self) -> mirror_RowCount {
        mirror_RowCount(self)
    }
}
impl flutter_rust_bridge::IntoDart for crate::wrapper::Shape {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        vec![
            self.height.into_into_dart().into_dart(),
            self.width.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::wrapper::Shape {}
impl flutter_rust_bridge::IntoIntoDart<crate::wrapper::Shape> for crate::wrapper::Shape {
    fn into_into_dart(self) -> crate::wrapper::Shape {
        self
    }
}
impl flutter_rust_bridge::IntoDart for mirror_SortOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        vec![
            self.0.descending.into_into_dart().into_dart(),
            self.0.nulls_last.into_into_dart().into_dart(),
            self.0.multithreaded.into_into_dart().into_dart(),
            self.0.maintain_order.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_SortOptions {}
impl flutter_rust_bridge::IntoIntoDart<mirror_SortOptions> for crate::wrapper::SortOptions {
    fn into_into_dart(self) -> mirror_SortOptions {
        mirror_SortOptions(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_TimeUnit {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::TimeUnit::Nanoseconds => 0,
            crate::wrapper::TimeUnit::Microseconds => 1,
            crate::wrapper::TimeUnit::Milliseconds => 2,
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_TimeUnit {}
impl flutter_rust_bridge::IntoIntoDart<mirror_TimeUnit> for crate::wrapper::TimeUnit {
    fn into_into_dart(self) -> mirror_TimeUnit {
        mirror_TimeUnit(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_UniqueKeepStrategy {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::UniqueKeepStrategy::First => 0,
            crate::wrapper::UniqueKeepStrategy::Last => 1,
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_UniqueKeepStrategy {}
impl flutter_rust_bridge::IntoIntoDart<mirror_UniqueKeepStrategy>
    for crate::wrapper::UniqueKeepStrategy
{
    fn into_into_dart(self) -> mirror_UniqueKeepStrategy {
        mirror_UniqueKeepStrategy(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_WindowMapping {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::WindowMapping::GroupsToRows => 0,
            crate::wrapper::WindowMapping::Explode => 1,
            crate::wrapper::WindowMapping::Join => 2,
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_WindowMapping {}
impl flutter_rust_bridge::IntoIntoDart<mirror_WindowMapping> for crate::wrapper::WindowMapping {
    fn into_into_dart(self) -> mirror_WindowMapping {
        mirror_WindowMapping(self)
    }
}
impl flutter_rust_bridge::IntoDart for mirror_WindowType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::wrapper::WindowType::Over(field0) => {
                vec![0.into_dart(), field0.into_into_dart().into_dart()]
            }
        }
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for mirror_WindowType {}
impl flutter_rust_bridge::IntoIntoDart<mirror_WindowType> for crate::wrapper::WindowType {
    fn into_into_dart(self) -> mirror_WindowType {
        mirror_WindowType(self)
    }
}

impl SseEncode for anyhow::Error {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for chrono::Duration {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("not yet supported in serialized mode, feel free to create an issue");
    }
}

impl SseEncode for chrono::DateTime<chrono::Local> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("not yet supported in serialized mode, feel free to create an issue");
    }
}

impl SseEncode for chrono::NaiveDateTime {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("not yet supported in serialized mode, feel free to create an issue");
    }
}

impl SseEncode for chrono::DateTime<chrono::Utc> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("not yet supported in serialized mode, feel free to create an issue");
    }
}

impl SseEncode
    for flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<Vec<crate::wrapper::Series>>>>
{
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for flutter_rust_bridge::RustOpaque<std::sync::RwLock<Option<crate::wrapper::Schema>>>
{
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<Vec<crate::wrapper::Series>>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::DataFrame>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyFrame>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::LazyGroupBy>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Schema>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for flutter_rust_bridge::RustOpaque<std::sync::RwLock<crate::wrapper::Series>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::wrapper::AggExpr {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::wrapper::AggExpr::Min {
                input,
                propagate_nans,
            } => {
                <i32>::sse_encode(0, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(input, serializer);
                <bool>::sse_encode(propagate_nans, serializer);
            }
            crate::wrapper::AggExpr::Max {
                input,
                propagate_nans,
            } => {
                <i32>::sse_encode(1, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(input, serializer);
                <bool>::sse_encode(propagate_nans, serializer);
            }
            crate::wrapper::AggExpr::Median(field0) => {
                <i32>::sse_encode(2, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::AggExpr::NUnique(field0) => {
                <i32>::sse_encode(3, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::AggExpr::First(field0) => {
                <i32>::sse_encode(4, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::AggExpr::Last(field0) => {
                <i32>::sse_encode(5, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::AggExpr::Mean(field0) => {
                <i32>::sse_encode(6, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::AggExpr::Count(field0) => {
                <i32>::sse_encode(7, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::AggExpr::Quantile {
                expr,
                quantile,
                interpol,
            } => {
                <i32>::sse_encode(8, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(expr, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(quantile, serializer);
                <crate::wrapper::QuantileInterpolOptions>::sse_encode(interpol, serializer);
            }
            crate::wrapper::AggExpr::Sum(field0) => {
                <i32>::sse_encode(9, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::AggExpr::AggGroups(field0) => {
                <i32>::sse_encode(10, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::AggExpr::Std(field0, field1) => {
                <i32>::sse_encode(11, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
                <u8>::sse_encode(field1, serializer);
            }
            crate::wrapper::AggExpr::Var(field0, field1) => {
                <i32>::sse_encode(12, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
                <u8>::sse_encode(field1, serializer);
            }
        }
    }
}

impl SseEncode for bool {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for Box<crate::wrapper::DataType> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::wrapper::DataType>::sse_encode(*self, serializer);
    }
}

impl SseEncode for Box<crate::wrapper::Expr> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::wrapper::Expr>::sse_encode(*self, serializer);
    }
}

impl SseEncode for crate::wrapper::CsvEncoding {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self as _, serializer);
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::DartAbi {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        unimplemented!("");
    }
}

impl SseEncode for crate::wrapper::DataType {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::wrapper::DataType::Boolean => {
                <i32>::sse_encode(0, serializer);
            }
            crate::wrapper::DataType::UInt8 => {
                <i32>::sse_encode(1, serializer);
            }
            crate::wrapper::DataType::UInt16 => {
                <i32>::sse_encode(2, serializer);
            }
            crate::wrapper::DataType::UInt32 => {
                <i32>::sse_encode(3, serializer);
            }
            crate::wrapper::DataType::UInt64 => {
                <i32>::sse_encode(4, serializer);
            }
            crate::wrapper::DataType::Int8 => {
                <i32>::sse_encode(5, serializer);
            }
            crate::wrapper::DataType::Int16 => {
                <i32>::sse_encode(6, serializer);
            }
            crate::wrapper::DataType::Int32 => {
                <i32>::sse_encode(7, serializer);
            }
            crate::wrapper::DataType::Int64 => {
                <i32>::sse_encode(8, serializer);
            }
            crate::wrapper::DataType::Float32 => {
                <i32>::sse_encode(9, serializer);
            }
            crate::wrapper::DataType::Float64 => {
                <i32>::sse_encode(10, serializer);
            }
            crate::wrapper::DataType::Utf8 => {
                <i32>::sse_encode(11, serializer);
            }
            crate::wrapper::DataType::Binary => {
                <i32>::sse_encode(12, serializer);
            }
            crate::wrapper::DataType::Date => {
                <i32>::sse_encode(13, serializer);
            }
            crate::wrapper::DataType::Datetime(field0, field1) => {
                <i32>::sse_encode(14, serializer);
                <crate::wrapper::TimeUnit>::sse_encode(field0, serializer);
                <Option<String>>::sse_encode(field1, serializer);
            }
            crate::wrapper::DataType::Duration(field0) => {
                <i32>::sse_encode(15, serializer);
                <crate::wrapper::TimeUnit>::sse_encode(field0, serializer);
            }
            crate::wrapper::DataType::Time => {
                <i32>::sse_encode(16, serializer);
            }
            crate::wrapper::DataType::List(field0) => {
                <i32>::sse_encode(17, serializer);
                <Box<crate::wrapper::DataType>>::sse_encode(field0, serializer);
            }
            crate::wrapper::DataType::Null => {
                <i32>::sse_encode(18, serializer);
            }
            crate::wrapper::DataType::Struct(field0) => {
                <i32>::sse_encode(19, serializer);
                <Vec<crate::wrapper::Field>>::sse_encode(field0, serializer);
            }
            crate::wrapper::DataType::Unknown => {
                <i32>::sse_encode(20, serializer);
            }
        }
    }
}

impl SseEncode for crate::wrapper::Excluded {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::wrapper::Excluded::Name(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::wrapper::Excluded::Dtype(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::wrapper::DataType>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for crate::wrapper::Expr {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::wrapper::Expr::Alias(field0, field1) => {
                <i32>::sse_encode(0, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
                <String>::sse_encode(field1, serializer);
            }
            crate::wrapper::Expr::Column(field0) => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::wrapper::Expr::Columns(field0) => {
                <i32>::sse_encode(2, serializer);
                <Vec<String>>::sse_encode(field0, serializer);
            }
            crate::wrapper::Expr::DtypeColumn(field0) => {
                <i32>::sse_encode(3, serializer);
                <Vec<crate::wrapper::DataType>>::sse_encode(field0, serializer);
            }
            crate::wrapper::Expr::Literal(field0) => {
                <i32>::sse_encode(4, serializer);
                <crate::wrapper::LiteralValue>::sse_encode(field0, serializer);
            }
            crate::wrapper::Expr::BinaryExpr { left, op, right } => {
                <i32>::sse_encode(5, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(left, serializer);
                <crate::wrapper::Operator>::sse_encode(op, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(right, serializer);
            }
            crate::wrapper::Expr::Cast {
                expr,
                data_type,
                strict,
            } => {
                <i32>::sse_encode(6, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(expr, serializer);
                <crate::wrapper::DataType>::sse_encode(data_type, serializer);
                <bool>::sse_encode(strict, serializer);
            }
            crate::wrapper::Expr::Sort { expr, options } => {
                <i32>::sse_encode(7, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(expr, serializer);
                <crate::wrapper::SortOptions>::sse_encode(options, serializer);
            }
            crate::wrapper::Expr::Gather {
                expr,
                idx,
                returns_scalar,
            } => {
                <i32>::sse_encode(8, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(expr, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(idx, serializer);
                <bool>::sse_encode(returns_scalar, serializer);
            }
            crate::wrapper::Expr::SortBy {
                expr,
                by,
                descending,
            } => {
                <i32>::sse_encode(9, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(expr, serializer);
                <Vec<crate::wrapper::Expr>>::sse_encode(by, serializer);
                <Vec<bool>>::sse_encode(descending, serializer);
            }
            crate::wrapper::Expr::Agg(field0) => {
                <i32>::sse_encode(10, serializer);
                <crate::wrapper::AggExpr>::sse_encode(field0, serializer);
            }
            crate::wrapper::Expr::Ternary {
                predicate,
                truthy,
                falsy,
            } => {
                <i32>::sse_encode(11, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(predicate, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(truthy, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(falsy, serializer);
            }
            crate::wrapper::Expr::Explode(field0) => {
                <i32>::sse_encode(12, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::Expr::Filter { input, by } => {
                <i32>::sse_encode(13, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(input, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(by, serializer);
            }
            crate::wrapper::Expr::Window {
                function,
                partition_by,
                options,
            } => {
                <i32>::sse_encode(14, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(function, serializer);
                <Vec<crate::wrapper::Expr>>::sse_encode(partition_by, serializer);
                <crate::wrapper::WindowType>::sse_encode(options, serializer);
            }
            crate::wrapper::Expr::Wildcard => {
                <i32>::sse_encode(15, serializer);
            }
            crate::wrapper::Expr::Slice {
                input,
                offset,
                length,
            } => {
                <i32>::sse_encode(16, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(input, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(offset, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(length, serializer);
            }
            crate::wrapper::Expr::Exclude(field0, field1) => {
                <i32>::sse_encode(17, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
                <Vec<crate::wrapper::Excluded>>::sse_encode(field1, serializer);
            }
            crate::wrapper::Expr::KeepName(field0) => {
                <i32>::sse_encode(18, serializer);
                <Box<crate::wrapper::Expr>>::sse_encode(field0, serializer);
            }
            crate::wrapper::Expr::Count => {
                <i32>::sse_encode(19, serializer);
            }
            crate::wrapper::Expr::Nth(field0) => {
                <i32>::sse_encode(20, serializer);
                <i64>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for f32 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::wrapper::Field {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <crate::wrapper::DataType>::sse_encode(self.dtype, serializer);
    }
}

impl SseEncode for i16 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i32 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i8 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i8(self).unwrap();
    }
}

impl SseEncode for crate::wrapper::JoinType {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self as _, serializer);
    }
}

impl SseEncode for Vec<String> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<bool> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <bool>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<flutter_rust_bridge::for_generated::DartAbi> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <flutter_rust_bridge::for_generated::DartAbi>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::wrapper::DataType> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::wrapper::DataType>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::wrapper::Excluded> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::wrapper::Excluded>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::wrapper::Expr> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::wrapper::Expr>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::wrapper::Field> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::wrapper::Field>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Option<String>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Option<String>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Option<chrono::Duration>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Option<chrono::Duration>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Option<chrono::DateTime<chrono::Local>>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Option<chrono::DateTime<chrono::Local>>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Option<chrono::NaiveDateTime>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Option<chrono::NaiveDateTime>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Option<chrono::DateTime<chrono::Utc>>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Option<chrono::DateTime<chrono::Utc>>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Option<f64>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Option<f64>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Option<i32>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Option<i32>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<Option<i64>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <Option<i64>>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<f64> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <f64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<i64> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <i64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u32> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, String)> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, String)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::wrapper::LiteralValue {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::wrapper::LiteralValue::Null => {
                <i32>::sse_encode(0, serializer);
            }
            crate::wrapper::LiteralValue::Boolean(field0) => {
                <i32>::sse_encode(1, serializer);
                <bool>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Utf8(field0) => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Binary(field0) => {
                <i32>::sse_encode(3, serializer);
                <Vec<u8>>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::UInt8(field0) => {
                <i32>::sse_encode(4, serializer);
                <u8>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::UInt16(field0) => {
                <i32>::sse_encode(5, serializer);
                <u16>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::UInt32(field0) => {
                <i32>::sse_encode(6, serializer);
                <u32>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::UInt64(field0) => {
                <i32>::sse_encode(7, serializer);
                <u64>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Int8(field0) => {
                <i32>::sse_encode(8, serializer);
                <i8>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Int16(field0) => {
                <i32>::sse_encode(9, serializer);
                <i16>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Int32(field0) => {
                <i32>::sse_encode(10, serializer);
                <i32>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Int64(field0) => {
                <i32>::sse_encode(11, serializer);
                <i64>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Float32(field0) => {
                <i32>::sse_encode(12, serializer);
                <f32>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Float64(field0) => {
                <i32>::sse_encode(13, serializer);
                <f64>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Range {
                low,
                high,
                data_type,
            } => {
                <i32>::sse_encode(14, serializer);
                <i64>::sse_encode(low, serializer);
                <i64>::sse_encode(high, serializer);
                <crate::wrapper::DataType>::sse_encode(data_type, serializer);
            }
            crate::wrapper::LiteralValue::DateTime(field0, field1, field2) => {
                <i32>::sse_encode(15, serializer);
                <i64>::sse_encode(field0, serializer);
                <crate::wrapper::TimeUnit>::sse_encode(field1, serializer);
                <Option<String>>::sse_encode(field2, serializer);
            }
            crate::wrapper::LiteralValue::Duration(field0, field1) => {
                <i32>::sse_encode(16, serializer);
                <i64>::sse_encode(field0, serializer);
                <crate::wrapper::TimeUnit>::sse_encode(field1, serializer);
            }
            crate::wrapper::LiteralValue::Date(field0) => {
                <i32>::sse_encode(17, serializer);
                <i32>::sse_encode(field0, serializer);
            }
            crate::wrapper::LiteralValue::Time(field0) => {
                <i32>::sse_encode(18, serializer);
                <i64>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for crate::wrapper::NullValues {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::wrapper::NullValues::AllColumnsSingle(field0) => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(field0, serializer);
            }
            crate::wrapper::NullValues::AllColumns(field0) => {
                <i32>::sse_encode(1, serializer);
                <Vec<String>>::sse_encode(field0, serializer);
            }
            crate::wrapper::NullValues::Named(field0) => {
                <i32>::sse_encode(2, serializer);
                <Vec<(String, String)>>::sse_encode(field0, serializer);
            }
        }
    }
}

impl SseEncode for crate::wrapper::Operator {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self as _, serializer);
    }
}

impl SseEncode for Option<String> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<chrono::Duration> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <chrono::Duration>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<chrono::DateTime<chrono::Local>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <chrono::DateTime<chrono::Local>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<chrono::NaiveDateTime> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <chrono::NaiveDateTime>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<chrono::DateTime<chrono::Utc>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <chrono::DateTime<chrono::Utc>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::wrapper::CsvEncoding> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::wrapper::CsvEncoding>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i64> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::wrapper::NullValues> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::wrapper::NullValues>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::wrapper::RowCount> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::wrapper::RowCount>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u32> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u64> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<usize> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <usize>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<String>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<String>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<bool>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<bool>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::wrapper::DataType>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::wrapper::DataType>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::wrapper::Expr>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::wrapper::Expr>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<Option<String>>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<Option<String>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<Option<chrono::Duration>>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<Option<chrono::Duration>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<Option<f64>>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<Option<f64>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<Option<i32>>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<Option<i32>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<Option<i64>>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<Option<i64>>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<f64>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<f64>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<u32>> {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<u32>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::wrapper::QuantileInterpolOptions {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self as _, serializer);
    }
}

impl SseEncode for (String, String) {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <String>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::wrapper::RowCount {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <u32>::sse_encode(self.offset, serializer);
    }
}

impl SseEncode for crate::wrapper::Shape {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.height, serializer);
        <usize>::sse_encode(self.width, serializer);
    }
}

impl SseEncode for crate::wrapper::SortOptions {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.descending, serializer);
        <bool>::sse_encode(self.nulls_last, serializer);
        <bool>::sse_encode(self.multithreaded, serializer);
        <bool>::sse_encode(self.maintain_order, serializer);
    }
}

impl SseEncode for crate::wrapper::TimeUnit {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self as _, serializer);
    }
}

impl SseEncode for u16 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for crate::wrapper::UniqueKeepStrategy {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self as _, serializer);
    }
}

impl SseEncode for () {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::wrapper::WindowMapping {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self as _, serializer);
    }
}

impl SseEncode for crate::wrapper::WindowType {
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::wrapper::WindowType::Over(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::wrapper::WindowMapping>::sse_encode(field0, serializer);
            }
        }
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "bridge.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;
