// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.59.0.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member

import 'dart:convert';
import 'dart:async';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

import 'dart:convert';
import 'dart:async';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'wrapper.io.dart' if (dart.library.html) 'wrapper.web.dart';

import 'package:meta/meta.dart';

part 'wrapper.freezed.dart';

abstract class PolarsWrapper {
  /// Reads a .csv file into a [DataFrame].
  Future<DataFrame> readCsv(
      {required String path,
      bool? hasHeader,
      int? delimiter,
      int? skipRows,
      int? skipRowsAfterHeader,
      int? chunkSize,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReadCsvConstMeta;

  /// Iterate through this dataframe's rows.
  Stream<List<dynamic>> iterMethodDataFrame(
      {required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIterMethodDataFrameConstMeta;

  /// Select a single column by name.
  Series columnMethodDataFrame(
      {required DataFrame that, required String column, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kColumnMethodDataFrameConstMeta;

  /// Select multiple columns by name.
  List<Series> columnsMethodDataFrame(
      {required DataFrame that, required List<String> columns, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kColumnsMethodDataFrameConstMeta;

  /// Dump the contents of this entire dataframe.
  Future<String> dumpMethodDataFrame({required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDumpMethodDataFrameConstMeta;

  /// Returns the amount of bytes occupied by this series.
  int estimatedSizeMethodDataFrame({required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEstimatedSizeMethodDataFrameConstMeta;

  /// Add a new column at index 0 denoting the row number.
  Future<DataFrame> withRowCountMethodDataFrame(
      {required DataFrame that,
      required String name,
      int? offset,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kWithRowCountMethodDataFrameConstMeta;

  /// Get the names of this dataframe's columns.
  List<String> getColumnNamesMethodDataFrame(
      {required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetColumnNamesMethodDataFrameConstMeta;

  /// Get all columns of this dataframe.
  Future<List<Series>> getColumnsMethodDataFrame(
      {required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetColumnsMethodDataFrameConstMeta;

  /// Returns the width of this dataframe, aka the number of columns.
  int widthMethodDataFrame({required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kWidthMethodDataFrameConstMeta;

  /// Returns the height of this dataframe, aka the number of rows.
  int heightMethodDataFrame({required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHeightMethodDataFrameConstMeta;

  /// Returns whether this dataframe has no rows.
  bool isEmptyMethodDataFrame({required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsEmptyMethodDataFrameConstMeta;

  /// Sample [n] datapoints from this dataframe.
  Future<DataFrame> sampleMethodDataFrame(
      {required DataFrame that,
      required int n,
      bool withReplacement = false,
      bool shuffle = false,
      int? seed,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSampleMethodDataFrameConstMeta;

  /// Makes a new dataframe with the specified columns from this dataframe.
  DataFrame selectMethodDataFrame(
      {required DataFrame that, required List<String> columns, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSelectMethodDataFrameConstMeta;

  /// Returns the first few rows of this dataframe.
  DataFrame headMethodDataFrame(
      {required DataFrame that, int? length, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHeadMethodDataFrameConstMeta;

  /// Returns the last few rows of this dataframe.
  DataFrame tailMethodDataFrame(
      {required DataFrame that, int? length, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTailMethodDataFrameConstMeta;

  /// Output statistics about this dataframe.
  Future<DataFrame> describeMethodDataFrame(
      {required DataFrame that, Float64List? percentiles, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDescribeMethodDataFrameConstMeta;

  /// Drops a column by name, producing a new dataframe.
  DataFrame dropMethodDataFrame(
      {required DataFrame that, required String column, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDropMethodDataFrameConstMeta;

  /// Drops a column in-place and returns it.
  Series dropInPlaceMethodDataFrame(
      {required DataFrame that, required String column, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDropInPlaceMethodDataFrameConstMeta;

  /// Returns a dataframe with columns from this dataframe in reverse order.
  DataFrame reverseMethodDataFrame({required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReverseMethodDataFrameConstMeta;

  /// Returns the height and width of this dataframe.
  Shape shapeMethodDataFrame({required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kShapeMethodDataFrameConstMeta;

  /// Aggregate the columns to their maximum values.
  Future<DataFrame> maxMethodDataFrame({required DataFrame that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMaxMethodDataFrameConstMeta;

  /// Get a row of data from this dataframe.
  ///
  /// This method may be slow due to conversions between different data formats.
  Future<List<dynamic>> getRowMethodDataFrame(
      {required DataFrame that, required int index, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetRowMethodDataFrameConstMeta;

  /// Returns a [LazyFrame] to which operations can be applied lazily.
  /// As opposed to [LazyFrame], [DataFrame] by default applies its operations eagerly.
  ///
  /// This operation will fail if this dataframe is currently being shared, unless
  /// `allowCopy` is true in which case this dataframe will be copied.
  LazyFrame lazyMethodDataFrame(
      {required DataFrame that,
      bool allowCopy = false,
      bool? projectionPushdown,
      bool? predicatePushdown,
      bool? typeCoercion,
      bool? simplifyExpressions,
      bool? slicePushdown,
      bool? streaming,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLazyMethodDataFrameConstMeta;

  LazyFrame withColumnMethodLazyFrame(
      {required LazyFrame that, required Expr expr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kWithColumnMethodLazyFrameConstMeta;

  /// Create a new series of strings.
  /// Create a new series of 32-bit wide integers.
  Series ofI32StaticMethodSeries(
      {required String name, Int32List? values, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOfI32StaticMethodSeriesConstMeta;

  /// Create a new series of 64-bit wide integers.
  Series ofI64StaticMethodSeries(
      {required String name, Int64List? values, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOfI64StaticMethodSeriesConstMeta;

  /// Create a new series of [Duration]s.
  /// Create a new series of doubles.
  Series ofF64StaticMethodSeries(
      {required String name, Float64List? values, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kOfF64StaticMethodSeriesConstMeta;

  /// Adds the contents of [other] onto this series.
  ///
  /// Throws if [other] is self.
  Future<void> appendMethodSeries(
      {required Series that, required Series other, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAppendMethodSeriesConstMeta;

  /// If this series is a UTF-8 series, returns its Dart representation.
  Future<List<String?>> asStringsMethodSeries(
      {required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsStringsMethodSeriesConstMeta;

  /// If this series is a 32-bit wide integer series, returns its Dart representation.
  Future<List<int?>> asI32MethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsI32MethodSeriesConstMeta;

  /// If this series is a double series, returns its Dart representation.
  Future<List<double?>> asF64MethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsF64MethodSeriesConstMeta;

  /// If this series contains [Duration]s, returns its Dart representation.
  Future<List<Duration?>> asDurationsMethodSeries(
      {required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsDurationsMethodSeriesConstMeta;

  /// If this series contains [DateTime]s, returns its Dart representation.
  ///
  /// Datetimes are parsed as-is, without any timezone correction.
  Future<List<DateTime?>> asNaiveDatetimeMethodSeries(
      {required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsNaiveDatetimeMethodSeriesConstMeta;

  /// If this series contains [DateTime]s, returns its Dart representation.
  ///
  /// If a timezone is defined by this series, the datetimes will be converted to UTC.
  /// Otherwise, the datetimes are assumed to be in UTC.
  Future<List<DateTime?>> asUtcDatetimeMethodSeries(
      {required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsUtcDatetimeMethodSeriesConstMeta;

  /// If this series contains [DateTime]s, returns its Dart representation.
  ///
  /// If a timezone is defined by this series, the datetimes will be converted to the local timezone.
  /// Otherwise, the datetimes are assumed to be in the local timezone.
  Future<List<DateTime?>> asLocalDatetimeMethodSeries(
      {required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAsLocalDatetimeMethodSeriesConstMeta;

  /// Returns a new series with each value's absolute value.
  Future<Series> absMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAbsMethodSeriesConstMeta;

  /// Returns a new sorted series.
  Future<Series> sortMethodSeries(
      {required Series that, bool reverse = false, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSortMethodSeriesConstMeta;

  /// Returns a new shuffled series.
  Future<Series> shuffleMethodSeries(
      {required Series that, int? seed, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kShuffleMethodSeriesConstMeta;

  /// Sums all non-null rows in this series to produce a result.
  ///
  /// Returns null if the series only contains null values.
  Future<double?> sumMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSumMethodSeriesConstMeta;

  /// Returns the sum of this series' values as a single-element series.
  Future<Series> sumAsSeriesMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSumAsSeriesMethodSeriesConstMeta;

  /// Returns the minimum value of this series' values.
  ///
  /// Returns null if one of the values are also null.
  Future<double?> minMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMinMethodSeriesConstMeta;

  /// Returns the maximum value of this series' values.
  ///
  /// Returns null if one of the values are also null.
  Future<double?> maxMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMaxMethodSeriesConstMeta;

  /// Expands a series of lists into rows of values, or strings into rows of characters.
  Future<Series> explodeMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kExplodeMethodSeriesConstMeta;

  /// TODO: docs
  Future<Series> explodeByOffsetsMethodSeries(
      {required Series that, required Int64List offsets, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kExplodeByOffsetsMethodSeriesConstMeta;

  /// Calculates the cumulative max at each element.
  Future<Series> cummaxMethodSeries(
      {required Series that, bool reverse = false, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCummaxMethodSeriesConstMeta;

  /// Calculates the cumulative min at each element.
  Future<Series> cumminMethodSeries(
      {required Series that, bool reverse = false, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCumminMethodSeriesConstMeta;

  /// Calculates the cumulative product at each element.
  Future<Series> cumprodMethodSeries(
      {required Series that, bool reverse = false, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCumprodMethodSeriesConstMeta;

  /// Calculates the cumulative sum at each element.
  Future<Series> cumsumMethodSeries(
      {required Series that, bool reverse = false, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCumsumMethodSeriesConstMeta;

  /// Calculates the product of each element in the series and returns it in a single-element series.
  Future<Series> productMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kProductMethodSeriesConstMeta;

  /// Get the value at [index] as a string.
  String? getStringMethodSeries(
      {required Series that, required int index, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetStringMethodSeriesConstMeta;

  /// Get the value at [index] as a double.
  double? getMethodSeries(
      {required Series that, required int index, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetMethodSeriesConstMeta;

  /// Get the first few values of this series.
  Series headMethodSeries({required Series that, int? length, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kHeadMethodSeriesConstMeta;

  /// Get the last few values of this series.
  Series tailMethodSeries({required Series that, int? length, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTailMethodSeriesConstMeta;

  /// Calculates the mean (average) of this series.
  Future<double?> meanMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMeanMethodSeriesConstMeta;

  /// Calculates the [median](https://en.wikipedia.org/wiki/Median) of this series.
  Future<double?> medianMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMedianMethodSeriesConstMeta;

  /// Calculates and wraps this series' mean as a single-element series.
  Future<Series> meanAsSeriesMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMeanAsSeriesMethodSeriesConstMeta;

  /// Calculates and wraps this series' median as a single-element series.
  Future<Series> medianAsSeriesMethodSeries(
      {required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMedianAsSeriesMethodSeriesConstMeta;

  /// Returns the amount of bytes occupied by this series.
  int estimatedSizeMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEstimatedSizeMethodSeriesConstMeta;

  /// Returns a new series with elements from this series added to [other]'s element-wise.
  Series addToMethodSeries(
      {required Series that, required Series other, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddToMethodSeriesConstMeta;

  /// Returns a new series with elements from this series subtracted from [other]'s element-wise.
  Series subtractMethodSeries(
      {required Series that, required Series other, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSubtractMethodSeriesConstMeta;

  /// Returns a new series with elements from this series multiplied with [other]'s element-wise.
  Series multiplyMethodSeries(
      {required Series that, required Series other, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kMultiplyMethodSeriesConstMeta;

  /// Returns a new series with elements from this series divided by [other]'s element-wise.
  Series divideMethodSeries(
      {required Series that, required Series other, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDivideMethodSeriesConstMeta;

  /// Returns a new series with the [remainder](https://en.wikipedia.org/wiki/Remainder)
  /// between this series' and [other]'s elements.
  Series remainderMethodSeries(
      {required Series that, required Series other, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRemainderMethodSeriesConstMeta;

  /// Returns whether this is a series of booleans.
  bool isBoolMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsBoolMethodSeriesConstMeta;

  /// Returns whether this is a series of UTF-8 strings.
  bool isUtf8MethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsUtf8MethodSeriesConstMeta;

  /// Returns whether this is a series of numeric values.
  bool isNumericMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsNumericMethodSeriesConstMeta;

  /// Returns whether this is a series of [DateTime] or [Duration]s.
  bool isTemporalMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsTemporalMethodSeriesConstMeta;

  /// Dump the contents of this entire series.
  Future<String> dumpMethodSeries({required Series that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDumpMethodSeriesConstMeta;

  /// Rename this series to [name] in-place.
  void renameMethodSeries(
      {required Series that, required String name, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kRenameMethodSeriesConstMeta;

  /// Returns the unique values of this series.
  ///
  /// If `stable` is true, extra work is done to maintain the original order of elements.
  Future<Series> uniqueMethodSeries(
      {required Series that, bool stable = false, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kUniqueMethodSeriesConstMeta;

  /// Returns whether this series is identical to [other].
  ///
  /// if `ignoreNull` is true, null values are considered to be equal.
  Future<bool> equalMethodSeries(
      {required Series that,
      required Series other,
      bool ignoreNull = false,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEqualMethodSeriesConstMeta;

  /// Creates a new series with the specified dimensions.
  Future<Series> reshapeMethodSeries(
      {required Series that, required Int64List dims, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kReshapeMethodSeriesConstMeta;

  /// Calculates the standard deviation of this series with the specified degree of freedom.
  Future<Series> stdAsSeriesMethodSeries(
      {required Series that, required int ddof, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStdAsSeriesMethodSeriesConstMeta;

  DropFnType get dropOpaqueRwLockPDataFrame;
  ShareFnType get shareOpaqueRwLockPDataFrame;
  OpaqueTypeFinalizer get RwLockPDataFrameFinalizer;

  DropFnType get dropOpaqueRwLockPLazyFrame;
  ShareFnType get shareOpaqueRwLockPLazyFrame;
  OpaqueTypeFinalizer get RwLockPLazyFrameFinalizer;

  DropFnType get dropOpaqueRwLockPSeries;
  ShareFnType get shareOpaqueRwLockPSeries;
  OpaqueTypeFinalizer get RwLockPSeriesFinalizer;
}

@sealed
class RwLockPDataFrame extends FrbOpaque {
  final PolarsWrapper bridge;
  RwLockPDataFrame.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueRwLockPDataFrame;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueRwLockPDataFrame;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.RwLockPDataFrameFinalizer;
}

@sealed
class RwLockPLazyFrame extends FrbOpaque {
  final PolarsWrapper bridge;
  RwLockPLazyFrame.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueRwLockPLazyFrame;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueRwLockPLazyFrame;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.RwLockPLazyFrameFinalizer;
}

@sealed
class RwLockPSeries extends FrbOpaque {
  final PolarsWrapper bridge;
  RwLockPSeries.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueRwLockPSeries;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueRwLockPSeries;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.RwLockPSeriesFinalizer;
}

@freezed
class AggExpr with _$AggExpr {
  const factory AggExpr.min({
    required Expr input,
    required bool propagateNans,
  }) = AggExpr_Min;
  const factory AggExpr.max({
    required Expr input,
    required bool propagateNans,
  }) = AggExpr_Max;
  const factory AggExpr.median(
    Expr field0,
  ) = AggExpr_Median;
  const factory AggExpr.nUnique(
    Expr field0,
  ) = AggExpr_NUnique;
  const factory AggExpr.first(
    Expr field0,
  ) = AggExpr_First;
  const factory AggExpr.last(
    Expr field0,
  ) = AggExpr_Last;
  const factory AggExpr.mean(
    Expr field0,
  ) = AggExpr_Mean;
  const factory AggExpr.list(
    Expr field0,
  ) = AggExpr_List;
  const factory AggExpr.count(
    Expr field0,
  ) = AggExpr_Count;
  const factory AggExpr.sum(
    Expr field0,
  ) = AggExpr_Sum;
  const factory AggExpr.aggGroups(
    Expr field0,
  ) = AggExpr_AggGroups;
  const factory AggExpr.std(
    Expr field0,
    int field1,
  ) = AggExpr_Std;
}

/// Represents a table with each column as a [Series].
class DataFrame {
  final PolarsWrapper bridge;

  /// @nodoc
  final RwLockPDataFrame field0;

  const DataFrame({
    required this.bridge,
    required this.field0,
  });

  /// Iterate through this dataframe's rows.
  Stream<List<dynamic>> iter({dynamic hint}) => bridge.iterMethodDataFrame(
        that: this,
      );

  /// Select a single column by name.
  Series column({required String column, dynamic hint}) =>
      bridge.columnMethodDataFrame(
        that: this,
        column: column,
      );

  /// Select multiple columns by name.
  List<Series> columns({required List<String> columns, dynamic hint}) =>
      bridge.columnsMethodDataFrame(
        that: this,
        columns: columns,
      );

  /// Dump the contents of this entire dataframe.
  Future<String> dump({dynamic hint}) => bridge.dumpMethodDataFrame(
        that: this,
      );

  /// Returns the amount of bytes occupied by this series.
  int estimatedSize({dynamic hint}) => bridge.estimatedSizeMethodDataFrame(
        that: this,
      );

  /// Add a new column at index 0 denoting the row number.
  Future<DataFrame> withRowCount(
          {required String name, int? offset, dynamic hint}) =>
      bridge.withRowCountMethodDataFrame(
        that: this,
        name: name,
        offset: offset,
      );

  /// Get the names of this dataframe's columns.
  List<String> getColumnNames({dynamic hint}) =>
      bridge.getColumnNamesMethodDataFrame(
        that: this,
      );

  /// Get all columns of this dataframe.
  Future<List<Series>> getColumns({dynamic hint}) =>
      bridge.getColumnsMethodDataFrame(
        that: this,
      );

  /// Returns the width of this dataframe, aka the number of columns.
  int width({dynamic hint}) => bridge.widthMethodDataFrame(
        that: this,
      );

  /// Returns the height of this dataframe, aka the number of rows.
  int height({dynamic hint}) => bridge.heightMethodDataFrame(
        that: this,
      );

  /// Returns whether this dataframe has no rows.
  bool isEmpty({dynamic hint}) => bridge.isEmptyMethodDataFrame(
        that: this,
      );

  /// Sample [n] datapoints from this dataframe.
  Future<DataFrame> sample(
          {required int n,
          bool withReplacement = false,
          bool shuffle = false,
          int? seed,
          dynamic hint}) =>
      bridge.sampleMethodDataFrame(
        that: this,
        n: n,
        withReplacement: withReplacement,
        shuffle: shuffle,
        seed: seed,
      );

  /// Makes a new dataframe with the specified columns from this dataframe.
  DataFrame select({required List<String> columns, dynamic hint}) =>
      bridge.selectMethodDataFrame(
        that: this,
        columns: columns,
      );

  /// Returns the first few rows of this dataframe.
  DataFrame head({int? length, dynamic hint}) => bridge.headMethodDataFrame(
        that: this,
        length: length,
      );

  /// Returns the last few rows of this dataframe.
  DataFrame tail({int? length, dynamic hint}) => bridge.tailMethodDataFrame(
        that: this,
        length: length,
      );

  /// Output statistics about this dataframe.
  Future<DataFrame> describe({Float64List? percentiles, dynamic hint}) =>
      bridge.describeMethodDataFrame(
        that: this,
        percentiles: percentiles,
      );

  /// Drops a column by name, producing a new dataframe.
  DataFrame drop({required String column, dynamic hint}) =>
      bridge.dropMethodDataFrame(
        that: this,
        column: column,
      );

  /// Drops a column in-place and returns it.
  Series dropInPlace({required String column, dynamic hint}) =>
      bridge.dropInPlaceMethodDataFrame(
        that: this,
        column: column,
      );

  /// Returns a dataframe with columns from this dataframe in reverse order.
  DataFrame reverse({dynamic hint}) => bridge.reverseMethodDataFrame(
        that: this,
      );

  /// Returns the height and width of this dataframe.
  Shape shape({dynamic hint}) => bridge.shapeMethodDataFrame(
        that: this,
      );

  /// Aggregate the columns to their maximum values.
  Future<DataFrame> max({dynamic hint}) => bridge.maxMethodDataFrame(
        that: this,
      );

  /// Get a row of data from this dataframe.
  ///
  /// This method may be slow due to conversions between different data formats.
  Future<List<dynamic>> getRow({required int index, dynamic hint}) =>
      bridge.getRowMethodDataFrame(
        that: this,
        index: index,
      );

  /// Returns a [LazyFrame] to which operations can be applied lazily.
  /// As opposed to [LazyFrame], [DataFrame] by default applies its operations eagerly.
  ///
  /// This operation will fail if this dataframe is currently being shared, unless
  /// `allowCopy` is true in which case this dataframe will be copied.
  LazyFrame lazy(
          {bool allowCopy = false,
          bool? projectionPushdown,
          bool? predicatePushdown,
          bool? typeCoercion,
          bool? simplifyExpressions,
          bool? slicePushdown,
          bool? streaming,
          dynamic hint}) =>
      bridge.lazyMethodDataFrame(
        that: this,
        allowCopy: allowCopy,
        projectionPushdown: projectionPushdown,
        predicatePushdown: predicatePushdown,
        typeCoercion: typeCoercion,
        simplifyExpressions: simplifyExpressions,
        slicePushdown: slicePushdown,
        streaming: streaming,
      );
}

@freezed
class DataType with _$DataType {
  /// Boolean
  const factory DataType.boolean() = DataType_Boolean;

  /// Unsigned 8-bit integer
  const factory DataType.uInt8() = DataType_UInt8;

  /// Unsigned 16-bit integer
  const factory DataType.uInt16() = DataType_UInt16;

  /// Unsigned 32-bit integer
  const factory DataType.uInt32() = DataType_UInt32;

  /// Unsigned 64-bit integer
  const factory DataType.uInt64() = DataType_UInt64;

  /// Signed 8-bit integer
  const factory DataType.int8() = DataType_Int8;

  /// Signed 16-bit integer
  const factory DataType.int16() = DataType_Int16;

  /// Signed 32-bit integer
  const factory DataType.int32() = DataType_Int32;

  /// Signed 64-bit integer, the default [int] on native platforms.
  const factory DataType.int64() = DataType_Int64;

  /// Single-precision floating point number
  const factory DataType.float32() = DataType_Float32;

  /// Double-precision floating point number, aka a [double].
  const factory DataType.float64() = DataType_Float64;

  /// String data
  const factory DataType.utf8() = DataType_Utf8;

  /// Raw bytes.
  const factory DataType.binary() = DataType_Binary;

  /// A 32-bit date representing the elapsed time since UNIX epoch (1970-01-01)
  /// in days (32 bits).
  const factory DataType.date() = DataType_Date;

  /// A 64-bit date representing the elapsed time since UNIX epoch (1970-01-01)
  /// in the given timeunit (64 bits).
  const factory DataType.datetime(
    TimeUnit field0, [
    String? field1,
  ]) = DataType_Datetime;
  const factory DataType.duration(
    TimeUnit field0,
  ) = DataType_Duration;

  /// A 64-bit time representing the elapsed time since midnight in nanoseconds
  const factory DataType.time() = DataType_Time;
  const factory DataType.list(
    DataType field0,
  ) = DataType_List;

  /// A generic type that can be used in a `Series`
  /// &'static str can be used to determine/set inner type
  const factory DataType.unknown() = DataType_Unknown;
}

@freezed
class Expr with _$Expr {
  const factory Expr.columns(
    List<String> field0,
  ) = Expr_Columns;
  const factory Expr.dtypeColumn(
    List<DataType> field0,
  ) = Expr_DtypeColumn;
  const factory Expr.literal(
    LiteralValue field0,
  ) = Expr_Literal;
  const factory Expr.binaryExpr({
    required Expr left,
    required Operator op,
    required Expr right,
  }) = Expr_BinaryExpr;
  const factory Expr.cast({
    required Expr expr,
    required DataType dataType,
    required bool strict,
  }) = Expr_Cast;
  const factory Expr.sort({
    required Expr expr,
    required SortOptions options,
  }) = Expr_Sort;
  const factory Expr.take({
    required Expr expr,
    required Expr idx,
  }) = Expr_Take;
  const factory Expr.agg(
    AggExpr field0,
  ) = Expr_Agg;

  /// A ternary operation
  /// if true then "foo" else "bar"
  const factory Expr.ternary({
    required Expr predicate,
    required Expr truthy,
    required Expr falsy,
  }) = Expr_Ternary;
  const factory Expr.explode(
    Expr field0,
  ) = Expr_Explode;
  const factory Expr.filter({
    required Expr input,
    required Expr by,
  }) = Expr_Filter;

  /// See postgres window functions
  const factory Expr.wildcard() = Expr_Wildcard;
  const factory Expr.slice({
    required Expr input,

    /// length is not yet known so we accept negative offsets
    required Expr offset,
    required Expr length,
  }) = Expr_Slice;

  /// Can be used in a select statement to exclude a column from selection
  /// Set root name as Alias
  const factory Expr.keepName(
    Expr field0,
  ) = Expr_KeepName;

  /// Special case that does not need columns
  const factory Expr.count() = Expr_Count;

  /// Take the nth column in the `DataFrame`
  const factory Expr.nth(
    int field0,
  ) = Expr_Nth;
}

/// Lazily-evaluated version of a [DataFrame].
class LazyFrame {
  final PolarsWrapper bridge;
  final RwLockPLazyFrame field0;

  const LazyFrame({
    required this.bridge,
    required this.field0,
  });

  LazyFrame withColumn({required Expr expr, dynamic hint}) =>
      bridge.withColumnMethodLazyFrame(
        that: this,
        expr: expr,
      );
}

@freezed
class LiteralValue with _$LiteralValue {
  /// A binary true or false.
  const factory LiteralValue.boolean(
    bool field0,
  ) = LiteralValue_Boolean;

  /// A UTF8 encoded string type.
  const factory LiteralValue.utf8(
    String field0,
  ) = LiteralValue_Utf8;

  /// A raw binary array
  const factory LiteralValue.binary(
    Uint8List field0,
  ) = LiteralValue_Binary;

  /// An unsigned 8-bit integer number.
  const factory LiteralValue.uInt8(
    int field0,
  ) = LiteralValue_UInt8;

  /// An unsigned 16-bit integer number.
  const factory LiteralValue.uInt16(
    int field0,
  ) = LiteralValue_UInt16;

  /// An unsigned 32-bit integer number.
  const factory LiteralValue.uInt32(
    int field0,
  ) = LiteralValue_UInt32;

  /// An unsigned 64-bit integer number.
  const factory LiteralValue.uInt64(
    int field0,
  ) = LiteralValue_UInt64;

  /// An 8-bit integer number.
  const factory LiteralValue.int8(
    int field0,
  ) = LiteralValue_Int8;

  /// A 16-bit integer number.
  const factory LiteralValue.int16(
    int field0,
  ) = LiteralValue_Int16;

  /// A 32-bit integer number.
  const factory LiteralValue.int32(
    int field0,
  ) = LiteralValue_Int32;

  /// A 64-bit integer number.
  const factory LiteralValue.int64(
    int field0,
  ) = LiteralValue_Int64;

  /// A 32-bit floating point number.
  const factory LiteralValue.float32(
    double field0,
  ) = LiteralValue_Float32;

  /// A 64-bit floating point number.
  const factory LiteralValue.float64(
    double field0,
  ) = LiteralValue_Float64;
  const factory LiteralValue.range({
    required int low,
    required int high,
    required DataType dataType,
  }) = LiteralValue_Range;
  const factory LiteralValue.dateTime(
    DateTime field0,
    TimeUnit field1,
  ) = LiteralValue_DateTime;
  const factory LiteralValue.duration(
    Duration field0,
    TimeUnit field1,
  ) = LiteralValue_Duration;
}

enum Operator {
  Eq,
  NotEq,
  Lt,
  LtEq,
  Gt,
  GtEq,
  Plus,
  Minus,
  Multiply,
  Divide,
  TrueDivide,
  FloorDivide,
  Modulus,
  And,
  Or,
  Xor,
}

/// Represents a sequence of values of uniform type.
class Series {
  final PolarsWrapper bridge;

  /// @nodoc
  final RwLockPSeries field0;

  const Series({
    required this.bridge,
    required this.field0,
  });

  /// Create a new series of strings.
  /// Create a new series of 32-bit wide integers.
  static Series ofI32(
          {required PolarsWrapper bridge,
          required String name,
          Int32List? values,
          dynamic hint}) =>
      bridge.ofI32StaticMethodSeries(name: name, values: values, hint: hint);

  /// Create a new series of 64-bit wide integers.
  static Series ofI64(
          {required PolarsWrapper bridge,
          required String name,
          Int64List? values,
          dynamic hint}) =>
      bridge.ofI64StaticMethodSeries(name: name, values: values, hint: hint);

  /// Create a new series of [Duration]s.
  /// Create a new series of doubles.
  static Series ofF64(
          {required PolarsWrapper bridge,
          required String name,
          Float64List? values,
          dynamic hint}) =>
      bridge.ofF64StaticMethodSeries(name: name, values: values, hint: hint);

  /// Adds the contents of [other] onto this series.
  ///
  /// Throws if [other] is self.
  Future<void> append({required Series other, dynamic hint}) =>
      bridge.appendMethodSeries(
        that: this,
        other: other,
      );

  /// If this series is a UTF-8 series, returns its Dart representation.
  Future<List<String?>> asStrings({dynamic hint}) =>
      bridge.asStringsMethodSeries(
        that: this,
      );

  /// If this series is a 32-bit wide integer series, returns its Dart representation.
  Future<List<int?>> asI32({dynamic hint}) => bridge.asI32MethodSeries(
        that: this,
      );

  /// If this series is a double series, returns its Dart representation.
  Future<List<double?>> asF64({dynamic hint}) => bridge.asF64MethodSeries(
        that: this,
      );

  /// If this series contains [Duration]s, returns its Dart representation.
  Future<List<Duration?>> asDurations({dynamic hint}) =>
      bridge.asDurationsMethodSeries(
        that: this,
      );

  /// If this series contains [DateTime]s, returns its Dart representation.
  ///
  /// Datetimes are parsed as-is, without any timezone correction.
  Future<List<DateTime?>> asNaiveDatetime({dynamic hint}) =>
      bridge.asNaiveDatetimeMethodSeries(
        that: this,
      );

  /// If this series contains [DateTime]s, returns its Dart representation.
  ///
  /// If a timezone is defined by this series, the datetimes will be converted to UTC.
  /// Otherwise, the datetimes are assumed to be in UTC.
  Future<List<DateTime?>> asUtcDatetime({dynamic hint}) =>
      bridge.asUtcDatetimeMethodSeries(
        that: this,
      );

  /// If this series contains [DateTime]s, returns its Dart representation.
  ///
  /// If a timezone is defined by this series, the datetimes will be converted to the local timezone.
  /// Otherwise, the datetimes are assumed to be in the local timezone.
  Future<List<DateTime?>> asLocalDatetime({dynamic hint}) =>
      bridge.asLocalDatetimeMethodSeries(
        that: this,
      );

  /// Returns a new series with each value's absolute value.
  Future<Series> abs({dynamic hint}) => bridge.absMethodSeries(
        that: this,
      );

  /// Returns a new sorted series.
  Future<Series> sort({bool reverse = false, dynamic hint}) =>
      bridge.sortMethodSeries(
        that: this,
        reverse: reverse,
      );

  /// Returns a new shuffled series.
  Future<Series> shuffle({int? seed, dynamic hint}) =>
      bridge.shuffleMethodSeries(
        that: this,
        seed: seed,
      );

  /// Sums all non-null rows in this series to produce a result.
  ///
  /// Returns null if the series only contains null values.
  Future<double?> sum({dynamic hint}) => bridge.sumMethodSeries(
        that: this,
      );

  /// Returns the sum of this series' values as a single-element series.
  Future<Series> sumAsSeries({dynamic hint}) => bridge.sumAsSeriesMethodSeries(
        that: this,
      );

  /// Returns the minimum value of this series' values.
  ///
  /// Returns null if one of the values are also null.
  Future<double?> min({dynamic hint}) => bridge.minMethodSeries(
        that: this,
      );

  /// Returns the maximum value of this series' values.
  ///
  /// Returns null if one of the values are also null.
  Future<double?> max({dynamic hint}) => bridge.maxMethodSeries(
        that: this,
      );

  /// Expands a series of lists into rows of values, or strings into rows of characters.
  Future<Series> explode({dynamic hint}) => bridge.explodeMethodSeries(
        that: this,
      );

  /// TODO: docs
  Future<Series> explodeByOffsets({required Int64List offsets, dynamic hint}) =>
      bridge.explodeByOffsetsMethodSeries(
        that: this,
        offsets: offsets,
      );

  /// Calculates the cumulative max at each element.
  Future<Series> cummax({bool reverse = false, dynamic hint}) =>
      bridge.cummaxMethodSeries(
        that: this,
        reverse: reverse,
      );

  /// Calculates the cumulative min at each element.
  Future<Series> cummin({bool reverse = false, dynamic hint}) =>
      bridge.cumminMethodSeries(
        that: this,
        reverse: reverse,
      );

  /// Calculates the cumulative product at each element.
  Future<Series> cumprod({bool reverse = false, dynamic hint}) =>
      bridge.cumprodMethodSeries(
        that: this,
        reverse: reverse,
      );

  /// Calculates the cumulative sum at each element.
  Future<Series> cumsum({bool reverse = false, dynamic hint}) =>
      bridge.cumsumMethodSeries(
        that: this,
        reverse: reverse,
      );

  /// Calculates the product of each element in the series and returns it in a single-element series.
  Future<Series> product({dynamic hint}) => bridge.productMethodSeries(
        that: this,
      );

  /// Get the value at [index] as a string.
  String? getString({required int index, dynamic hint}) =>
      bridge.getStringMethodSeries(
        that: this,
        index: index,
      );

  /// Get the value at [index] as a double.
  double? get({required int index, dynamic hint}) => bridge.getMethodSeries(
        that: this,
        index: index,
      );

  /// Get the first few values of this series.
  Series head({int? length, dynamic hint}) => bridge.headMethodSeries(
        that: this,
        length: length,
      );

  /// Get the last few values of this series.
  Series tail({int? length, dynamic hint}) => bridge.tailMethodSeries(
        that: this,
        length: length,
      );

  /// Calculates the mean (average) of this series.
  Future<double?> mean({dynamic hint}) => bridge.meanMethodSeries(
        that: this,
      );

  /// Calculates the [median](https://en.wikipedia.org/wiki/Median) of this series.
  Future<double?> median({dynamic hint}) => bridge.medianMethodSeries(
        that: this,
      );

  /// Calculates and wraps this series' mean as a single-element series.
  Future<Series> meanAsSeries({dynamic hint}) =>
      bridge.meanAsSeriesMethodSeries(
        that: this,
      );

  /// Calculates and wraps this series' median as a single-element series.
  Future<Series> medianAsSeries({dynamic hint}) =>
      bridge.medianAsSeriesMethodSeries(
        that: this,
      );

  /// Returns the amount of bytes occupied by this series.
  int estimatedSize({dynamic hint}) => bridge.estimatedSizeMethodSeries(
        that: this,
      );

  /// Returns a new series with elements from this series added to [other]'s element-wise.
  Series addTo({required Series other, dynamic hint}) =>
      bridge.addToMethodSeries(
        that: this,
        other: other,
      );

  /// Returns a new series with elements from this series subtracted from [other]'s element-wise.
  Series subtract({required Series other, dynamic hint}) =>
      bridge.subtractMethodSeries(
        that: this,
        other: other,
      );

  /// Returns a new series with elements from this series multiplied with [other]'s element-wise.
  Series multiply({required Series other, dynamic hint}) =>
      bridge.multiplyMethodSeries(
        that: this,
        other: other,
      );

  /// Returns a new series with elements from this series divided by [other]'s element-wise.
  Series divide({required Series other, dynamic hint}) =>
      bridge.divideMethodSeries(
        that: this,
        other: other,
      );

  /// Returns a new series with the [remainder](https://en.wikipedia.org/wiki/Remainder)
  /// between this series' and [other]'s elements.
  Series remainder({required Series other, dynamic hint}) =>
      bridge.remainderMethodSeries(
        that: this,
        other: other,
      );

  /// Returns whether this is a series of booleans.
  bool isBool({dynamic hint}) => bridge.isBoolMethodSeries(
        that: this,
      );

  /// Returns whether this is a series of UTF-8 strings.
  bool isUtf8({dynamic hint}) => bridge.isUtf8MethodSeries(
        that: this,
      );

  /// Returns whether this is a series of numeric values.
  bool isNumeric({dynamic hint}) => bridge.isNumericMethodSeries(
        that: this,
      );

  /// Returns whether this is a series of [DateTime] or [Duration]s.
  bool isTemporal({dynamic hint}) => bridge.isTemporalMethodSeries(
        that: this,
      );

  /// Dump the contents of this entire series.
  Future<String> dump({dynamic hint}) => bridge.dumpMethodSeries(
        that: this,
      );

  /// Rename this series to [name] in-place.
  void rename({required String name, dynamic hint}) =>
      bridge.renameMethodSeries(
        that: this,
        name: name,
      );

  /// Returns the unique values of this series.
  ///
  /// If `stable` is true, extra work is done to maintain the original order of elements.
  Future<Series> unique({bool stable = false, dynamic hint}) =>
      bridge.uniqueMethodSeries(
        that: this,
        stable: stable,
      );

  /// Returns whether this series is identical to [other].
  ///
  /// if `ignoreNull` is true, null values are considered to be equal.
  Future<bool> equal(
          {required Series other, bool ignoreNull = false, dynamic hint}) =>
      bridge.equalMethodSeries(
        that: this,
        other: other,
        ignoreNull: ignoreNull,
      );

  /// Creates a new series with the specified dimensions.
  Future<Series> reshape({required Int64List dims, dynamic hint}) =>
      bridge.reshapeMethodSeries(
        that: this,
        dims: dims,
      );

  /// Calculates the standard deviation of this series with the specified degree of freedom.
  Future<Series> stdAsSeries({required int ddof, dynamic hint}) =>
      bridge.stdAsSeriesMethodSeries(
        that: this,
        ddof: ddof,
      );
}

/// Describes the shape of a [DataFrame].
class Shape {
  /// The number of rows.
  final int height;

  /// The number of columns.
  final int width;

  const Shape({
    required this.height,
    required this.width,
  });
}

/// Options for sorting
class SortOptions {
  /// Whether it should be sorted from smallest or largest.
  final bool descending;

  /// Whether nulls get pushed to the top or bottom.
  final bool nullsLast;

  const SortOptions({
    required this.descending,
    required this.nullsLast,
  });
}

enum TimeUnit {
  Nanoseconds,
  Microseconds,
  Milliseconds,
}

class PolarsWrapperImpl implements PolarsWrapper {
  final PolarsWrapperPlatform _platform;
  factory PolarsWrapperImpl(ExternalLibrary dylib) =>
      PolarsWrapperImpl.raw(PolarsWrapperPlatform(dylib));

  /// Only valid on web/WASM platforms.
  factory PolarsWrapperImpl.wasm(FutureOr<WasmModule> module) =>
      PolarsWrapperImpl(module as ExternalLibrary);
  PolarsWrapperImpl.raw(this._platform);
  Future<DataFrame> readCsv(
      {required String path,
      bool? hasHeader,
      int? delimiter,
      int? skipRows,
      int? skipRowsAfterHeader,
      int? chunkSize,
      dynamic hint}) {
    var arg0 = _platform.api2wire_String(path);
    var arg1 = _platform.api2wire_opt_box_autoadd_bool(hasHeader);
    var arg2 = _platform.api2wire_opt_box_autoadd_u8(delimiter);
    var arg3 = _platform.api2wire_opt_box_autoadd_usize(skipRows);
    var arg4 = _platform.api2wire_opt_box_autoadd_usize(skipRowsAfterHeader);
    var arg5 = _platform.api2wire_opt_box_autoadd_usize(chunkSize);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_read_csv(port_, arg0, arg1, arg2, arg3, arg4, arg5),
      parseSuccessData: (d) => _wire2api_data_frame(d),
      constMeta: kReadCsvConstMeta,
      argValues: [
        path,
        hasHeader,
        delimiter,
        skipRows,
        skipRowsAfterHeader,
        chunkSize
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kReadCsvConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "read_csv",
        argNames: [
          "path",
          "hasHeader",
          "delimiter",
          "skipRows",
          "skipRowsAfterHeader",
          "chunkSize"
        ],
      );

  Stream<List<dynamic>> iterMethodDataFrame(
      {required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeStream(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_iter__method__DataFrame(port_, arg0),
      parseSuccessData: _wire2api_list_dartabi,
      constMeta: kIterMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kIterMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "iter__method__DataFrame",
        argNames: ["that"],
      );

  Series columnMethodDataFrame(
      {required DataFrame that, required String column, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = _platform.api2wire_String(column);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_column__method__DataFrame(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kColumnMethodDataFrameConstMeta,
      argValues: [that, column],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kColumnMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "column__method__DataFrame",
        argNames: ["that", "column"],
      );

  List<Series> columnsMethodDataFrame(
      {required DataFrame that, required List<String> columns, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = _platform.api2wire_StringList(columns);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () =>
          _platform.inner.wire_columns__method__DataFrame(arg0, arg1),
      parseSuccessData: _wire2api_list_series,
      constMeta: kColumnsMethodDataFrameConstMeta,
      argValues: [that, columns],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kColumnsMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "columns__method__DataFrame",
        argNames: ["that", "columns"],
      );

  Future<String> dumpMethodDataFrame({required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_dump__method__DataFrame(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kDumpMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDumpMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "dump__method__DataFrame",
        argNames: ["that"],
      );

  int estimatedSizeMethodDataFrame({required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () =>
          _platform.inner.wire_estimated_size__method__DataFrame(arg0),
      parseSuccessData: _wire2api_usize,
      constMeta: kEstimatedSizeMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEstimatedSizeMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "estimated_size__method__DataFrame",
        argNames: ["that"],
      );

  Future<DataFrame> withRowCountMethodDataFrame(
      {required DataFrame that,
      required String name,
      int? offset,
      dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = _platform.api2wire_String(name);
    var arg2 = _platform.api2wire_opt_box_autoadd_u32(offset);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_with_row_count__method__DataFrame(port_, arg0, arg1, arg2),
      parseSuccessData: (d) => _wire2api_data_frame(d),
      constMeta: kWithRowCountMethodDataFrameConstMeta,
      argValues: [that, name, offset],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kWithRowCountMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "with_row_count__method__DataFrame",
        argNames: ["that", "name", "offset"],
      );

  List<String> getColumnNamesMethodDataFrame(
      {required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () =>
          _platform.inner.wire_get_column_names__method__DataFrame(arg0),
      parseSuccessData: _wire2api_StringList,
      constMeta: kGetColumnNamesMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetColumnNamesMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "get_column_names__method__DataFrame",
        argNames: ["that"],
      );

  Future<List<Series>> getColumnsMethodDataFrame(
      {required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_get_columns__method__DataFrame(port_, arg0),
      parseSuccessData: _wire2api_list_series,
      constMeta: kGetColumnsMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetColumnsMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "get_columns__method__DataFrame",
        argNames: ["that"],
      );

  int widthMethodDataFrame({required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_width__method__DataFrame(arg0),
      parseSuccessData: _wire2api_usize,
      constMeta: kWidthMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kWidthMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "width__method__DataFrame",
        argNames: ["that"],
      );

  int heightMethodDataFrame({required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_height__method__DataFrame(arg0),
      parseSuccessData: _wire2api_usize,
      constMeta: kHeightMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kHeightMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "height__method__DataFrame",
        argNames: ["that"],
      );

  bool isEmptyMethodDataFrame({required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_is_empty__method__DataFrame(arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kIsEmptyMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kIsEmptyMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "is_empty__method__DataFrame",
        argNames: ["that"],
      );

  Future<DataFrame> sampleMethodDataFrame(
      {required DataFrame that,
      required int n,
      bool withReplacement = false,
      bool shuffle = false,
      int? seed,
      dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = api2wire_usize(n);
    var arg2 = withReplacement;
    var arg3 = shuffle;
    var arg4 = _platform.api2wire_opt_box_autoadd_u64(seed);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_sample__method__DataFrame(port_, arg0, arg1, arg2, arg3, arg4),
      parseSuccessData: (d) => _wire2api_data_frame(d),
      constMeta: kSampleMethodDataFrameConstMeta,
      argValues: [that, n, withReplacement, shuffle, seed],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSampleMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "sample__method__DataFrame",
        argNames: ["that", "n", "withReplacement", "shuffle", "seed"],
      );

  DataFrame selectMethodDataFrame(
      {required DataFrame that, required List<String> columns, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = _platform.api2wire_StringList(columns);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_select__method__DataFrame(arg0, arg1),
      parseSuccessData: _wire2api_data_frame,
      constMeta: kSelectMethodDataFrameConstMeta,
      argValues: [that, columns],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSelectMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "select__method__DataFrame",
        argNames: ["that", "columns"],
      );

  DataFrame headMethodDataFrame(
      {required DataFrame that, int? length, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = _platform.api2wire_opt_box_autoadd_usize(length);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_head__method__DataFrame(arg0, arg1),
      parseSuccessData: _wire2api_data_frame,
      constMeta: kHeadMethodDataFrameConstMeta,
      argValues: [that, length],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kHeadMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "head__method__DataFrame",
        argNames: ["that", "length"],
      );

  DataFrame tailMethodDataFrame(
      {required DataFrame that, int? length, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = _platform.api2wire_opt_box_autoadd_usize(length);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_tail__method__DataFrame(arg0, arg1),
      parseSuccessData: _wire2api_data_frame,
      constMeta: kTailMethodDataFrameConstMeta,
      argValues: [that, length],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kTailMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "tail__method__DataFrame",
        argNames: ["that", "length"],
      );

  Future<DataFrame> describeMethodDataFrame(
      {required DataFrame that, Float64List? percentiles, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = _platform.api2wire_opt_float_64_list(percentiles);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_describe__method__DataFrame(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_data_frame(d),
      constMeta: kDescribeMethodDataFrameConstMeta,
      argValues: [that, percentiles],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDescribeMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "describe__method__DataFrame",
        argNames: ["that", "percentiles"],
      );

  DataFrame dropMethodDataFrame(
      {required DataFrame that, required String column, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = _platform.api2wire_String(column);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_drop__method__DataFrame(arg0, arg1),
      parseSuccessData: _wire2api_data_frame,
      constMeta: kDropMethodDataFrameConstMeta,
      argValues: [that, column],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDropMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "drop__method__DataFrame",
        argNames: ["that", "column"],
      );

  Series dropInPlaceMethodDataFrame(
      {required DataFrame that, required String column, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = _platform.api2wire_String(column);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () =>
          _platform.inner.wire_drop_in_place__method__DataFrame(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kDropInPlaceMethodDataFrameConstMeta,
      argValues: [that, column],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDropInPlaceMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "drop_in_place__method__DataFrame",
        argNames: ["that", "column"],
      );

  DataFrame reverseMethodDataFrame({required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_reverse__method__DataFrame(arg0),
      parseSuccessData: _wire2api_data_frame,
      constMeta: kReverseMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kReverseMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "reverse__method__DataFrame",
        argNames: ["that"],
      );

  Shape shapeMethodDataFrame({required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_shape__method__DataFrame(arg0),
      parseSuccessData: _wire2api_shape,
      constMeta: kShapeMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kShapeMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "shape__method__DataFrame",
        argNames: ["that"],
      );

  Future<DataFrame> maxMethodDataFrame(
      {required DataFrame that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_max__method__DataFrame(port_, arg0),
      parseSuccessData: (d) => _wire2api_data_frame(d),
      constMeta: kMaxMethodDataFrameConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMaxMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "max__method__DataFrame",
        argNames: ["that"],
      );

  Future<List<dynamic>> getRowMethodDataFrame(
      {required DataFrame that, required int index, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = api2wire_usize(index);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_get_row__method__DataFrame(port_, arg0, arg1),
      parseSuccessData: _wire2api_list_dartabi,
      constMeta: kGetRowMethodDataFrameConstMeta,
      argValues: [that, index],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetRowMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "get_row__method__DataFrame",
        argNames: ["that", "index"],
      );

  LazyFrame lazyMethodDataFrame(
      {required DataFrame that,
      bool allowCopy = false,
      bool? projectionPushdown,
      bool? predicatePushdown,
      bool? typeCoercion,
      bool? simplifyExpressions,
      bool? slicePushdown,
      bool? streaming,
      dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_data_frame(that);
    var arg1 = allowCopy;
    var arg2 = _platform.api2wire_opt_box_autoadd_bool(projectionPushdown);
    var arg3 = _platform.api2wire_opt_box_autoadd_bool(predicatePushdown);
    var arg4 = _platform.api2wire_opt_box_autoadd_bool(typeCoercion);
    var arg5 = _platform.api2wire_opt_box_autoadd_bool(simplifyExpressions);
    var arg6 = _platform.api2wire_opt_box_autoadd_bool(slicePushdown);
    var arg7 = _platform.api2wire_opt_box_autoadd_bool(streaming);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_lazy__method__DataFrame(
          arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7),
      parseSuccessData: _wire2api_lazy_frame,
      constMeta: kLazyMethodDataFrameConstMeta,
      argValues: [
        that,
        allowCopy,
        projectionPushdown,
        predicatePushdown,
        typeCoercion,
        simplifyExpressions,
        slicePushdown,
        streaming
      ],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kLazyMethodDataFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "lazy__method__DataFrame",
        argNames: [
          "that",
          "allowCopy",
          "projectionPushdown",
          "predicatePushdown",
          "typeCoercion",
          "simplifyExpressions",
          "slicePushdown",
          "streaming"
        ],
      );

  LazyFrame withColumnMethodLazyFrame(
      {required LazyFrame that, required Expr expr, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_lazy_frame(that);
    var arg1 = _platform.api2wire_box_autoadd_expr(expr);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () =>
          _platform.inner.wire_with_column__method__LazyFrame(arg0, arg1),
      parseSuccessData: _wire2api_lazy_frame,
      constMeta: kWithColumnMethodLazyFrameConstMeta,
      argValues: [that, expr],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kWithColumnMethodLazyFrameConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "with_column__method__LazyFrame",
        argNames: ["that", "expr"],
      );

  Series ofI32StaticMethodSeries(
      {required String name, Int32List? values, dynamic hint}) {
    var arg0 = _platform.api2wire_String(name);
    var arg1 = _platform.api2wire_opt_int_32_list(values);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () =>
          _platform.inner.wire_of_i32__static_method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kOfI32StaticMethodSeriesConstMeta,
      argValues: [name, values],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kOfI32StaticMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "of_i32__static_method__Series",
        argNames: ["name", "values"],
      );

  Series ofI64StaticMethodSeries(
      {required String name, Int64List? values, dynamic hint}) {
    var arg0 = _platform.api2wire_String(name);
    var arg1 = _platform.api2wire_opt_int_64_list(values);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () =>
          _platform.inner.wire_of_i64__static_method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kOfI64StaticMethodSeriesConstMeta,
      argValues: [name, values],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kOfI64StaticMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "of_i64__static_method__Series",
        argNames: ["name", "values"],
      );

  Series ofF64StaticMethodSeries(
      {required String name, Float64List? values, dynamic hint}) {
    var arg0 = _platform.api2wire_String(name);
    var arg1 = _platform.api2wire_opt_float_64_list(values);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () =>
          _platform.inner.wire_of_f64__static_method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kOfF64StaticMethodSeriesConstMeta,
      argValues: [name, values],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kOfF64StaticMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "of_f64__static_method__Series",
        argNames: ["name", "values"],
      );

  Future<void> appendMethodSeries(
      {required Series that, required Series other, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_box_autoadd_series(other);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_append__method__Series(port_, arg0, arg1),
      parseSuccessData: _wire2api_unit,
      constMeta: kAppendMethodSeriesConstMeta,
      argValues: [that, other],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAppendMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "append__method__Series",
        argNames: ["that", "other"],
      );

  Future<List<String?>> asStringsMethodSeries(
      {required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_as_strings__method__Series(port_, arg0),
      parseSuccessData: _wire2api_list_opt_String,
      constMeta: kAsStringsMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsStringsMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "as_strings__method__Series",
        argNames: ["that"],
      );

  Future<List<int?>> asI32MethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_as_i32__method__Series(port_, arg0),
      parseSuccessData: _wire2api_list_opt_box_autoadd_i32,
      constMeta: kAsI32MethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsI32MethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "as_i32__method__Series",
        argNames: ["that"],
      );

  Future<List<double?>> asF64MethodSeries(
      {required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_as_f64__method__Series(port_, arg0),
      parseSuccessData: _wire2api_list_opt_box_autoadd_f64,
      constMeta: kAsF64MethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsF64MethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "as_f64__method__Series",
        argNames: ["that"],
      );

  Future<List<Duration?>> asDurationsMethodSeries(
      {required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_as_durations__method__Series(port_, arg0),
      parseSuccessData: _wire2api_list_opt_Chrono_Duration,
      constMeta: kAsDurationsMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsDurationsMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "as_durations__method__Series",
        argNames: ["that"],
      );

  Future<List<DateTime?>> asNaiveDatetimeMethodSeries(
      {required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_as_naive_datetime__method__Series(port_, arg0),
      parseSuccessData: _wire2api_list_opt_Chrono_Naive,
      constMeta: kAsNaiveDatetimeMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsNaiveDatetimeMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "as_naive_datetime__method__Series",
        argNames: ["that"],
      );

  Future<List<DateTime?>> asUtcDatetimeMethodSeries(
      {required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_as_utc_datetime__method__Series(port_, arg0),
      parseSuccessData: _wire2api_list_opt_Chrono_Utc,
      constMeta: kAsUtcDatetimeMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsUtcDatetimeMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "as_utc_datetime__method__Series",
        argNames: ["that"],
      );

  Future<List<DateTime?>> asLocalDatetimeMethodSeries(
      {required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_as_local_datetime__method__Series(port_, arg0),
      parseSuccessData: _wire2api_list_opt_Chrono_Local,
      constMeta: kAsLocalDatetimeMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAsLocalDatetimeMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "as_local_datetime__method__Series",
        argNames: ["that"],
      );

  Future<Series> absMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_abs__method__Series(port_, arg0),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kAbsMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAbsMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "abs__method__Series",
        argNames: ["that"],
      );

  Future<Series> sortMethodSeries(
      {required Series that, bool reverse = false, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = reverse;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_sort__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kSortMethodSeriesConstMeta,
      argValues: [that, reverse],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSortMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "sort__method__Series",
        argNames: ["that", "reverse"],
      );

  Future<Series> shuffleMethodSeries(
      {required Series that, int? seed, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_opt_box_autoadd_u64(seed);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_shuffle__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kShuffleMethodSeriesConstMeta,
      argValues: [that, seed],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kShuffleMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "shuffle__method__Series",
        argNames: ["that", "seed"],
      );

  Future<double?> sumMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_sum__method__Series(port_, arg0),
      parseSuccessData: _wire2api_opt_box_autoadd_f64,
      constMeta: kSumMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSumMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "sum__method__Series",
        argNames: ["that"],
      );

  Future<Series> sumAsSeriesMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_sum_as_series__method__Series(port_, arg0),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kSumAsSeriesMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSumAsSeriesMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "sum_as_series__method__Series",
        argNames: ["that"],
      );

  Future<double?> minMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_min__method__Series(port_, arg0),
      parseSuccessData: _wire2api_opt_box_autoadd_f64,
      constMeta: kMinMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMinMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "min__method__Series",
        argNames: ["that"],
      );

  Future<double?> maxMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner.wire_max__method__Series(port_, arg0),
      parseSuccessData: _wire2api_opt_box_autoadd_f64,
      constMeta: kMaxMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMaxMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "max__method__Series",
        argNames: ["that"],
      );

  Future<Series> explodeMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_explode__method__Series(port_, arg0),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kExplodeMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kExplodeMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "explode__method__Series",
        argNames: ["that"],
      );

  Future<Series> explodeByOffsetsMethodSeries(
      {required Series that, required Int64List offsets, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_int_64_list(offsets);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) => _platform.inner
          .wire_explode_by_offsets__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kExplodeByOffsetsMethodSeriesConstMeta,
      argValues: [that, offsets],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kExplodeByOffsetsMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "explode_by_offsets__method__Series",
        argNames: ["that", "offsets"],
      );

  Future<Series> cummaxMethodSeries(
      {required Series that, bool reverse = false, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = reverse;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_cummax__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kCummaxMethodSeriesConstMeta,
      argValues: [that, reverse],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCummaxMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "cummax__method__Series",
        argNames: ["that", "reverse"],
      );

  Future<Series> cumminMethodSeries(
      {required Series that, bool reverse = false, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = reverse;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_cummin__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kCumminMethodSeriesConstMeta,
      argValues: [that, reverse],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCumminMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "cummin__method__Series",
        argNames: ["that", "reverse"],
      );

  Future<Series> cumprodMethodSeries(
      {required Series that, bool reverse = false, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = reverse;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_cumprod__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kCumprodMethodSeriesConstMeta,
      argValues: [that, reverse],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCumprodMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "cumprod__method__Series",
        argNames: ["that", "reverse"],
      );

  Future<Series> cumsumMethodSeries(
      {required Series that, bool reverse = false, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = reverse;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_cumsum__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kCumsumMethodSeriesConstMeta,
      argValues: [that, reverse],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kCumsumMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "cumsum__method__Series",
        argNames: ["that", "reverse"],
      );

  Future<Series> productMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_product__method__Series(port_, arg0),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kProductMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kProductMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "product__method__Series",
        argNames: ["that"],
      );

  String? getStringMethodSeries(
      {required Series that, required int index, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = api2wire_usize(index);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () =>
          _platform.inner.wire_get_string__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_opt_String,
      constMeta: kGetStringMethodSeriesConstMeta,
      argValues: [that, index],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetStringMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "get_string__method__Series",
        argNames: ["that", "index"],
      );

  double? getMethodSeries(
      {required Series that, required int index, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = api2wire_usize(index);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_get__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_opt_box_autoadd_f64,
      constMeta: kGetMethodSeriesConstMeta,
      argValues: [that, index],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kGetMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "get__method__Series",
        argNames: ["that", "index"],
      );

  Series headMethodSeries({required Series that, int? length, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_opt_box_autoadd_usize(length);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_head__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kHeadMethodSeriesConstMeta,
      argValues: [that, length],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kHeadMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "head__method__Series",
        argNames: ["that", "length"],
      );

  Series tailMethodSeries({required Series that, int? length, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_opt_box_autoadd_usize(length);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_tail__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kTailMethodSeriesConstMeta,
      argValues: [that, length],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kTailMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "tail__method__Series",
        argNames: ["that", "length"],
      );

  Future<double?> meanMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_mean__method__Series(port_, arg0),
      parseSuccessData: _wire2api_opt_box_autoadd_f64,
      constMeta: kMeanMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMeanMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "mean__method__Series",
        argNames: ["that"],
      );

  Future<double?> medianMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_median__method__Series(port_, arg0),
      parseSuccessData: _wire2api_opt_box_autoadd_f64,
      constMeta: kMedianMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMedianMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "median__method__Series",
        argNames: ["that"],
      );

  Future<Series> meanAsSeriesMethodSeries(
      {required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_mean_as_series__method__Series(port_, arg0),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kMeanAsSeriesMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMeanAsSeriesMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "mean_as_series__method__Series",
        argNames: ["that"],
      );

  Future<Series> medianAsSeriesMethodSeries(
      {required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_median_as_series__method__Series(port_, arg0),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kMedianAsSeriesMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMedianAsSeriesMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "median_as_series__method__Series",
        argNames: ["that"],
      );

  int estimatedSizeMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_estimated_size__method__Series(arg0),
      parseSuccessData: _wire2api_usize,
      constMeta: kEstimatedSizeMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEstimatedSizeMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "estimated_size__method__Series",
        argNames: ["that"],
      );

  Series addToMethodSeries(
      {required Series that, required Series other, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_box_autoadd_series(other);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_add_to__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kAddToMethodSeriesConstMeta,
      argValues: [that, other],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kAddToMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "add_to__method__Series",
        argNames: ["that", "other"],
      );

  Series subtractMethodSeries(
      {required Series that, required Series other, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_box_autoadd_series(other);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_subtract__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kSubtractMethodSeriesConstMeta,
      argValues: [that, other],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kSubtractMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "subtract__method__Series",
        argNames: ["that", "other"],
      );

  Series multiplyMethodSeries(
      {required Series that, required Series other, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_box_autoadd_series(other);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_multiply__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kMultiplyMethodSeriesConstMeta,
      argValues: [that, other],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kMultiplyMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "multiply__method__Series",
        argNames: ["that", "other"],
      );

  Series divideMethodSeries(
      {required Series that, required Series other, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_box_autoadd_series(other);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_divide__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kDivideMethodSeriesConstMeta,
      argValues: [that, other],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDivideMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "divide__method__Series",
        argNames: ["that", "other"],
      );

  Series remainderMethodSeries(
      {required Series that, required Series other, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_box_autoadd_series(other);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_remainder__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_series,
      constMeta: kRemainderMethodSeriesConstMeta,
      argValues: [that, other],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kRemainderMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "remainder__method__Series",
        argNames: ["that", "other"],
      );

  bool isBoolMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_is_bool__method__Series(arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kIsBoolMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kIsBoolMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "is_bool__method__Series",
        argNames: ["that"],
      );

  bool isUtf8MethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_is_utf8__method__Series(arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kIsUtf8MethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kIsUtf8MethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "is_utf8__method__Series",
        argNames: ["that"],
      );

  bool isNumericMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_is_numeric__method__Series(arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kIsNumericMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kIsNumericMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "is_numeric__method__Series",
        argNames: ["that"],
      );

  bool isTemporalMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_is_temporal__method__Series(arg0),
      parseSuccessData: _wire2api_bool,
      constMeta: kIsTemporalMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kIsTemporalMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "is_temporal__method__Series",
        argNames: ["that"],
      );

  Future<String> dumpMethodSeries({required Series that, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_dump__method__Series(port_, arg0),
      parseSuccessData: _wire2api_String,
      constMeta: kDumpMethodSeriesConstMeta,
      argValues: [that],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kDumpMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "dump__method__Series",
        argNames: ["that"],
      );

  void renameMethodSeries(
      {required Series that, required String name, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_String(name);
    return _platform.executeSync(FlutterRustBridgeSyncTask(
      callFfi: () => _platform.inner.wire_rename__method__Series(arg0, arg1),
      parseSuccessData: _wire2api_unit,
      constMeta: kRenameMethodSeriesConstMeta,
      argValues: [that, name],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kRenameMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "rename__method__Series",
        argNames: ["that", "name"],
      );

  Future<Series> uniqueMethodSeries(
      {required Series that, bool stable = false, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = stable;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_unique__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kUniqueMethodSeriesConstMeta,
      argValues: [that, stable],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kUniqueMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "unique__method__Series",
        argNames: ["that", "stable"],
      );

  Future<bool> equalMethodSeries(
      {required Series that,
      required Series other,
      bool ignoreNull = false,
      dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_box_autoadd_series(other);
    var arg2 = ignoreNull;
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_equal__method__Series(port_, arg0, arg1, arg2),
      parseSuccessData: _wire2api_bool,
      constMeta: kEqualMethodSeriesConstMeta,
      argValues: [that, other, ignoreNull],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kEqualMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "equal__method__Series",
        argNames: ["that", "other", "ignoreNull"],
      );

  Future<Series> reshapeMethodSeries(
      {required Series that, required Int64List dims, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = _platform.api2wire_int_64_list(dims);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_reshape__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kReshapeMethodSeriesConstMeta,
      argValues: [that, dims],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kReshapeMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "reshape__method__Series",
        argNames: ["that", "dims"],
      );

  Future<Series> stdAsSeriesMethodSeries(
      {required Series that, required int ddof, dynamic hint}) {
    var arg0 = _platform.api2wire_box_autoadd_series(that);
    var arg1 = api2wire_u8(ddof);
    return _platform.executeNormal(FlutterRustBridgeTask(
      callFfi: (port_) =>
          _platform.inner.wire_std_as_series__method__Series(port_, arg0, arg1),
      parseSuccessData: (d) => _wire2api_series(d),
      constMeta: kStdAsSeriesMethodSeriesConstMeta,
      argValues: [that, ddof],
      hint: hint,
    ));
  }

  FlutterRustBridgeTaskConstMeta get kStdAsSeriesMethodSeriesConstMeta =>
      const FlutterRustBridgeTaskConstMeta(
        debugName: "std_as_series__method__Series",
        argNames: ["that", "ddof"],
      );

  DropFnType get dropOpaqueRwLockPDataFrame =>
      _platform.inner.drop_opaque_RwLockPDataFrame;
  ShareFnType get shareOpaqueRwLockPDataFrame =>
      _platform.inner.share_opaque_RwLockPDataFrame;
  OpaqueTypeFinalizer get RwLockPDataFrameFinalizer =>
      _platform.RwLockPDataFrameFinalizer;

  DropFnType get dropOpaqueRwLockPLazyFrame =>
      _platform.inner.drop_opaque_RwLockPLazyFrame;
  ShareFnType get shareOpaqueRwLockPLazyFrame =>
      _platform.inner.share_opaque_RwLockPLazyFrame;
  OpaqueTypeFinalizer get RwLockPLazyFrameFinalizer =>
      _platform.RwLockPLazyFrameFinalizer;

  DropFnType get dropOpaqueRwLockPSeries =>
      _platform.inner.drop_opaque_RwLockPSeries;
  ShareFnType get shareOpaqueRwLockPSeries =>
      _platform.inner.share_opaque_RwLockPSeries;
  OpaqueTypeFinalizer get RwLockPSeriesFinalizer =>
      _platform.RwLockPSeriesFinalizer;

  void dispose() {
    _platform.dispose();
  }
// Section: wire2api

  Duration _wire2api_Chrono_Duration(dynamic raw) {
    return wire2apiDuration(_wire2api_i64(raw));
  }

  DateTime _wire2api_Chrono_Local(dynamic raw) {
    return wire2apiTimestamp(ts: _wire2api_i64(raw), isUtc: false);
  }

  DateTime _wire2api_Chrono_Naive(dynamic raw) {
    return wire2apiTimestamp(ts: _wire2api_i64(raw), isUtc: true);
  }

  DateTime _wire2api_Chrono_Utc(dynamic raw) {
    return wire2apiTimestamp(ts: _wire2api_i64(raw), isUtc: true);
  }

  RwLockPDataFrame _wire2api_RwLockPDataFrame(dynamic raw) {
    return RwLockPDataFrame.fromRaw(raw[0], raw[1], this);
  }

  RwLockPLazyFrame _wire2api_RwLockPLazyFrame(dynamic raw) {
    return RwLockPLazyFrame.fromRaw(raw[0], raw[1], this);
  }

  RwLockPSeries _wire2api_RwLockPSeries(dynamic raw) {
    return RwLockPSeries.fromRaw(raw[0], raw[1], this);
  }

  String _wire2api_String(dynamic raw) {
    return raw as String;
  }

  List<String> _wire2api_StringList(dynamic raw) {
    return (raw as List<dynamic>).cast<String>();
  }

  bool _wire2api_bool(dynamic raw) {
    return raw as bool;
  }

  double _wire2api_box_autoadd_f64(dynamic raw) {
    return raw as double;
  }

  int _wire2api_box_autoadd_i32(dynamic raw) {
    return raw as int;
  }

  dynamic _wire2api_dartabi(dynamic raw) {
    return raw;
  }

  DataFrame _wire2api_data_frame(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return DataFrame(
      bridge: this,
      field0: _wire2api_RwLockPDataFrame(arr[0]),
    );
  }

  double _wire2api_f64(dynamic raw) {
    return raw as double;
  }

  int _wire2api_i32(dynamic raw) {
    return raw as int;
  }

  int _wire2api_i64(dynamic raw) {
    return castInt(raw);
  }

  LazyFrame _wire2api_lazy_frame(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return LazyFrame(
      bridge: this,
      field0: _wire2api_RwLockPLazyFrame(arr[0]),
    );
  }

  List<dynamic> _wire2api_list_dartabi(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_dartabi).toList();
  }

  List<Duration?> _wire2api_list_opt_Chrono_Duration(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_opt_Chrono_Duration).toList();
  }

  List<DateTime?> _wire2api_list_opt_Chrono_Local(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_opt_Chrono_Local).toList();
  }

  List<DateTime?> _wire2api_list_opt_Chrono_Naive(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_opt_Chrono_Naive).toList();
  }

  List<DateTime?> _wire2api_list_opt_Chrono_Utc(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_opt_Chrono_Utc).toList();
  }

  List<String?> _wire2api_list_opt_String(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_opt_String).toList();
  }

  List<double?> _wire2api_list_opt_box_autoadd_f64(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_opt_box_autoadd_f64).toList();
  }

  List<int?> _wire2api_list_opt_box_autoadd_i32(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_opt_box_autoadd_i32).toList();
  }

  List<Series> _wire2api_list_series(dynamic raw) {
    return (raw as List<dynamic>).map(_wire2api_series).toList();
  }

  Duration? _wire2api_opt_Chrono_Duration(dynamic raw) {
    return raw == null ? null : _wire2api_Chrono_Duration(raw);
  }

  DateTime? _wire2api_opt_Chrono_Local(dynamic raw) {
    return raw == null ? null : _wire2api_Chrono_Local(raw);
  }

  DateTime? _wire2api_opt_Chrono_Naive(dynamic raw) {
    return raw == null ? null : _wire2api_Chrono_Naive(raw);
  }

  DateTime? _wire2api_opt_Chrono_Utc(dynamic raw) {
    return raw == null ? null : _wire2api_Chrono_Utc(raw);
  }

  String? _wire2api_opt_String(dynamic raw) {
    return raw == null ? null : _wire2api_String(raw);
  }

  double? _wire2api_opt_box_autoadd_f64(dynamic raw) {
    return raw == null ? null : _wire2api_box_autoadd_f64(raw);
  }

  int? _wire2api_opt_box_autoadd_i32(dynamic raw) {
    return raw == null ? null : _wire2api_box_autoadd_i32(raw);
  }

  Series _wire2api_series(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Series(
      bridge: this,
      field0: _wire2api_RwLockPSeries(arr[0]),
    );
  }

  Shape _wire2api_shape(dynamic raw) {
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Shape(
      height: _wire2api_usize(arr[0]),
      width: _wire2api_usize(arr[1]),
    );
  }

  int _wire2api_u8(dynamic raw) {
    return raw as int;
  }

  Uint8List _wire2api_uint_8_list(dynamic raw) {
    return raw as Uint8List;
  }

  void _wire2api_unit(dynamic raw) {
    return;
  }

  int _wire2api_usize(dynamic raw) {
    return castInt(raw);
  }
}

// Section: api2wire

@protected
bool api2wire_bool(bool raw) {
  return raw;
}

@protected
double api2wire_f32(double raw) {
  return raw;
}

@protected
double api2wire_f64(double raw) {
  return raw;
}

@protected
int api2wire_i16(int raw) {
  return raw;
}

@protected
int api2wire_i32(int raw) {
  return raw;
}

@protected
int api2wire_i8(int raw) {
  return raw;
}

@protected
int api2wire_operator(Operator raw) {
  return api2wire_i32(raw.index);
}

@protected
int api2wire_time_unit(TimeUnit raw) {
  return api2wire_i32(raw.index);
}

@protected
int api2wire_u16(int raw) {
  return raw;
}

@protected
int api2wire_u32(int raw) {
  return raw;
}

@protected
int api2wire_u8(int raw) {
  return raw;
}

@protected
int api2wire_usize(int raw) {
  return raw;
}
// Section: finalizer
